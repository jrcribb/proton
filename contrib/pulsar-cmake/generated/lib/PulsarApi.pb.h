// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PulsarApi.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_PulsarApi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_PulsarApi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_PulsarApi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_PulsarApi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[72]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace pulsar {
namespace proto {
class AuthData;
struct AuthDataDefaultTypeInternal;
extern AuthDataDefaultTypeInternal _AuthData_default_instance_;
class BaseCommand;
struct BaseCommandDefaultTypeInternal;
extern BaseCommandDefaultTypeInternal _BaseCommand_default_instance_;
class BrokerEntryMetadata;
struct BrokerEntryMetadataDefaultTypeInternal;
extern BrokerEntryMetadataDefaultTypeInternal _BrokerEntryMetadata_default_instance_;
class CommandAck;
struct CommandAckDefaultTypeInternal;
extern CommandAckDefaultTypeInternal _CommandAck_default_instance_;
class CommandAckResponse;
struct CommandAckResponseDefaultTypeInternal;
extern CommandAckResponseDefaultTypeInternal _CommandAckResponse_default_instance_;
class CommandActiveConsumerChange;
struct CommandActiveConsumerChangeDefaultTypeInternal;
extern CommandActiveConsumerChangeDefaultTypeInternal _CommandActiveConsumerChange_default_instance_;
class CommandAddPartitionToTxn;
struct CommandAddPartitionToTxnDefaultTypeInternal;
extern CommandAddPartitionToTxnDefaultTypeInternal _CommandAddPartitionToTxn_default_instance_;
class CommandAddPartitionToTxnResponse;
struct CommandAddPartitionToTxnResponseDefaultTypeInternal;
extern CommandAddPartitionToTxnResponseDefaultTypeInternal _CommandAddPartitionToTxnResponse_default_instance_;
class CommandAddSubscriptionToTxn;
struct CommandAddSubscriptionToTxnDefaultTypeInternal;
extern CommandAddSubscriptionToTxnDefaultTypeInternal _CommandAddSubscriptionToTxn_default_instance_;
class CommandAddSubscriptionToTxnResponse;
struct CommandAddSubscriptionToTxnResponseDefaultTypeInternal;
extern CommandAddSubscriptionToTxnResponseDefaultTypeInternal _CommandAddSubscriptionToTxnResponse_default_instance_;
class CommandAuthChallenge;
struct CommandAuthChallengeDefaultTypeInternal;
extern CommandAuthChallengeDefaultTypeInternal _CommandAuthChallenge_default_instance_;
class CommandAuthResponse;
struct CommandAuthResponseDefaultTypeInternal;
extern CommandAuthResponseDefaultTypeInternal _CommandAuthResponse_default_instance_;
class CommandCloseConsumer;
struct CommandCloseConsumerDefaultTypeInternal;
extern CommandCloseConsumerDefaultTypeInternal _CommandCloseConsumer_default_instance_;
class CommandCloseProducer;
struct CommandCloseProducerDefaultTypeInternal;
extern CommandCloseProducerDefaultTypeInternal _CommandCloseProducer_default_instance_;
class CommandConnect;
struct CommandConnectDefaultTypeInternal;
extern CommandConnectDefaultTypeInternal _CommandConnect_default_instance_;
class CommandConnected;
struct CommandConnectedDefaultTypeInternal;
extern CommandConnectedDefaultTypeInternal _CommandConnected_default_instance_;
class CommandConsumerStats;
struct CommandConsumerStatsDefaultTypeInternal;
extern CommandConsumerStatsDefaultTypeInternal _CommandConsumerStats_default_instance_;
class CommandConsumerStatsResponse;
struct CommandConsumerStatsResponseDefaultTypeInternal;
extern CommandConsumerStatsResponseDefaultTypeInternal _CommandConsumerStatsResponse_default_instance_;
class CommandEndTxn;
struct CommandEndTxnDefaultTypeInternal;
extern CommandEndTxnDefaultTypeInternal _CommandEndTxn_default_instance_;
class CommandEndTxnOnPartition;
struct CommandEndTxnOnPartitionDefaultTypeInternal;
extern CommandEndTxnOnPartitionDefaultTypeInternal _CommandEndTxnOnPartition_default_instance_;
class CommandEndTxnOnPartitionResponse;
struct CommandEndTxnOnPartitionResponseDefaultTypeInternal;
extern CommandEndTxnOnPartitionResponseDefaultTypeInternal _CommandEndTxnOnPartitionResponse_default_instance_;
class CommandEndTxnOnSubscription;
struct CommandEndTxnOnSubscriptionDefaultTypeInternal;
extern CommandEndTxnOnSubscriptionDefaultTypeInternal _CommandEndTxnOnSubscription_default_instance_;
class CommandEndTxnOnSubscriptionResponse;
struct CommandEndTxnOnSubscriptionResponseDefaultTypeInternal;
extern CommandEndTxnOnSubscriptionResponseDefaultTypeInternal _CommandEndTxnOnSubscriptionResponse_default_instance_;
class CommandEndTxnResponse;
struct CommandEndTxnResponseDefaultTypeInternal;
extern CommandEndTxnResponseDefaultTypeInternal _CommandEndTxnResponse_default_instance_;
class CommandError;
struct CommandErrorDefaultTypeInternal;
extern CommandErrorDefaultTypeInternal _CommandError_default_instance_;
class CommandFlow;
struct CommandFlowDefaultTypeInternal;
extern CommandFlowDefaultTypeInternal _CommandFlow_default_instance_;
class CommandGetLastMessageId;
struct CommandGetLastMessageIdDefaultTypeInternal;
extern CommandGetLastMessageIdDefaultTypeInternal _CommandGetLastMessageId_default_instance_;
class CommandGetLastMessageIdResponse;
struct CommandGetLastMessageIdResponseDefaultTypeInternal;
extern CommandGetLastMessageIdResponseDefaultTypeInternal _CommandGetLastMessageIdResponse_default_instance_;
class CommandGetOrCreateSchema;
struct CommandGetOrCreateSchemaDefaultTypeInternal;
extern CommandGetOrCreateSchemaDefaultTypeInternal _CommandGetOrCreateSchema_default_instance_;
class CommandGetOrCreateSchemaResponse;
struct CommandGetOrCreateSchemaResponseDefaultTypeInternal;
extern CommandGetOrCreateSchemaResponseDefaultTypeInternal _CommandGetOrCreateSchemaResponse_default_instance_;
class CommandGetSchema;
struct CommandGetSchemaDefaultTypeInternal;
extern CommandGetSchemaDefaultTypeInternal _CommandGetSchema_default_instance_;
class CommandGetSchemaResponse;
struct CommandGetSchemaResponseDefaultTypeInternal;
extern CommandGetSchemaResponseDefaultTypeInternal _CommandGetSchemaResponse_default_instance_;
class CommandGetTopicsOfNamespace;
struct CommandGetTopicsOfNamespaceDefaultTypeInternal;
extern CommandGetTopicsOfNamespaceDefaultTypeInternal _CommandGetTopicsOfNamespace_default_instance_;
class CommandGetTopicsOfNamespaceResponse;
struct CommandGetTopicsOfNamespaceResponseDefaultTypeInternal;
extern CommandGetTopicsOfNamespaceResponseDefaultTypeInternal _CommandGetTopicsOfNamespaceResponse_default_instance_;
class CommandLookupTopic;
struct CommandLookupTopicDefaultTypeInternal;
extern CommandLookupTopicDefaultTypeInternal _CommandLookupTopic_default_instance_;
class CommandLookupTopicResponse;
struct CommandLookupTopicResponseDefaultTypeInternal;
extern CommandLookupTopicResponseDefaultTypeInternal _CommandLookupTopicResponse_default_instance_;
class CommandMessage;
struct CommandMessageDefaultTypeInternal;
extern CommandMessageDefaultTypeInternal _CommandMessage_default_instance_;
class CommandNewTxn;
struct CommandNewTxnDefaultTypeInternal;
extern CommandNewTxnDefaultTypeInternal _CommandNewTxn_default_instance_;
class CommandNewTxnResponse;
struct CommandNewTxnResponseDefaultTypeInternal;
extern CommandNewTxnResponseDefaultTypeInternal _CommandNewTxnResponse_default_instance_;
class CommandPartitionedTopicMetadata;
struct CommandPartitionedTopicMetadataDefaultTypeInternal;
extern CommandPartitionedTopicMetadataDefaultTypeInternal _CommandPartitionedTopicMetadata_default_instance_;
class CommandPartitionedTopicMetadataResponse;
struct CommandPartitionedTopicMetadataResponseDefaultTypeInternal;
extern CommandPartitionedTopicMetadataResponseDefaultTypeInternal _CommandPartitionedTopicMetadataResponse_default_instance_;
class CommandPing;
struct CommandPingDefaultTypeInternal;
extern CommandPingDefaultTypeInternal _CommandPing_default_instance_;
class CommandPong;
struct CommandPongDefaultTypeInternal;
extern CommandPongDefaultTypeInternal _CommandPong_default_instance_;
class CommandProducer;
struct CommandProducerDefaultTypeInternal;
extern CommandProducerDefaultTypeInternal _CommandProducer_default_instance_;
class CommandProducerSuccess;
struct CommandProducerSuccessDefaultTypeInternal;
extern CommandProducerSuccessDefaultTypeInternal _CommandProducerSuccess_default_instance_;
class CommandReachedEndOfTopic;
struct CommandReachedEndOfTopicDefaultTypeInternal;
extern CommandReachedEndOfTopicDefaultTypeInternal _CommandReachedEndOfTopic_default_instance_;
class CommandRedeliverUnacknowledgedMessages;
struct CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal;
extern CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal _CommandRedeliverUnacknowledgedMessages_default_instance_;
class CommandSeek;
struct CommandSeekDefaultTypeInternal;
extern CommandSeekDefaultTypeInternal _CommandSeek_default_instance_;
class CommandSend;
struct CommandSendDefaultTypeInternal;
extern CommandSendDefaultTypeInternal _CommandSend_default_instance_;
class CommandSendError;
struct CommandSendErrorDefaultTypeInternal;
extern CommandSendErrorDefaultTypeInternal _CommandSendError_default_instance_;
class CommandSendReceipt;
struct CommandSendReceiptDefaultTypeInternal;
extern CommandSendReceiptDefaultTypeInternal _CommandSendReceipt_default_instance_;
class CommandSubscribe;
struct CommandSubscribeDefaultTypeInternal;
extern CommandSubscribeDefaultTypeInternal _CommandSubscribe_default_instance_;
class CommandSuccess;
struct CommandSuccessDefaultTypeInternal;
extern CommandSuccessDefaultTypeInternal _CommandSuccess_default_instance_;
class CommandTcClientConnectRequest;
struct CommandTcClientConnectRequestDefaultTypeInternal;
extern CommandTcClientConnectRequestDefaultTypeInternal _CommandTcClientConnectRequest_default_instance_;
class CommandTcClientConnectResponse;
struct CommandTcClientConnectResponseDefaultTypeInternal;
extern CommandTcClientConnectResponseDefaultTypeInternal _CommandTcClientConnectResponse_default_instance_;
class CommandTopicMigrated;
struct CommandTopicMigratedDefaultTypeInternal;
extern CommandTopicMigratedDefaultTypeInternal _CommandTopicMigrated_default_instance_;
class CommandUnsubscribe;
struct CommandUnsubscribeDefaultTypeInternal;
extern CommandUnsubscribeDefaultTypeInternal _CommandUnsubscribe_default_instance_;
class CommandWatchTopicList;
struct CommandWatchTopicListDefaultTypeInternal;
extern CommandWatchTopicListDefaultTypeInternal _CommandWatchTopicList_default_instance_;
class CommandWatchTopicListClose;
struct CommandWatchTopicListCloseDefaultTypeInternal;
extern CommandWatchTopicListCloseDefaultTypeInternal _CommandWatchTopicListClose_default_instance_;
class CommandWatchTopicListSuccess;
struct CommandWatchTopicListSuccessDefaultTypeInternal;
extern CommandWatchTopicListSuccessDefaultTypeInternal _CommandWatchTopicListSuccess_default_instance_;
class CommandWatchTopicUpdate;
struct CommandWatchTopicUpdateDefaultTypeInternal;
extern CommandWatchTopicUpdateDefaultTypeInternal _CommandWatchTopicUpdate_default_instance_;
class EncryptionKeys;
struct EncryptionKeysDefaultTypeInternal;
extern EncryptionKeysDefaultTypeInternal _EncryptionKeys_default_instance_;
class FeatureFlags;
struct FeatureFlagsDefaultTypeInternal;
extern FeatureFlagsDefaultTypeInternal _FeatureFlags_default_instance_;
class IntRange;
struct IntRangeDefaultTypeInternal;
extern IntRangeDefaultTypeInternal _IntRange_default_instance_;
class KeyLongValue;
struct KeyLongValueDefaultTypeInternal;
extern KeyLongValueDefaultTypeInternal _KeyLongValue_default_instance_;
class KeySharedMeta;
struct KeySharedMetaDefaultTypeInternal;
extern KeySharedMetaDefaultTypeInternal _KeySharedMeta_default_instance_;
class KeyValue;
struct KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class MessageIdData;
struct MessageIdDataDefaultTypeInternal;
extern MessageIdDataDefaultTypeInternal _MessageIdData_default_instance_;
class MessageMetadata;
struct MessageMetadataDefaultTypeInternal;
extern MessageMetadataDefaultTypeInternal _MessageMetadata_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SingleMessageMetadata;
struct SingleMessageMetadataDefaultTypeInternal;
extern SingleMessageMetadataDefaultTypeInternal _SingleMessageMetadata_default_instance_;
class Subscription;
struct SubscriptionDefaultTypeInternal;
extern SubscriptionDefaultTypeInternal _Subscription_default_instance_;
}  // namespace proto
}  // namespace pulsar
PROTOBUF_NAMESPACE_OPEN
template<> ::pulsar::proto::AuthData* Arena::CreateMaybeMessage<::pulsar::proto::AuthData>(Arena*);
template<> ::pulsar::proto::BaseCommand* Arena::CreateMaybeMessage<::pulsar::proto::BaseCommand>(Arena*);
template<> ::pulsar::proto::BrokerEntryMetadata* Arena::CreateMaybeMessage<::pulsar::proto::BrokerEntryMetadata>(Arena*);
template<> ::pulsar::proto::CommandAck* Arena::CreateMaybeMessage<::pulsar::proto::CommandAck>(Arena*);
template<> ::pulsar::proto::CommandAckResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandAckResponse>(Arena*);
template<> ::pulsar::proto::CommandActiveConsumerChange* Arena::CreateMaybeMessage<::pulsar::proto::CommandActiveConsumerChange>(Arena*);
template<> ::pulsar::proto::CommandAddPartitionToTxn* Arena::CreateMaybeMessage<::pulsar::proto::CommandAddPartitionToTxn>(Arena*);
template<> ::pulsar::proto::CommandAddPartitionToTxnResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandAddPartitionToTxnResponse>(Arena*);
template<> ::pulsar::proto::CommandAddSubscriptionToTxn* Arena::CreateMaybeMessage<::pulsar::proto::CommandAddSubscriptionToTxn>(Arena*);
template<> ::pulsar::proto::CommandAddSubscriptionToTxnResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandAddSubscriptionToTxnResponse>(Arena*);
template<> ::pulsar::proto::CommandAuthChallenge* Arena::CreateMaybeMessage<::pulsar::proto::CommandAuthChallenge>(Arena*);
template<> ::pulsar::proto::CommandAuthResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandAuthResponse>(Arena*);
template<> ::pulsar::proto::CommandCloseConsumer* Arena::CreateMaybeMessage<::pulsar::proto::CommandCloseConsumer>(Arena*);
template<> ::pulsar::proto::CommandCloseProducer* Arena::CreateMaybeMessage<::pulsar::proto::CommandCloseProducer>(Arena*);
template<> ::pulsar::proto::CommandConnect* Arena::CreateMaybeMessage<::pulsar::proto::CommandConnect>(Arena*);
template<> ::pulsar::proto::CommandConnected* Arena::CreateMaybeMessage<::pulsar::proto::CommandConnected>(Arena*);
template<> ::pulsar::proto::CommandConsumerStats* Arena::CreateMaybeMessage<::pulsar::proto::CommandConsumerStats>(Arena*);
template<> ::pulsar::proto::CommandConsumerStatsResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandConsumerStatsResponse>(Arena*);
template<> ::pulsar::proto::CommandEndTxn* Arena::CreateMaybeMessage<::pulsar::proto::CommandEndTxn>(Arena*);
template<> ::pulsar::proto::CommandEndTxnOnPartition* Arena::CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnPartition>(Arena*);
template<> ::pulsar::proto::CommandEndTxnOnPartitionResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnPartitionResponse>(Arena*);
template<> ::pulsar::proto::CommandEndTxnOnSubscription* Arena::CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnSubscription>(Arena*);
template<> ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnSubscriptionResponse>(Arena*);
template<> ::pulsar::proto::CommandEndTxnResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandEndTxnResponse>(Arena*);
template<> ::pulsar::proto::CommandError* Arena::CreateMaybeMessage<::pulsar::proto::CommandError>(Arena*);
template<> ::pulsar::proto::CommandFlow* Arena::CreateMaybeMessage<::pulsar::proto::CommandFlow>(Arena*);
template<> ::pulsar::proto::CommandGetLastMessageId* Arena::CreateMaybeMessage<::pulsar::proto::CommandGetLastMessageId>(Arena*);
template<> ::pulsar::proto::CommandGetLastMessageIdResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandGetLastMessageIdResponse>(Arena*);
template<> ::pulsar::proto::CommandGetOrCreateSchema* Arena::CreateMaybeMessage<::pulsar::proto::CommandGetOrCreateSchema>(Arena*);
template<> ::pulsar::proto::CommandGetOrCreateSchemaResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandGetOrCreateSchemaResponse>(Arena*);
template<> ::pulsar::proto::CommandGetSchema* Arena::CreateMaybeMessage<::pulsar::proto::CommandGetSchema>(Arena*);
template<> ::pulsar::proto::CommandGetSchemaResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandGetSchemaResponse>(Arena*);
template<> ::pulsar::proto::CommandGetTopicsOfNamespace* Arena::CreateMaybeMessage<::pulsar::proto::CommandGetTopicsOfNamespace>(Arena*);
template<> ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandGetTopicsOfNamespaceResponse>(Arena*);
template<> ::pulsar::proto::CommandLookupTopic* Arena::CreateMaybeMessage<::pulsar::proto::CommandLookupTopic>(Arena*);
template<> ::pulsar::proto::CommandLookupTopicResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandLookupTopicResponse>(Arena*);
template<> ::pulsar::proto::CommandMessage* Arena::CreateMaybeMessage<::pulsar::proto::CommandMessage>(Arena*);
template<> ::pulsar::proto::CommandNewTxn* Arena::CreateMaybeMessage<::pulsar::proto::CommandNewTxn>(Arena*);
template<> ::pulsar::proto::CommandNewTxnResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandNewTxnResponse>(Arena*);
template<> ::pulsar::proto::CommandPartitionedTopicMetadata* Arena::CreateMaybeMessage<::pulsar::proto::CommandPartitionedTopicMetadata>(Arena*);
template<> ::pulsar::proto::CommandPartitionedTopicMetadataResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandPartitionedTopicMetadataResponse>(Arena*);
template<> ::pulsar::proto::CommandPing* Arena::CreateMaybeMessage<::pulsar::proto::CommandPing>(Arena*);
template<> ::pulsar::proto::CommandPong* Arena::CreateMaybeMessage<::pulsar::proto::CommandPong>(Arena*);
template<> ::pulsar::proto::CommandProducer* Arena::CreateMaybeMessage<::pulsar::proto::CommandProducer>(Arena*);
template<> ::pulsar::proto::CommandProducerSuccess* Arena::CreateMaybeMessage<::pulsar::proto::CommandProducerSuccess>(Arena*);
template<> ::pulsar::proto::CommandReachedEndOfTopic* Arena::CreateMaybeMessage<::pulsar::proto::CommandReachedEndOfTopic>(Arena*);
template<> ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* Arena::CreateMaybeMessage<::pulsar::proto::CommandRedeliverUnacknowledgedMessages>(Arena*);
template<> ::pulsar::proto::CommandSeek* Arena::CreateMaybeMessage<::pulsar::proto::CommandSeek>(Arena*);
template<> ::pulsar::proto::CommandSend* Arena::CreateMaybeMessage<::pulsar::proto::CommandSend>(Arena*);
template<> ::pulsar::proto::CommandSendError* Arena::CreateMaybeMessage<::pulsar::proto::CommandSendError>(Arena*);
template<> ::pulsar::proto::CommandSendReceipt* Arena::CreateMaybeMessage<::pulsar::proto::CommandSendReceipt>(Arena*);
template<> ::pulsar::proto::CommandSubscribe* Arena::CreateMaybeMessage<::pulsar::proto::CommandSubscribe>(Arena*);
template<> ::pulsar::proto::CommandSuccess* Arena::CreateMaybeMessage<::pulsar::proto::CommandSuccess>(Arena*);
template<> ::pulsar::proto::CommandTcClientConnectRequest* Arena::CreateMaybeMessage<::pulsar::proto::CommandTcClientConnectRequest>(Arena*);
template<> ::pulsar::proto::CommandTcClientConnectResponse* Arena::CreateMaybeMessage<::pulsar::proto::CommandTcClientConnectResponse>(Arena*);
template<> ::pulsar::proto::CommandTopicMigrated* Arena::CreateMaybeMessage<::pulsar::proto::CommandTopicMigrated>(Arena*);
template<> ::pulsar::proto::CommandUnsubscribe* Arena::CreateMaybeMessage<::pulsar::proto::CommandUnsubscribe>(Arena*);
template<> ::pulsar::proto::CommandWatchTopicList* Arena::CreateMaybeMessage<::pulsar::proto::CommandWatchTopicList>(Arena*);
template<> ::pulsar::proto::CommandWatchTopicListClose* Arena::CreateMaybeMessage<::pulsar::proto::CommandWatchTopicListClose>(Arena*);
template<> ::pulsar::proto::CommandWatchTopicListSuccess* Arena::CreateMaybeMessage<::pulsar::proto::CommandWatchTopicListSuccess>(Arena*);
template<> ::pulsar::proto::CommandWatchTopicUpdate* Arena::CreateMaybeMessage<::pulsar::proto::CommandWatchTopicUpdate>(Arena*);
template<> ::pulsar::proto::EncryptionKeys* Arena::CreateMaybeMessage<::pulsar::proto::EncryptionKeys>(Arena*);
template<> ::pulsar::proto::FeatureFlags* Arena::CreateMaybeMessage<::pulsar::proto::FeatureFlags>(Arena*);
template<> ::pulsar::proto::IntRange* Arena::CreateMaybeMessage<::pulsar::proto::IntRange>(Arena*);
template<> ::pulsar::proto::KeyLongValue* Arena::CreateMaybeMessage<::pulsar::proto::KeyLongValue>(Arena*);
template<> ::pulsar::proto::KeySharedMeta* Arena::CreateMaybeMessage<::pulsar::proto::KeySharedMeta>(Arena*);
template<> ::pulsar::proto::KeyValue* Arena::CreateMaybeMessage<::pulsar::proto::KeyValue>(Arena*);
template<> ::pulsar::proto::MessageIdData* Arena::CreateMaybeMessage<::pulsar::proto::MessageIdData>(Arena*);
template<> ::pulsar::proto::MessageMetadata* Arena::CreateMaybeMessage<::pulsar::proto::MessageMetadata>(Arena*);
template<> ::pulsar::proto::Schema* Arena::CreateMaybeMessage<::pulsar::proto::Schema>(Arena*);
template<> ::pulsar::proto::SingleMessageMetadata* Arena::CreateMaybeMessage<::pulsar::proto::SingleMessageMetadata>(Arena*);
template<> ::pulsar::proto::Subscription* Arena::CreateMaybeMessage<::pulsar::proto::Subscription>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pulsar {
namespace proto {

enum Schema_Type : int {
  Schema_Type_None = 0,
  Schema_Type_String = 1,
  Schema_Type_Json = 2,
  Schema_Type_Protobuf = 3,
  Schema_Type_Avro = 4,
  Schema_Type_Bool = 5,
  Schema_Type_Int8 = 6,
  Schema_Type_Int16 = 7,
  Schema_Type_Int32 = 8,
  Schema_Type_Int64 = 9,
  Schema_Type_Float = 10,
  Schema_Type_Double = 11,
  Schema_Type_Date = 12,
  Schema_Type_Time = 13,
  Schema_Type_Timestamp = 14,
  Schema_Type_KeyValue = 15,
  Schema_Type_Instant = 16,
  Schema_Type_LocalDate = 17,
  Schema_Type_LocalTime = 18,
  Schema_Type_LocalDateTime = 19,
  Schema_Type_ProtobufNative = 20
};
bool Schema_Type_IsValid(int value);
constexpr Schema_Type Schema_Type_Type_MIN = Schema_Type_None;
constexpr Schema_Type Schema_Type_Type_MAX = Schema_Type_ProtobufNative;
constexpr int Schema_Type_Type_ARRAYSIZE = Schema_Type_Type_MAX + 1;

const std::string& Schema_Type_Name(Schema_Type value);
template<typename T>
inline const std::string& Schema_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Schema_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Schema_Type_Name.");
  return Schema_Type_Name(static_cast<Schema_Type>(enum_t_value));
}
bool Schema_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Schema_Type* value);
enum CommandSubscribe_SubType : int {
  CommandSubscribe_SubType_Exclusive = 0,
  CommandSubscribe_SubType_Shared = 1,
  CommandSubscribe_SubType_Failover = 2,
  CommandSubscribe_SubType_Key_Shared = 3
};
bool CommandSubscribe_SubType_IsValid(int value);
constexpr CommandSubscribe_SubType CommandSubscribe_SubType_SubType_MIN = CommandSubscribe_SubType_Exclusive;
constexpr CommandSubscribe_SubType CommandSubscribe_SubType_SubType_MAX = CommandSubscribe_SubType_Key_Shared;
constexpr int CommandSubscribe_SubType_SubType_ARRAYSIZE = CommandSubscribe_SubType_SubType_MAX + 1;

const std::string& CommandSubscribe_SubType_Name(CommandSubscribe_SubType value);
template<typename T>
inline const std::string& CommandSubscribe_SubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandSubscribe_SubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandSubscribe_SubType_Name.");
  return CommandSubscribe_SubType_Name(static_cast<CommandSubscribe_SubType>(enum_t_value));
}
bool CommandSubscribe_SubType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandSubscribe_SubType* value);
enum CommandSubscribe_InitialPosition : int {
  CommandSubscribe_InitialPosition_Latest = 0,
  CommandSubscribe_InitialPosition_Earliest = 1
};
bool CommandSubscribe_InitialPosition_IsValid(int value);
constexpr CommandSubscribe_InitialPosition CommandSubscribe_InitialPosition_InitialPosition_MIN = CommandSubscribe_InitialPosition_Latest;
constexpr CommandSubscribe_InitialPosition CommandSubscribe_InitialPosition_InitialPosition_MAX = CommandSubscribe_InitialPosition_Earliest;
constexpr int CommandSubscribe_InitialPosition_InitialPosition_ARRAYSIZE = CommandSubscribe_InitialPosition_InitialPosition_MAX + 1;

const std::string& CommandSubscribe_InitialPosition_Name(CommandSubscribe_InitialPosition value);
template<typename T>
inline const std::string& CommandSubscribe_InitialPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandSubscribe_InitialPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandSubscribe_InitialPosition_Name.");
  return CommandSubscribe_InitialPosition_Name(static_cast<CommandSubscribe_InitialPosition>(enum_t_value));
}
bool CommandSubscribe_InitialPosition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandSubscribe_InitialPosition* value);
enum CommandPartitionedTopicMetadataResponse_LookupType : int {
  CommandPartitionedTopicMetadataResponse_LookupType_Success = 0,
  CommandPartitionedTopicMetadataResponse_LookupType_Failed = 1
};
bool CommandPartitionedTopicMetadataResponse_LookupType_IsValid(int value);
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MIN = CommandPartitionedTopicMetadataResponse_LookupType_Success;
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MAX = CommandPartitionedTopicMetadataResponse_LookupType_Failed;
constexpr int CommandPartitionedTopicMetadataResponse_LookupType_LookupType_ARRAYSIZE = CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MAX + 1;

const std::string& CommandPartitionedTopicMetadataResponse_LookupType_Name(CommandPartitionedTopicMetadataResponse_LookupType value);
template<typename T>
inline const std::string& CommandPartitionedTopicMetadataResponse_LookupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandPartitionedTopicMetadataResponse_LookupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandPartitionedTopicMetadataResponse_LookupType_Name.");
  return CommandPartitionedTopicMetadataResponse_LookupType_Name(static_cast<CommandPartitionedTopicMetadataResponse_LookupType>(enum_t_value));
}
bool CommandPartitionedTopicMetadataResponse_LookupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandPartitionedTopicMetadataResponse_LookupType* value);
enum CommandLookupTopicResponse_LookupType : int {
  CommandLookupTopicResponse_LookupType_Redirect = 0,
  CommandLookupTopicResponse_LookupType_Connect = 1,
  CommandLookupTopicResponse_LookupType_Failed = 2
};
bool CommandLookupTopicResponse_LookupType_IsValid(int value);
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse_LookupType_LookupType_MIN = CommandLookupTopicResponse_LookupType_Redirect;
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse_LookupType_LookupType_MAX = CommandLookupTopicResponse_LookupType_Failed;
constexpr int CommandLookupTopicResponse_LookupType_LookupType_ARRAYSIZE = CommandLookupTopicResponse_LookupType_LookupType_MAX + 1;

const std::string& CommandLookupTopicResponse_LookupType_Name(CommandLookupTopicResponse_LookupType value);
template<typename T>
inline const std::string& CommandLookupTopicResponse_LookupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandLookupTopicResponse_LookupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandLookupTopicResponse_LookupType_Name.");
  return CommandLookupTopicResponse_LookupType_Name(static_cast<CommandLookupTopicResponse_LookupType>(enum_t_value));
}
bool CommandLookupTopicResponse_LookupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandLookupTopicResponse_LookupType* value);
enum CommandAck_AckType : int {
  CommandAck_AckType_Individual = 0,
  CommandAck_AckType_Cumulative = 1
};
bool CommandAck_AckType_IsValid(int value);
constexpr CommandAck_AckType CommandAck_AckType_AckType_MIN = CommandAck_AckType_Individual;
constexpr CommandAck_AckType CommandAck_AckType_AckType_MAX = CommandAck_AckType_Cumulative;
constexpr int CommandAck_AckType_AckType_ARRAYSIZE = CommandAck_AckType_AckType_MAX + 1;

const std::string& CommandAck_AckType_Name(CommandAck_AckType value);
template<typename T>
inline const std::string& CommandAck_AckType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandAck_AckType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandAck_AckType_Name.");
  return CommandAck_AckType_Name(static_cast<CommandAck_AckType>(enum_t_value));
}
bool CommandAck_AckType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandAck_AckType* value);
enum CommandAck_ValidationError : int {
  CommandAck_ValidationError_UncompressedSizeCorruption = 0,
  CommandAck_ValidationError_DecompressionError = 1,
  CommandAck_ValidationError_ChecksumMismatch = 2,
  CommandAck_ValidationError_BatchDeSerializeError = 3,
  CommandAck_ValidationError_DecryptionError = 4
};
bool CommandAck_ValidationError_IsValid(int value);
constexpr CommandAck_ValidationError CommandAck_ValidationError_ValidationError_MIN = CommandAck_ValidationError_UncompressedSizeCorruption;
constexpr CommandAck_ValidationError CommandAck_ValidationError_ValidationError_MAX = CommandAck_ValidationError_DecryptionError;
constexpr int CommandAck_ValidationError_ValidationError_ARRAYSIZE = CommandAck_ValidationError_ValidationError_MAX + 1;

const std::string& CommandAck_ValidationError_Name(CommandAck_ValidationError value);
template<typename T>
inline const std::string& CommandAck_ValidationError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandAck_ValidationError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandAck_ValidationError_Name.");
  return CommandAck_ValidationError_Name(static_cast<CommandAck_ValidationError>(enum_t_value));
}
bool CommandAck_ValidationError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandAck_ValidationError* value);
enum CommandTopicMigrated_ResourceType : int {
  CommandTopicMigrated_ResourceType_Producer = 0,
  CommandTopicMigrated_ResourceType_Consumer = 1
};
bool CommandTopicMigrated_ResourceType_IsValid(int value);
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated_ResourceType_ResourceType_MIN = CommandTopicMigrated_ResourceType_Producer;
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated_ResourceType_ResourceType_MAX = CommandTopicMigrated_ResourceType_Consumer;
constexpr int CommandTopicMigrated_ResourceType_ResourceType_ARRAYSIZE = CommandTopicMigrated_ResourceType_ResourceType_MAX + 1;

const std::string& CommandTopicMigrated_ResourceType_Name(CommandTopicMigrated_ResourceType value);
template<typename T>
inline const std::string& CommandTopicMigrated_ResourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandTopicMigrated_ResourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandTopicMigrated_ResourceType_Name.");
  return CommandTopicMigrated_ResourceType_Name(static_cast<CommandTopicMigrated_ResourceType>(enum_t_value));
}
bool CommandTopicMigrated_ResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandTopicMigrated_ResourceType* value);
enum CommandGetTopicsOfNamespace_Mode : int {
  CommandGetTopicsOfNamespace_Mode_PERSISTENT = 0,
  CommandGetTopicsOfNamespace_Mode_NON_PERSISTENT = 1,
  CommandGetTopicsOfNamespace_Mode_ALL = 2
};
bool CommandGetTopicsOfNamespace_Mode_IsValid(int value);
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace_Mode_Mode_MIN = CommandGetTopicsOfNamespace_Mode_PERSISTENT;
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace_Mode_Mode_MAX = CommandGetTopicsOfNamespace_Mode_ALL;
constexpr int CommandGetTopicsOfNamespace_Mode_Mode_ARRAYSIZE = CommandGetTopicsOfNamespace_Mode_Mode_MAX + 1;

const std::string& CommandGetTopicsOfNamespace_Mode_Name(CommandGetTopicsOfNamespace_Mode value);
template<typename T>
inline const std::string& CommandGetTopicsOfNamespace_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandGetTopicsOfNamespace_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandGetTopicsOfNamespace_Mode_Name.");
  return CommandGetTopicsOfNamespace_Mode_Name(static_cast<CommandGetTopicsOfNamespace_Mode>(enum_t_value));
}
bool CommandGetTopicsOfNamespace_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandGetTopicsOfNamespace_Mode* value);
enum BaseCommand_Type : int {
  BaseCommand_Type_CONNECT = 2,
  BaseCommand_Type_CONNECTED = 3,
  BaseCommand_Type_SUBSCRIBE = 4,
  BaseCommand_Type_PRODUCER = 5,
  BaseCommand_Type_SEND = 6,
  BaseCommand_Type_SEND_RECEIPT = 7,
  BaseCommand_Type_SEND_ERROR = 8,
  BaseCommand_Type_MESSAGE = 9,
  BaseCommand_Type_ACK = 10,
  BaseCommand_Type_FLOW = 11,
  BaseCommand_Type_UNSUBSCRIBE = 12,
  BaseCommand_Type_SUCCESS = 13,
  BaseCommand_Type_ERROR = 14,
  BaseCommand_Type_CLOSE_PRODUCER = 15,
  BaseCommand_Type_CLOSE_CONSUMER = 16,
  BaseCommand_Type_PRODUCER_SUCCESS = 17,
  BaseCommand_Type_PING = 18,
  BaseCommand_Type_PONG = 19,
  BaseCommand_Type_REDELIVER_UNACKNOWLEDGED_MESSAGES = 20,
  BaseCommand_Type_PARTITIONED_METADATA = 21,
  BaseCommand_Type_PARTITIONED_METADATA_RESPONSE = 22,
  BaseCommand_Type_LOOKUP = 23,
  BaseCommand_Type_LOOKUP_RESPONSE = 24,
  BaseCommand_Type_CONSUMER_STATS = 25,
  BaseCommand_Type_CONSUMER_STATS_RESPONSE = 26,
  BaseCommand_Type_REACHED_END_OF_TOPIC = 27,
  BaseCommand_Type_SEEK = 28,
  BaseCommand_Type_GET_LAST_MESSAGE_ID = 29,
  BaseCommand_Type_GET_LAST_MESSAGE_ID_RESPONSE = 30,
  BaseCommand_Type_ACTIVE_CONSUMER_CHANGE = 31,
  BaseCommand_Type_GET_TOPICS_OF_NAMESPACE = 32,
  BaseCommand_Type_GET_TOPICS_OF_NAMESPACE_RESPONSE = 33,
  BaseCommand_Type_GET_SCHEMA = 34,
  BaseCommand_Type_GET_SCHEMA_RESPONSE = 35,
  BaseCommand_Type_AUTH_CHALLENGE = 36,
  BaseCommand_Type_AUTH_RESPONSE = 37,
  BaseCommand_Type_ACK_RESPONSE = 38,
  BaseCommand_Type_GET_OR_CREATE_SCHEMA = 39,
  BaseCommand_Type_GET_OR_CREATE_SCHEMA_RESPONSE = 40,
  BaseCommand_Type_NEW_TXN = 50,
  BaseCommand_Type_NEW_TXN_RESPONSE = 51,
  BaseCommand_Type_ADD_PARTITION_TO_TXN = 52,
  BaseCommand_Type_ADD_PARTITION_TO_TXN_RESPONSE = 53,
  BaseCommand_Type_ADD_SUBSCRIPTION_TO_TXN = 54,
  BaseCommand_Type_ADD_SUBSCRIPTION_TO_TXN_RESPONSE = 55,
  BaseCommand_Type_END_TXN = 56,
  BaseCommand_Type_END_TXN_RESPONSE = 57,
  BaseCommand_Type_END_TXN_ON_PARTITION = 58,
  BaseCommand_Type_END_TXN_ON_PARTITION_RESPONSE = 59,
  BaseCommand_Type_END_TXN_ON_SUBSCRIPTION = 60,
  BaseCommand_Type_END_TXN_ON_SUBSCRIPTION_RESPONSE = 61,
  BaseCommand_Type_TC_CLIENT_CONNECT_REQUEST = 62,
  BaseCommand_Type_TC_CLIENT_CONNECT_RESPONSE = 63,
  BaseCommand_Type_WATCH_TOPIC_LIST = 64,
  BaseCommand_Type_WATCH_TOPIC_LIST_SUCCESS = 65,
  BaseCommand_Type_WATCH_TOPIC_UPDATE = 66,
  BaseCommand_Type_WATCH_TOPIC_LIST_CLOSE = 67,
  BaseCommand_Type_TOPIC_MIGRATED = 68
};
bool BaseCommand_Type_IsValid(int value);
constexpr BaseCommand_Type BaseCommand_Type_Type_MIN = BaseCommand_Type_CONNECT;
constexpr BaseCommand_Type BaseCommand_Type_Type_MAX = BaseCommand_Type_TOPIC_MIGRATED;
constexpr int BaseCommand_Type_Type_ARRAYSIZE = BaseCommand_Type_Type_MAX + 1;

const std::string& BaseCommand_Type_Name(BaseCommand_Type value);
template<typename T>
inline const std::string& BaseCommand_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BaseCommand_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BaseCommand_Type_Name.");
  return BaseCommand_Type_Name(static_cast<BaseCommand_Type>(enum_t_value));
}
bool BaseCommand_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BaseCommand_Type* value);
enum CompressionType : int {
  NONE = 0,
  LZ4 = 1,
  ZLIB = 2,
  ZSTD = 3,
  SNAPPY = 4
};
bool CompressionType_IsValid(int value);
constexpr CompressionType CompressionType_MIN = NONE;
constexpr CompressionType CompressionType_MAX = SNAPPY;
constexpr int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

const std::string& CompressionType_Name(CompressionType value);
template<typename T>
inline const std::string& CompressionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionType_Name.");
  return CompressionType_Name(static_cast<CompressionType>(enum_t_value));
}
bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value);
enum ProducerAccessMode : int {
  Shared = 0,
  Exclusive = 1,
  WaitForExclusive = 2,
  ExclusiveWithFencing = 3
};
bool ProducerAccessMode_IsValid(int value);
constexpr ProducerAccessMode ProducerAccessMode_MIN = Shared;
constexpr ProducerAccessMode ProducerAccessMode_MAX = ExclusiveWithFencing;
constexpr int ProducerAccessMode_ARRAYSIZE = ProducerAccessMode_MAX + 1;

const std::string& ProducerAccessMode_Name(ProducerAccessMode value);
template<typename T>
inline const std::string& ProducerAccessMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProducerAccessMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProducerAccessMode_Name.");
  return ProducerAccessMode_Name(static_cast<ProducerAccessMode>(enum_t_value));
}
bool ProducerAccessMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProducerAccessMode* value);
enum ServerError : int {
  UnknownError = 0,
  MetadataError = 1,
  PersistenceError = 2,
  AuthenticationError = 3,
  AuthorizationError = 4,
  ConsumerBusy = 5,
  ServiceNotReady = 6,
  ProducerBlockedQuotaExceededError = 7,
  ProducerBlockedQuotaExceededException = 8,
  ChecksumError = 9,
  UnsupportedVersionError = 10,
  TopicNotFound = 11,
  SubscriptionNotFound = 12,
  ConsumerNotFound = 13,
  TooManyRequests = 14,
  TopicTerminatedError = 15,
  ProducerBusy = 16,
  InvalidTopicName = 17,
  IncompatibleSchema = 18,
  ConsumerAssignError = 19,
  TransactionCoordinatorNotFound = 20,
  InvalidTxnStatus = 21,
  NotAllowedError = 22,
  TransactionConflict = 23,
  TransactionNotFound = 24,
  ProducerFenced = 25
};
bool ServerError_IsValid(int value);
constexpr ServerError ServerError_MIN = UnknownError;
constexpr ServerError ServerError_MAX = ProducerFenced;
constexpr int ServerError_ARRAYSIZE = ServerError_MAX + 1;

const std::string& ServerError_Name(ServerError value);
template<typename T>
inline const std::string& ServerError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerError_Name.");
  return ServerError_Name(static_cast<ServerError>(enum_t_value));
}
bool ServerError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerError* value);
enum AuthMethod : int {
  AuthMethodNone = 0,
  AuthMethodYcaV1 = 1,
  AuthMethodAthens = 2
};
bool AuthMethod_IsValid(int value);
constexpr AuthMethod AuthMethod_MIN = AuthMethodNone;
constexpr AuthMethod AuthMethod_MAX = AuthMethodAthens;
constexpr int AuthMethod_ARRAYSIZE = AuthMethod_MAX + 1;

const std::string& AuthMethod_Name(AuthMethod value);
template<typename T>
inline const std::string& AuthMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AuthMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AuthMethod_Name.");
  return AuthMethod_Name(static_cast<AuthMethod>(enum_t_value));
}
bool AuthMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AuthMethod* value);
enum ProtocolVersion : int {
  v0 = 0,
  v1 = 1,
  v2 = 2,
  v3 = 3,
  v4 = 4,
  v5 = 5,
  v6 = 6,
  v7 = 7,
  v8 = 8,
  v9 = 9,
  v10 = 10,
  v11 = 11,
  v12 = 12,
  v13 = 13,
  v14 = 14,
  v15 = 15,
  v16 = 16,
  v17 = 17,
  v18 = 18,
  v19 = 19,
  v20 = 20
};
bool ProtocolVersion_IsValid(int value);
constexpr ProtocolVersion ProtocolVersion_MIN = v0;
constexpr ProtocolVersion ProtocolVersion_MAX = v20;
constexpr int ProtocolVersion_ARRAYSIZE = ProtocolVersion_MAX + 1;

const std::string& ProtocolVersion_Name(ProtocolVersion value);
template<typename T>
inline const std::string& ProtocolVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProtocolVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProtocolVersion_Name.");
  return ProtocolVersion_Name(static_cast<ProtocolVersion>(enum_t_value));
}
bool ProtocolVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProtocolVersion* value);
enum KeySharedMode : int {
  AUTO_SPLIT = 0,
  STICKY = 1
};
bool KeySharedMode_IsValid(int value);
constexpr KeySharedMode KeySharedMode_MIN = AUTO_SPLIT;
constexpr KeySharedMode KeySharedMode_MAX = STICKY;
constexpr int KeySharedMode_ARRAYSIZE = KeySharedMode_MAX + 1;

const std::string& KeySharedMode_Name(KeySharedMode value);
template<typename T>
inline const std::string& KeySharedMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeySharedMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeySharedMode_Name.");
  return KeySharedMode_Name(static_cast<KeySharedMode>(enum_t_value));
}
bool KeySharedMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeySharedMode* value);
enum TxnAction : int {
  COMMIT = 0,
  ABORT = 1
};
bool TxnAction_IsValid(int value);
constexpr TxnAction TxnAction_MIN = COMMIT;
constexpr TxnAction TxnAction_MAX = ABORT;
constexpr int TxnAction_ARRAYSIZE = TxnAction_MAX + 1;

const std::string& TxnAction_Name(TxnAction value);
template<typename T>
inline const std::string& TxnAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TxnAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TxnAction_Name.");
  return TxnAction_Name(static_cast<TxnAction>(enum_t_value));
}
bool TxnAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TxnAction* value);
// ===================================================================

class Schema final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  explicit constexpr Schema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Schema* New() const final {
    return new Schema();
  }

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Schema* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Schema_Type Type;
  static constexpr Type None =
    Schema_Type_None;
  static constexpr Type String =
    Schema_Type_String;
  static constexpr Type Json =
    Schema_Type_Json;
  static constexpr Type Protobuf =
    Schema_Type_Protobuf;
  static constexpr Type Avro =
    Schema_Type_Avro;
  static constexpr Type Bool =
    Schema_Type_Bool;
  static constexpr Type Int8 =
    Schema_Type_Int8;
  static constexpr Type Int16 =
    Schema_Type_Int16;
  static constexpr Type Int32 =
    Schema_Type_Int32;
  static constexpr Type Int64 =
    Schema_Type_Int64;
  static constexpr Type Float =
    Schema_Type_Float;
  static constexpr Type Double =
    Schema_Type_Double;
  static constexpr Type Date =
    Schema_Type_Date;
  static constexpr Type Time =
    Schema_Type_Time;
  static constexpr Type Timestamp =
    Schema_Type_Timestamp;
  static constexpr Type KeyValue =
    Schema_Type_KeyValue;
  static constexpr Type Instant =
    Schema_Type_Instant;
  static constexpr Type LocalDate =
    Schema_Type_LocalDate;
  static constexpr Type LocalTime =
    Schema_Type_LocalTime;
  static constexpr Type LocalDateTime =
    Schema_Type_LocalDateTime;
  static constexpr Type ProtobufNative =
    Schema_Type_ProtobufNative;
  static inline bool Type_IsValid(int value) {
    return Schema_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Schema_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Schema_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Schema_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Schema_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Schema_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 5,
    kNameFieldNumber = 1,
    kSchemaDataFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // repeated .pulsar.proto.KeyValue properties = 5;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::pulsar::proto::KeyValue* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_properties();
  private:
  const ::pulsar::proto::KeyValue& _internal_properties(int index) const;
  ::pulsar::proto::KeyValue* _internal_add_properties();
  public:
  const ::pulsar::proto::KeyValue& properties(int index) const;
  ::pulsar::proto::KeyValue* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      properties() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required bytes schema_data = 3;
  bool has_schema_data() const;
  private:
  bool _internal_has_schema_data() const;
  public:
  void clear_schema_data();
  const std::string& schema_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema_data();
  void set_allocated_schema_data(std::string* schema_data);
  private:
  const std::string& _internal_schema_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_data(const std::string& value);
  std::string* _internal_mutable_schema_data();
  public:

  // required .pulsar.proto.Schema.Type type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pulsar::proto::Schema_Type type() const;
  void set_type(::pulsar::proto::Schema_Type value);
  private:
  ::pulsar::proto::Schema_Type _internal_type() const;
  void _internal_set_type(::pulsar::proto::Schema_Type value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.Schema)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue > properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_data_;
  int type_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class MessageIdData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.MessageIdData) */ {
 public:
  inline MessageIdData() : MessageIdData(nullptr) {}
  ~MessageIdData() override;
  explicit constexpr MessageIdData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageIdData(const MessageIdData& from);
  MessageIdData(MessageIdData&& from) noexcept
    : MessageIdData() {
    *this = ::std::move(from);
  }

  inline MessageIdData& operator=(const MessageIdData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageIdData& operator=(MessageIdData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MessageIdData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageIdData* internal_default_instance() {
    return reinterpret_cast<const MessageIdData*>(
               &_MessageIdData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MessageIdData& a, MessageIdData& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageIdData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageIdData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageIdData* New() const final {
    return new MessageIdData();
  }

  MessageIdData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageIdData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MessageIdData& from);
  void MergeFrom(const MessageIdData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageIdData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.MessageIdData";
  }
  protected:
  explicit MessageIdData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckSetFieldNumber = 5,
    kFirstChunkMessageIdFieldNumber = 7,
    kLedgerIdFieldNumber = 1,
    kEntryIdFieldNumber = 2,
    kBatchSizeFieldNumber = 6,
    kPartitionFieldNumber = 3,
    kBatchIndexFieldNumber = 4,
  };
  // repeated int64 ack_set = 5;
  int ack_set_size() const;
  private:
  int _internal_ack_set_size() const;
  public:
  void clear_ack_set();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ack_set(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_ack_set() const;
  void _internal_add_ack_set(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_ack_set();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 ack_set(int index) const;
  void set_ack_set(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_ack_set(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      ack_set() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_ack_set();

  // optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
  bool has_first_chunk_message_id() const;
  private:
  bool _internal_has_first_chunk_message_id() const;
  public:
  void clear_first_chunk_message_id();
  const ::pulsar::proto::MessageIdData& first_chunk_message_id() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::MessageIdData* release_first_chunk_message_id();
  ::pulsar::proto::MessageIdData* mutable_first_chunk_message_id();
  void set_allocated_first_chunk_message_id(::pulsar::proto::MessageIdData* first_chunk_message_id);
  private:
  const ::pulsar::proto::MessageIdData& _internal_first_chunk_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_first_chunk_message_id();
  public:
  void unsafe_arena_set_allocated_first_chunk_message_id(
      ::pulsar::proto::MessageIdData* first_chunk_message_id);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_first_chunk_message_id();

  // required uint64 ledgerId = 1;
  bool has_ledgerid() const;
  private:
  bool _internal_has_ledgerid() const;
  public:
  void clear_ledgerid();
  ::PROTOBUF_NAMESPACE_ID::uint64 ledgerid() const;
  void set_ledgerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ledgerid() const;
  void _internal_set_ledgerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 entryId = 2;
  bool has_entryid() const;
  private:
  bool _internal_has_entryid() const;
  public:
  void clear_entryid();
  ::PROTOBUF_NAMESPACE_ID::uint64 entryid() const;
  void set_entryid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_entryid() const;
  void _internal_set_entryid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 batch_size = 6;
  bool has_batch_size() const;
  private:
  bool _internal_has_batch_size() const;
  public:
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_size() const;
  void _internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 partition = 3 [default = -1];
  bool has_partition() const;
  private:
  bool _internal_has_partition() const;
  public:
  void clear_partition();
  ::PROTOBUF_NAMESPACE_ID::int32 partition() const;
  void set_partition(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_partition() const;
  void _internal_set_partition(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 batch_index = 4 [default = -1];
  bool has_batch_index() const;
  private:
  bool _internal_has_batch_index() const;
  public:
  void clear_batch_index();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_index() const;
  void set_batch_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_index() const;
  void _internal_set_batch_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.MessageIdData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > ack_set_;
  ::pulsar::proto::MessageIdData* first_chunk_message_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ledgerid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 entryid_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 partition_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_index_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class KeyValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.KeyValue) */ {
 public:
  inline KeyValue() : KeyValue(nullptr) {}
  ~KeyValue() override;
  explicit constexpr KeyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValue(const KeyValue& from);
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeyValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyValue* New() const final {
    return new KeyValue();
  }

  KeyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.KeyValue";
  }
  protected:
  explicit KeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.KeyValue)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class KeyLongValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.KeyLongValue) */ {
 public:
  inline KeyLongValue() : KeyLongValue(nullptr) {}
  ~KeyLongValue() override;
  explicit constexpr KeyLongValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyLongValue(const KeyLongValue& from);
  KeyLongValue(KeyLongValue&& from) noexcept
    : KeyLongValue() {
    *this = ::std::move(from);
  }

  inline KeyLongValue& operator=(const KeyLongValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyLongValue& operator=(KeyLongValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeyLongValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyLongValue* internal_default_instance() {
    return reinterpret_cast<const KeyLongValue*>(
               &_KeyLongValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(KeyLongValue& a, KeyLongValue& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyLongValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyLongValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyLongValue* New() const final {
    return new KeyLongValue();
  }

  KeyLongValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyLongValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KeyLongValue& from);
  void MergeFrom(const KeyLongValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyLongValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.KeyLongValue";
  }
  protected:
  explicit KeyLongValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required uint64 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.KeyLongValue)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class IntRange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.IntRange) */ {
 public:
  inline IntRange() : IntRange(nullptr) {}
  ~IntRange() override;
  explicit constexpr IntRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntRange(const IntRange& from);
  IntRange(IntRange&& from) noexcept
    : IntRange() {
    *this = ::std::move(from);
  }

  inline IntRange& operator=(const IntRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntRange& operator=(IntRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IntRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntRange* internal_default_instance() {
    return reinterpret_cast<const IntRange*>(
               &_IntRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IntRange& a, IntRange& b) {
    a.Swap(&b);
  }
  inline void Swap(IntRange* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IntRange* New() const final {
    return new IntRange();
  }

  IntRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IntRange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const IntRange& from);
  void MergeFrom(const IntRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IntRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.IntRange";
  }
  protected:
  explicit IntRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // required int32 start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.IntRange)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class EncryptionKeys final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.EncryptionKeys) */ {
 public:
  inline EncryptionKeys() : EncryptionKeys(nullptr) {}
  ~EncryptionKeys() override;
  explicit constexpr EncryptionKeys(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncryptionKeys(const EncryptionKeys& from);
  EncryptionKeys(EncryptionKeys&& from) noexcept
    : EncryptionKeys() {
    *this = ::std::move(from);
  }

  inline EncryptionKeys& operator=(const EncryptionKeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptionKeys& operator=(EncryptionKeys&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EncryptionKeys& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncryptionKeys* internal_default_instance() {
    return reinterpret_cast<const EncryptionKeys*>(
               &_EncryptionKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EncryptionKeys& a, EncryptionKeys& b) {
    a.Swap(&b);
  }
  inline void Swap(EncryptionKeys* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncryptionKeys* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EncryptionKeys* New() const final {
    return new EncryptionKeys();
  }

  EncryptionKeys* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EncryptionKeys>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EncryptionKeys& from);
  void MergeFrom(const EncryptionKeys& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EncryptionKeys* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.EncryptionKeys";
  }
  protected:
  explicit EncryptionKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // repeated .pulsar.proto.KeyValue metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::pulsar::proto::KeyValue* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_metadata();
  private:
  const ::pulsar::proto::KeyValue& _internal_metadata(int index) const;
  ::pulsar::proto::KeyValue* _internal_add_metadata();
  public:
  const ::pulsar::proto::KeyValue& metadata(int index) const;
  ::pulsar::proto::KeyValue* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      metadata() const;

  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required bytes value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.EncryptionKeys)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue > metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class MessageMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.MessageMetadata) */ {
 public:
  inline MessageMetadata() : MessageMetadata(nullptr) {}
  ~MessageMetadata() override;
  explicit constexpr MessageMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageMetadata(const MessageMetadata& from);
  MessageMetadata(MessageMetadata&& from) noexcept
    : MessageMetadata() {
    *this = ::std::move(from);
  }

  inline MessageMetadata& operator=(const MessageMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageMetadata& operator=(MessageMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MessageMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageMetadata* internal_default_instance() {
    return reinterpret_cast<const MessageMetadata*>(
               &_MessageMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MessageMetadata& a, MessageMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageMetadata* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageMetadata* New() const final {
    return new MessageMetadata();
  }

  MessageMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MessageMetadata& from);
  void MergeFrom(const MessageMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.MessageMetadata";
  }
  protected:
  explicit MessageMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 4,
    kReplicateToFieldNumber = 7,
    kEncryptionKeysFieldNumber = 13,
    kProducerNameFieldNumber = 1,
    kReplicatedFromFieldNumber = 5,
    kPartitionKeyFieldNumber = 6,
    kEncryptionAlgoFieldNumber = 14,
    kEncryptionParamFieldNumber = 15,
    kSchemaVersionFieldNumber = 16,
    kOrderingKeyFieldNumber = 18,
    kUuidFieldNumber = 26,
    kSequenceIdFieldNumber = 2,
    kPublishTimeFieldNumber = 3,
    kCompressionFieldNumber = 8,
    kUncompressedSizeFieldNumber = 9,
    kEventTimeFieldNumber = 12,
    kDeliverAtTimeFieldNumber = 19,
    kTxnidLeastBitsFieldNumber = 22,
    kTxnidMostBitsFieldNumber = 23,
    kMarkerTypeFieldNumber = 20,
    kPartitionKeyB64EncodedFieldNumber = 17,
    kNullValueFieldNumber = 25,
    kNullPartitionKeyFieldNumber = 30,
    kHighestSequenceIdFieldNumber = 24,
    kNumChunksFromMsgFieldNumber = 27,
    kTotalChunkMsgSizeFieldNumber = 28,
    kChunkIdFieldNumber = 29,
    kNumMessagesInBatchFieldNumber = 11,
  };
  // repeated .pulsar.proto.KeyValue properties = 4;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::pulsar::proto::KeyValue* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_properties();
  private:
  const ::pulsar::proto::KeyValue& _internal_properties(int index) const;
  ::pulsar::proto::KeyValue* _internal_add_properties();
  public:
  const ::pulsar::proto::KeyValue& properties(int index) const;
  ::pulsar::proto::KeyValue* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      properties() const;

  // repeated string replicate_to = 7;
  int replicate_to_size() const;
  private:
  int _internal_replicate_to_size() const;
  public:
  void clear_replicate_to();
  const std::string& replicate_to(int index) const;
  std::string* mutable_replicate_to(int index);
  void set_replicate_to(int index, const std::string& value);
  void set_replicate_to(int index, std::string&& value);
  void set_replicate_to(int index, const char* value);
  void set_replicate_to(int index, const char* value, size_t size);
  std::string* add_replicate_to();
  void add_replicate_to(const std::string& value);
  void add_replicate_to(std::string&& value);
  void add_replicate_to(const char* value);
  void add_replicate_to(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& replicate_to() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_replicate_to();
  private:
  const std::string& _internal_replicate_to(int index) const;
  std::string* _internal_add_replicate_to();
  public:

  // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
  int encryption_keys_size() const;
  private:
  int _internal_encryption_keys_size() const;
  public:
  void clear_encryption_keys();
  ::pulsar::proto::EncryptionKeys* mutable_encryption_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >*
      mutable_encryption_keys();
  private:
  const ::pulsar::proto::EncryptionKeys& _internal_encryption_keys(int index) const;
  ::pulsar::proto::EncryptionKeys* _internal_add_encryption_keys();
  public:
  const ::pulsar::proto::EncryptionKeys& encryption_keys(int index) const;
  ::pulsar::proto::EncryptionKeys* add_encryption_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >&
      encryption_keys() const;

  // required string producer_name = 1;
  bool has_producer_name() const;
  private:
  bool _internal_has_producer_name() const;
  public:
  void clear_producer_name();
  const std::string& producer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_producer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_producer_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_producer_name();
  void set_allocated_producer_name(std::string* producer_name);
  private:
  const std::string& _internal_producer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_name(const std::string& value);
  std::string* _internal_mutable_producer_name();
  public:

  // optional string replicated_from = 5;
  bool has_replicated_from() const;
  private:
  bool _internal_has_replicated_from() const;
  public:
  void clear_replicated_from();
  const std::string& replicated_from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_replicated_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_replicated_from();
  PROTOBUF_MUST_USE_RESULT std::string* release_replicated_from();
  void set_allocated_replicated_from(std::string* replicated_from);
  private:
  const std::string& _internal_replicated_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replicated_from(const std::string& value);
  std::string* _internal_mutable_replicated_from();
  public:

  // optional string partition_key = 6;
  bool has_partition_key() const;
  private:
  bool _internal_has_partition_key() const;
  public:
  void clear_partition_key();
  const std::string& partition_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_partition_key();
  void set_allocated_partition_key(std::string* partition_key);
  private:
  const std::string& _internal_partition_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_key(const std::string& value);
  std::string* _internal_mutable_partition_key();
  public:

  // optional string encryption_algo = 14;
  bool has_encryption_algo() const;
  private:
  bool _internal_has_encryption_algo() const;
  public:
  void clear_encryption_algo();
  const std::string& encryption_algo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encryption_algo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encryption_algo();
  PROTOBUF_MUST_USE_RESULT std::string* release_encryption_algo();
  void set_allocated_encryption_algo(std::string* encryption_algo);
  private:
  const std::string& _internal_encryption_algo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption_algo(const std::string& value);
  std::string* _internal_mutable_encryption_algo();
  public:

  // optional bytes encryption_param = 15;
  bool has_encryption_param() const;
  private:
  bool _internal_has_encryption_param() const;
  public:
  void clear_encryption_param();
  const std::string& encryption_param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encryption_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encryption_param();
  PROTOBUF_MUST_USE_RESULT std::string* release_encryption_param();
  void set_allocated_encryption_param(std::string* encryption_param);
  private:
  const std::string& _internal_encryption_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption_param(const std::string& value);
  std::string* _internal_mutable_encryption_param();
  public:

  // optional bytes schema_version = 16;
  bool has_schema_version() const;
  private:
  bool _internal_has_schema_version() const;
  public:
  void clear_schema_version();
  const std::string& schema_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema_version();
  void set_allocated_schema_version(std::string* schema_version);
  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(const std::string& value);
  std::string* _internal_mutable_schema_version();
  public:

  // optional bytes ordering_key = 18;
  bool has_ordering_key() const;
  private:
  bool _internal_has_ordering_key() const;
  public:
  void clear_ordering_key();
  const std::string& ordering_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ordering_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ordering_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_ordering_key();
  void set_allocated_ordering_key(std::string* ordering_key);
  private:
  const std::string& _internal_ordering_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordering_key(const std::string& value);
  std::string* _internal_mutable_ordering_key();
  public:

  // optional string uuid = 26;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // required uint64 sequence_id = 2;
  bool has_sequence_id() const;
  private:
  bool _internal_has_sequence_id() const;
  public:
  void clear_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id() const;
  void set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence_id() const;
  void _internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 publish_time = 3;
  bool has_publish_time() const;
  private:
  bool _internal_has_publish_time() const;
  public:
  void clear_publish_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 publish_time() const;
  void set_publish_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_publish_time() const;
  void _internal_set_publish_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
  bool has_compression() const;
  private:
  bool _internal_has_compression() const;
  public:
  void clear_compression();
  ::pulsar::proto::CompressionType compression() const;
  void set_compression(::pulsar::proto::CompressionType value);
  private:
  ::pulsar::proto::CompressionType _internal_compression() const;
  void _internal_set_compression(::pulsar::proto::CompressionType value);
  public:

  // optional uint32 uncompressed_size = 9 [default = 0];
  bool has_uncompressed_size() const;
  private:
  bool _internal_has_uncompressed_size() const;
  public:
  void clear_uncompressed_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 uncompressed_size() const;
  void set_uncompressed_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_uncompressed_size() const;
  void _internal_set_uncompressed_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint64 event_time = 12 [default = 0];
  bool has_event_time() const;
  private:
  bool _internal_has_event_time() const;
  public:
  void clear_event_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 event_time() const;
  void set_event_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_event_time() const;
  void _internal_set_event_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int64 deliver_at_time = 19;
  bool has_deliver_at_time() const;
  private:
  bool _internal_has_deliver_at_time() const;
  public:
  void clear_deliver_at_time();
  ::PROTOBUF_NAMESPACE_ID::int64 deliver_at_time() const;
  void set_deliver_at_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_deliver_at_time() const;
  void _internal_set_deliver_at_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 txnid_least_bits = 22;
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 23;
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 marker_type = 20;
  bool has_marker_type() const;
  private:
  bool _internal_has_marker_type() const;
  public:
  void clear_marker_type();
  ::PROTOBUF_NAMESPACE_ID::int32 marker_type() const;
  void set_marker_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_marker_type() const;
  void _internal_set_marker_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool partition_key_b64_encoded = 17 [default = false];
  bool has_partition_key_b64_encoded() const;
  private:
  bool _internal_has_partition_key_b64_encoded() const;
  public:
  void clear_partition_key_b64_encoded();
  bool partition_key_b64_encoded() const;
  void set_partition_key_b64_encoded(bool value);
  private:
  bool _internal_partition_key_b64_encoded() const;
  void _internal_set_partition_key_b64_encoded(bool value);
  public:

  // optional bool null_value = 25 [default = false];
  bool has_null_value() const;
  private:
  bool _internal_has_null_value() const;
  public:
  void clear_null_value();
  bool null_value() const;
  void set_null_value(bool value);
  private:
  bool _internal_null_value() const;
  void _internal_set_null_value(bool value);
  public:

  // optional bool null_partition_key = 30 [default = false];
  bool has_null_partition_key() const;
  private:
  bool _internal_has_null_partition_key() const;
  public:
  void clear_null_partition_key();
  bool null_partition_key() const;
  void set_null_partition_key(bool value);
  private:
  bool _internal_null_partition_key() const;
  void _internal_set_null_partition_key(bool value);
  public:

  // optional uint64 highest_sequence_id = 24 [default = 0];
  bool has_highest_sequence_id() const;
  private:
  bool _internal_has_highest_sequence_id() const;
  public:
  void clear_highest_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 highest_sequence_id() const;
  void set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_highest_sequence_id() const;
  void _internal_set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 num_chunks_from_msg = 27;
  bool has_num_chunks_from_msg() const;
  private:
  bool _internal_has_num_chunks_from_msg() const;
  public:
  void clear_num_chunks_from_msg();
  ::PROTOBUF_NAMESPACE_ID::int32 num_chunks_from_msg() const;
  void set_num_chunks_from_msg(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_chunks_from_msg() const;
  void _internal_set_num_chunks_from_msg(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 total_chunk_msg_size = 28;
  bool has_total_chunk_msg_size() const;
  private:
  bool _internal_has_total_chunk_msg_size() const;
  public:
  void clear_total_chunk_msg_size();
  ::PROTOBUF_NAMESPACE_ID::int32 total_chunk_msg_size() const;
  void set_total_chunk_msg_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_total_chunk_msg_size() const;
  void _internal_set_total_chunk_msg_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 chunk_id = 29;
  bool has_chunk_id() const;
  private:
  bool _internal_has_chunk_id() const;
  public:
  void clear_chunk_id();
  ::PROTOBUF_NAMESPACE_ID::int32 chunk_id() const;
  void set_chunk_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_chunk_id() const;
  void _internal_set_chunk_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 num_messages_in_batch = 11 [default = 1];
  bool has_num_messages_in_batch() const;
  private:
  bool _internal_has_num_messages_in_batch() const;
  public:
  void clear_num_messages_in_batch();
  ::PROTOBUF_NAMESPACE_ID::int32 num_messages_in_batch() const;
  void set_num_messages_in_batch(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_messages_in_batch() const;
  void _internal_set_num_messages_in_batch(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.MessageMetadata)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue > properties_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> replicate_to_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::EncryptionKeys > encryption_keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr producer_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replicated_from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_algo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_param_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ordering_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 publish_time_;
  int compression_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uncompressed_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 event_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 deliver_at_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  ::PROTOBUF_NAMESPACE_ID::int32 marker_type_;
  bool partition_key_b64_encoded_;
  bool null_value_;
  bool null_partition_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 highest_sequence_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_chunks_from_msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 total_chunk_msg_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 chunk_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_messages_in_batch_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class SingleMessageMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.SingleMessageMetadata) */ {
 public:
  inline SingleMessageMetadata() : SingleMessageMetadata(nullptr) {}
  ~SingleMessageMetadata() override;
  explicit constexpr SingleMessageMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleMessageMetadata(const SingleMessageMetadata& from);
  SingleMessageMetadata(SingleMessageMetadata&& from) noexcept
    : SingleMessageMetadata() {
    *this = ::std::move(from);
  }

  inline SingleMessageMetadata& operator=(const SingleMessageMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleMessageMetadata& operator=(SingleMessageMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SingleMessageMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleMessageMetadata* internal_default_instance() {
    return reinterpret_cast<const SingleMessageMetadata*>(
               &_SingleMessageMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SingleMessageMetadata& a, SingleMessageMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleMessageMetadata* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleMessageMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleMessageMetadata* New() const final {
    return new SingleMessageMetadata();
  }

  SingleMessageMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleMessageMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SingleMessageMetadata& from);
  void MergeFrom(const SingleMessageMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SingleMessageMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.SingleMessageMetadata";
  }
  protected:
  explicit SingleMessageMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 1,
    kPartitionKeyFieldNumber = 2,
    kOrderingKeyFieldNumber = 7,
    kEventTimeFieldNumber = 5,
    kPayloadSizeFieldNumber = 3,
    kCompactedOutFieldNumber = 4,
    kPartitionKeyB64EncodedFieldNumber = 6,
    kNullValueFieldNumber = 9,
    kNullPartitionKeyFieldNumber = 10,
    kSequenceIdFieldNumber = 8,
  };
  // repeated .pulsar.proto.KeyValue properties = 1;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::pulsar::proto::KeyValue* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_properties();
  private:
  const ::pulsar::proto::KeyValue& _internal_properties(int index) const;
  ::pulsar::proto::KeyValue* _internal_add_properties();
  public:
  const ::pulsar::proto::KeyValue& properties(int index) const;
  ::pulsar::proto::KeyValue* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      properties() const;

  // optional string partition_key = 2;
  bool has_partition_key() const;
  private:
  bool _internal_has_partition_key() const;
  public:
  void clear_partition_key();
  const std::string& partition_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_partition_key();
  void set_allocated_partition_key(std::string* partition_key);
  private:
  const std::string& _internal_partition_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_key(const std::string& value);
  std::string* _internal_mutable_partition_key();
  public:

  // optional bytes ordering_key = 7;
  bool has_ordering_key() const;
  private:
  bool _internal_has_ordering_key() const;
  public:
  void clear_ordering_key();
  const std::string& ordering_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ordering_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ordering_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_ordering_key();
  void set_allocated_ordering_key(std::string* ordering_key);
  private:
  const std::string& _internal_ordering_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordering_key(const std::string& value);
  std::string* _internal_mutable_ordering_key();
  public:

  // optional uint64 event_time = 5 [default = 0];
  bool has_event_time() const;
  private:
  bool _internal_has_event_time() const;
  public:
  void clear_event_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 event_time() const;
  void set_event_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_event_time() const;
  void _internal_set_event_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required int32 payload_size = 3;
  bool has_payload_size() const;
  private:
  bool _internal_has_payload_size() const;
  public:
  void clear_payload_size();
  ::PROTOBUF_NAMESPACE_ID::int32 payload_size() const;
  void set_payload_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_payload_size() const;
  void _internal_set_payload_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool compacted_out = 4 [default = false];
  bool has_compacted_out() const;
  private:
  bool _internal_has_compacted_out() const;
  public:
  void clear_compacted_out();
  bool compacted_out() const;
  void set_compacted_out(bool value);
  private:
  bool _internal_compacted_out() const;
  void _internal_set_compacted_out(bool value);
  public:

  // optional bool partition_key_b64_encoded = 6 [default = false];
  bool has_partition_key_b64_encoded() const;
  private:
  bool _internal_has_partition_key_b64_encoded() const;
  public:
  void clear_partition_key_b64_encoded();
  bool partition_key_b64_encoded() const;
  void set_partition_key_b64_encoded(bool value);
  private:
  bool _internal_partition_key_b64_encoded() const;
  void _internal_set_partition_key_b64_encoded(bool value);
  public:

  // optional bool null_value = 9 [default = false];
  bool has_null_value() const;
  private:
  bool _internal_has_null_value() const;
  public:
  void clear_null_value();
  bool null_value() const;
  void set_null_value(bool value);
  private:
  bool _internal_null_value() const;
  void _internal_set_null_value(bool value);
  public:

  // optional bool null_partition_key = 10 [default = false];
  bool has_null_partition_key() const;
  private:
  bool _internal_has_null_partition_key() const;
  public:
  void clear_null_partition_key();
  bool null_partition_key() const;
  void set_null_partition_key(bool value);
  private:
  bool _internal_null_partition_key() const;
  void _internal_set_null_partition_key(bool value);
  public:

  // optional uint64 sequence_id = 8;
  bool has_sequence_id() const;
  private:
  bool _internal_has_sequence_id() const;
  public:
  void clear_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id() const;
  void set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence_id() const;
  void _internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.SingleMessageMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue > properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ordering_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 event_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 payload_size_;
  bool compacted_out_;
  bool partition_key_b64_encoded_;
  bool null_value_;
  bool null_partition_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class BrokerEntryMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.BrokerEntryMetadata) */ {
 public:
  inline BrokerEntryMetadata() : BrokerEntryMetadata(nullptr) {}
  ~BrokerEntryMetadata() override;
  explicit constexpr BrokerEntryMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrokerEntryMetadata(const BrokerEntryMetadata& from);
  BrokerEntryMetadata(BrokerEntryMetadata&& from) noexcept
    : BrokerEntryMetadata() {
    *this = ::std::move(from);
  }

  inline BrokerEntryMetadata& operator=(const BrokerEntryMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrokerEntryMetadata& operator=(BrokerEntryMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BrokerEntryMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrokerEntryMetadata* internal_default_instance() {
    return reinterpret_cast<const BrokerEntryMetadata*>(
               &_BrokerEntryMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BrokerEntryMetadata& a, BrokerEntryMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(BrokerEntryMetadata* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrokerEntryMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BrokerEntryMetadata* New() const final {
    return new BrokerEntryMetadata();
  }

  BrokerEntryMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BrokerEntryMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BrokerEntryMetadata& from);
  void MergeFrom(const BrokerEntryMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BrokerEntryMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.BrokerEntryMetadata";
  }
  protected:
  explicit BrokerEntryMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBrokerTimestampFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // optional uint64 broker_timestamp = 1;
  bool has_broker_timestamp() const;
  private:
  bool _internal_has_broker_timestamp() const;
  public:
  void clear_broker_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 broker_timestamp() const;
  void set_broker_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_broker_timestamp() const;
  void _internal_set_broker_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint64 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.BrokerEntryMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 broker_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 index_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandConnect final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandConnect) */ {
 public:
  inline CommandConnect() : CommandConnect(nullptr) {}
  ~CommandConnect() override;
  explicit constexpr CommandConnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandConnect(const CommandConnect& from);
  CommandConnect(CommandConnect&& from) noexcept
    : CommandConnect() {
    *this = ::std::move(from);
  }

  inline CommandConnect& operator=(const CommandConnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConnect& operator=(CommandConnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandConnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConnect* internal_default_instance() {
    return reinterpret_cast<const CommandConnect*>(
               &_CommandConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CommandConnect& a, CommandConnect& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandConnect* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandConnect* New() const final {
    return new CommandConnect();
  }

  CommandConnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandConnect>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandConnect& from);
  void MergeFrom(const CommandConnect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandConnect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandConnect";
  }
  protected:
  explicit CommandConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientVersionFieldNumber = 1,
    kAuthDataFieldNumber = 3,
    kAuthMethodNameFieldNumber = 5,
    kProxyToBrokerUrlFieldNumber = 6,
    kOriginalPrincipalFieldNumber = 7,
    kOriginalAuthDataFieldNumber = 8,
    kOriginalAuthMethodFieldNumber = 9,
    kFeatureFlagsFieldNumber = 10,
    kAuthMethodFieldNumber = 2,
    kProtocolVersionFieldNumber = 4,
  };
  // required string client_version = 1;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  const std::string& client_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);
  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
  std::string* _internal_mutable_client_version();
  public:

  // optional bytes auth_data = 3;
  bool has_auth_data() const;
  private:
  bool _internal_has_auth_data() const;
  public:
  void clear_auth_data();
  const std::string& auth_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_auth_data();
  void set_allocated_auth_data(std::string* auth_data);
  private:
  const std::string& _internal_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_data(const std::string& value);
  std::string* _internal_mutable_auth_data();
  public:

  // optional string auth_method_name = 5;
  bool has_auth_method_name() const;
  private:
  bool _internal_has_auth_method_name() const;
  public:
  void clear_auth_method_name();
  const std::string& auth_method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_method_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_auth_method_name();
  void set_allocated_auth_method_name(std::string* auth_method_name);
  private:
  const std::string& _internal_auth_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_method_name(const std::string& value);
  std::string* _internal_mutable_auth_method_name();
  public:

  // optional string proxy_to_broker_url = 6;
  bool has_proxy_to_broker_url() const;
  private:
  bool _internal_has_proxy_to_broker_url() const;
  public:
  void clear_proxy_to_broker_url();
  const std::string& proxy_to_broker_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proxy_to_broker_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proxy_to_broker_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_proxy_to_broker_url();
  void set_allocated_proxy_to_broker_url(std::string* proxy_to_broker_url);
  private:
  const std::string& _internal_proxy_to_broker_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxy_to_broker_url(const std::string& value);
  std::string* _internal_mutable_proxy_to_broker_url();
  public:

  // optional string original_principal = 7;
  bool has_original_principal() const;
  private:
  bool _internal_has_original_principal() const;
  public:
  void clear_original_principal();
  const std::string& original_principal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_principal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_principal();
  PROTOBUF_MUST_USE_RESULT std::string* release_original_principal();
  void set_allocated_original_principal(std::string* original_principal);
  private:
  const std::string& _internal_original_principal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_principal(const std::string& value);
  std::string* _internal_mutable_original_principal();
  public:

  // optional string original_auth_data = 8;
  bool has_original_auth_data() const;
  private:
  bool _internal_has_original_auth_data() const;
  public:
  void clear_original_auth_data();
  const std::string& original_auth_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_auth_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_auth_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_original_auth_data();
  void set_allocated_original_auth_data(std::string* original_auth_data);
  private:
  const std::string& _internal_original_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_data(const std::string& value);
  std::string* _internal_mutable_original_auth_data();
  public:

  // optional string original_auth_method = 9;
  bool has_original_auth_method() const;
  private:
  bool _internal_has_original_auth_method() const;
  public:
  void clear_original_auth_method();
  const std::string& original_auth_method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_auth_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_auth_method();
  PROTOBUF_MUST_USE_RESULT std::string* release_original_auth_method();
  void set_allocated_original_auth_method(std::string* original_auth_method);
  private:
  const std::string& _internal_original_auth_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_method(const std::string& value);
  std::string* _internal_mutable_original_auth_method();
  public:

  // optional .pulsar.proto.FeatureFlags feature_flags = 10;
  bool has_feature_flags() const;
  private:
  bool _internal_has_feature_flags() const;
  public:
  void clear_feature_flags();
  const ::pulsar::proto::FeatureFlags& feature_flags() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::FeatureFlags* release_feature_flags();
  ::pulsar::proto::FeatureFlags* mutable_feature_flags();
  void set_allocated_feature_flags(::pulsar::proto::FeatureFlags* feature_flags);
  private:
  const ::pulsar::proto::FeatureFlags& _internal_feature_flags() const;
  ::pulsar::proto::FeatureFlags* _internal_mutable_feature_flags();
  public:
  void unsafe_arena_set_allocated_feature_flags(
      ::pulsar::proto::FeatureFlags* feature_flags);
  ::pulsar::proto::FeatureFlags* unsafe_arena_release_feature_flags();

  // optional .pulsar.proto.AuthMethod auth_method = 2;
  bool has_auth_method() const;
  private:
  bool _internal_has_auth_method() const;
  public:
  void clear_auth_method();
  ::pulsar::proto::AuthMethod auth_method() const;
  void set_auth_method(::pulsar::proto::AuthMethod value);
  private:
  ::pulsar::proto::AuthMethod _internal_auth_method() const;
  void _internal_set_auth_method(::pulsar::proto::AuthMethod value);
  public:

  // optional int32 protocol_version = 4 [default = 0];
  bool has_protocol_version() const;
  private:
  bool _internal_has_protocol_version() const;
  public:
  void clear_protocol_version();
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_version() const;
  void set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_protocol_version() const;
  void _internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_method_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proxy_to_broker_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_principal_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_auth_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_auth_method_;
  ::pulsar::proto::FeatureFlags* feature_flags_;
  int auth_method_;
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_version_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class FeatureFlags final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.FeatureFlags) */ {
 public:
  inline FeatureFlags() : FeatureFlags(nullptr) {}
  ~FeatureFlags() override;
  explicit constexpr FeatureFlags(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeatureFlags(const FeatureFlags& from);
  FeatureFlags(FeatureFlags&& from) noexcept
    : FeatureFlags() {
    *this = ::std::move(from);
  }

  inline FeatureFlags& operator=(const FeatureFlags& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureFlags& operator=(FeatureFlags&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FeatureFlags& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeatureFlags* internal_default_instance() {
    return reinterpret_cast<const FeatureFlags*>(
               &_FeatureFlags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FeatureFlags& a, FeatureFlags& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureFlags* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureFlags* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeatureFlags* New() const final {
    return new FeatureFlags();
  }

  FeatureFlags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeatureFlags>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FeatureFlags& from);
  void MergeFrom(const FeatureFlags& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureFlags* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.FeatureFlags";
  }
  protected:
  explicit FeatureFlags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportsAuthRefreshFieldNumber = 1,
    kSupportsBrokerEntryMetadataFieldNumber = 2,
    kSupportsPartialProducerFieldNumber = 3,
    kSupportsTopicWatchersFieldNumber = 4,
  };
  // optional bool supports_auth_refresh = 1 [default = false];
  bool has_supports_auth_refresh() const;
  private:
  bool _internal_has_supports_auth_refresh() const;
  public:
  void clear_supports_auth_refresh();
  bool supports_auth_refresh() const;
  void set_supports_auth_refresh(bool value);
  private:
  bool _internal_supports_auth_refresh() const;
  void _internal_set_supports_auth_refresh(bool value);
  public:

  // optional bool supports_broker_entry_metadata = 2 [default = false];
  bool has_supports_broker_entry_metadata() const;
  private:
  bool _internal_has_supports_broker_entry_metadata() const;
  public:
  void clear_supports_broker_entry_metadata();
  bool supports_broker_entry_metadata() const;
  void set_supports_broker_entry_metadata(bool value);
  private:
  bool _internal_supports_broker_entry_metadata() const;
  void _internal_set_supports_broker_entry_metadata(bool value);
  public:

  // optional bool supports_partial_producer = 3 [default = false];
  bool has_supports_partial_producer() const;
  private:
  bool _internal_has_supports_partial_producer() const;
  public:
  void clear_supports_partial_producer();
  bool supports_partial_producer() const;
  void set_supports_partial_producer(bool value);
  private:
  bool _internal_supports_partial_producer() const;
  void _internal_set_supports_partial_producer(bool value);
  public:

  // optional bool supports_topic_watchers = 4 [default = false];
  bool has_supports_topic_watchers() const;
  private:
  bool _internal_has_supports_topic_watchers() const;
  public:
  void clear_supports_topic_watchers();
  bool supports_topic_watchers() const;
  void set_supports_topic_watchers(bool value);
  private:
  bool _internal_supports_topic_watchers() const;
  void _internal_set_supports_topic_watchers(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.FeatureFlags)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool supports_auth_refresh_;
  bool supports_broker_entry_metadata_;
  bool supports_partial_producer_;
  bool supports_topic_watchers_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandConnected final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandConnected) */ {
 public:
  inline CommandConnected() : CommandConnected(nullptr) {}
  ~CommandConnected() override;
  explicit constexpr CommandConnected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandConnected(const CommandConnected& from);
  CommandConnected(CommandConnected&& from) noexcept
    : CommandConnected() {
    *this = ::std::move(from);
  }

  inline CommandConnected& operator=(const CommandConnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConnected& operator=(CommandConnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandConnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConnected* internal_default_instance() {
    return reinterpret_cast<const CommandConnected*>(
               &_CommandConnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CommandConnected& a, CommandConnected& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandConnected* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConnected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandConnected* New() const final {
    return new CommandConnected();
  }

  CommandConnected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandConnected>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandConnected& from);
  void MergeFrom(const CommandConnected& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandConnected* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandConnected";
  }
  protected:
  explicit CommandConnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerVersionFieldNumber = 1,
    kFeatureFlagsFieldNumber = 4,
    kProtocolVersionFieldNumber = 2,
    kMaxMessageSizeFieldNumber = 3,
  };
  // required string server_version = 1;
  bool has_server_version() const;
  private:
  bool _internal_has_server_version() const;
  public:
  void clear_server_version();
  const std::string& server_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_version();
  void set_allocated_server_version(std::string* server_version);
  private:
  const std::string& _internal_server_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_version(const std::string& value);
  std::string* _internal_mutable_server_version();
  public:

  // optional .pulsar.proto.FeatureFlags feature_flags = 4;
  bool has_feature_flags() const;
  private:
  bool _internal_has_feature_flags() const;
  public:
  void clear_feature_flags();
  const ::pulsar::proto::FeatureFlags& feature_flags() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::FeatureFlags* release_feature_flags();
  ::pulsar::proto::FeatureFlags* mutable_feature_flags();
  void set_allocated_feature_flags(::pulsar::proto::FeatureFlags* feature_flags);
  private:
  const ::pulsar::proto::FeatureFlags& _internal_feature_flags() const;
  ::pulsar::proto::FeatureFlags* _internal_mutable_feature_flags();
  public:
  void unsafe_arena_set_allocated_feature_flags(
      ::pulsar::proto::FeatureFlags* feature_flags);
  ::pulsar::proto::FeatureFlags* unsafe_arena_release_feature_flags();

  // optional int32 protocol_version = 2 [default = 0];
  bool has_protocol_version() const;
  private:
  bool _internal_has_protocol_version() const;
  public:
  void clear_protocol_version();
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_version() const;
  void set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_protocol_version() const;
  void _internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 max_message_size = 3;
  bool has_max_message_size() const;
  private:
  bool _internal_has_max_message_size() const;
  public:
  void clear_max_message_size();
  ::PROTOBUF_NAMESPACE_ID::int32 max_message_size() const;
  void set_max_message_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_message_size() const;
  void _internal_set_max_message_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConnected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_version_;
  ::pulsar::proto::FeatureFlags* feature_flags_;
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_message_size_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandAuthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAuthResponse) */ {
 public:
  inline CommandAuthResponse() : CommandAuthResponse(nullptr) {}
  ~CommandAuthResponse() override;
  explicit constexpr CommandAuthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandAuthResponse(const CommandAuthResponse& from);
  CommandAuthResponse(CommandAuthResponse&& from) noexcept
    : CommandAuthResponse() {
    *this = ::std::move(from);
  }

  inline CommandAuthResponse& operator=(const CommandAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAuthResponse& operator=(CommandAuthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAuthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAuthResponse* internal_default_instance() {
    return reinterpret_cast<const CommandAuthResponse*>(
               &_CommandAuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CommandAuthResponse& a, CommandAuthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAuthResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAuthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandAuthResponse* New() const final {
    return new CommandAuthResponse();
  }

  CommandAuthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandAuthResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandAuthResponse& from);
  void MergeFrom(const CommandAuthResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandAuthResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandAuthResponse";
  }
  protected:
  explicit CommandAuthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientVersionFieldNumber = 1,
    kResponseFieldNumber = 2,
    kProtocolVersionFieldNumber = 3,
  };
  // optional string client_version = 1;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  const std::string& client_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);
  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
  std::string* _internal_mutable_client_version();
  public:

  // optional .pulsar.proto.AuthData response = 2;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::pulsar::proto::AuthData& response() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::AuthData* release_response();
  ::pulsar::proto::AuthData* mutable_response();
  void set_allocated_response(::pulsar::proto::AuthData* response);
  private:
  const ::pulsar::proto::AuthData& _internal_response() const;
  ::pulsar::proto::AuthData* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::pulsar::proto::AuthData* response);
  ::pulsar::proto::AuthData* unsafe_arena_release_response();

  // optional int32 protocol_version = 3 [default = 0];
  bool has_protocol_version() const;
  private:
  bool _internal_has_protocol_version() const;
  public:
  void clear_protocol_version();
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_version() const;
  void set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_protocol_version() const;
  void _internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAuthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
  ::pulsar::proto::AuthData* response_;
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_version_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandAuthChallenge final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAuthChallenge) */ {
 public:
  inline CommandAuthChallenge() : CommandAuthChallenge(nullptr) {}
  ~CommandAuthChallenge() override;
  explicit constexpr CommandAuthChallenge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandAuthChallenge(const CommandAuthChallenge& from);
  CommandAuthChallenge(CommandAuthChallenge&& from) noexcept
    : CommandAuthChallenge() {
    *this = ::std::move(from);
  }

  inline CommandAuthChallenge& operator=(const CommandAuthChallenge& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAuthChallenge& operator=(CommandAuthChallenge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAuthChallenge& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAuthChallenge* internal_default_instance() {
    return reinterpret_cast<const CommandAuthChallenge*>(
               &_CommandAuthChallenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CommandAuthChallenge& a, CommandAuthChallenge& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAuthChallenge* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAuthChallenge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandAuthChallenge* New() const final {
    return new CommandAuthChallenge();
  }

  CommandAuthChallenge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandAuthChallenge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandAuthChallenge& from);
  void MergeFrom(const CommandAuthChallenge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandAuthChallenge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandAuthChallenge";
  }
  protected:
  explicit CommandAuthChallenge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerVersionFieldNumber = 1,
    kChallengeFieldNumber = 2,
    kProtocolVersionFieldNumber = 3,
  };
  // optional string server_version = 1;
  bool has_server_version() const;
  private:
  bool _internal_has_server_version() const;
  public:
  void clear_server_version();
  const std::string& server_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_version();
  void set_allocated_server_version(std::string* server_version);
  private:
  const std::string& _internal_server_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_version(const std::string& value);
  std::string* _internal_mutable_server_version();
  public:

  // optional .pulsar.proto.AuthData challenge = 2;
  bool has_challenge() const;
  private:
  bool _internal_has_challenge() const;
  public:
  void clear_challenge();
  const ::pulsar::proto::AuthData& challenge() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::AuthData* release_challenge();
  ::pulsar::proto::AuthData* mutable_challenge();
  void set_allocated_challenge(::pulsar::proto::AuthData* challenge);
  private:
  const ::pulsar::proto::AuthData& _internal_challenge() const;
  ::pulsar::proto::AuthData* _internal_mutable_challenge();
  public:
  void unsafe_arena_set_allocated_challenge(
      ::pulsar::proto::AuthData* challenge);
  ::pulsar::proto::AuthData* unsafe_arena_release_challenge();

  // optional int32 protocol_version = 3 [default = 0];
  bool has_protocol_version() const;
  private:
  bool _internal_has_protocol_version() const;
  public:
  void clear_protocol_version();
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_version() const;
  void set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_protocol_version() const;
  void _internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAuthChallenge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_version_;
  ::pulsar::proto::AuthData* challenge_;
  ::PROTOBUF_NAMESPACE_ID::int32 protocol_version_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class AuthData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.AuthData) */ {
 public:
  inline AuthData() : AuthData(nullptr) {}
  ~AuthData() override;
  explicit constexpr AuthData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthData(const AuthData& from);
  AuthData(AuthData&& from) noexcept
    : AuthData() {
    *this = ::std::move(from);
  }

  inline AuthData& operator=(const AuthData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthData& operator=(AuthData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AuthData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthData* internal_default_instance() {
    return reinterpret_cast<const AuthData*>(
               &_AuthData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AuthData& a, AuthData& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthData* New() const final {
    return new AuthData();
  }

  AuthData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AuthData& from);
  void MergeFrom(const AuthData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.AuthData";
  }
  protected:
  explicit AuthData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthMethodNameFieldNumber = 1,
    kAuthDataFieldNumber = 2,
  };
  // optional string auth_method_name = 1;
  bool has_auth_method_name() const;
  private:
  bool _internal_has_auth_method_name() const;
  public:
  void clear_auth_method_name();
  const std::string& auth_method_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_method_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_method_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_auth_method_name();
  void set_allocated_auth_method_name(std::string* auth_method_name);
  private:
  const std::string& _internal_auth_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_method_name(const std::string& value);
  std::string* _internal_mutable_auth_method_name();
  public:

  // optional bytes auth_data = 2;
  bool has_auth_data() const;
  private:
  bool _internal_has_auth_data() const;
  public:
  void clear_auth_data();
  const std::string& auth_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_auth_data();
  void set_allocated_auth_data(std::string* auth_data);
  private:
  const std::string& _internal_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_data(const std::string& value);
  std::string* _internal_mutable_auth_data();
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.AuthData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_method_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_data_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class KeySharedMeta final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.KeySharedMeta) */ {
 public:
  inline KeySharedMeta() : KeySharedMeta(nullptr) {}
  ~KeySharedMeta() override;
  explicit constexpr KeySharedMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeySharedMeta(const KeySharedMeta& from);
  KeySharedMeta(KeySharedMeta&& from) noexcept
    : KeySharedMeta() {
    *this = ::std::move(from);
  }

  inline KeySharedMeta& operator=(const KeySharedMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeySharedMeta& operator=(KeySharedMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeySharedMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeySharedMeta* internal_default_instance() {
    return reinterpret_cast<const KeySharedMeta*>(
               &_KeySharedMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(KeySharedMeta& a, KeySharedMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(KeySharedMeta* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeySharedMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeySharedMeta* New() const final {
    return new KeySharedMeta();
  }

  KeySharedMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeySharedMeta>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KeySharedMeta& from);
  void MergeFrom(const KeySharedMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeySharedMeta* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.KeySharedMeta";
  }
  protected:
  explicit KeySharedMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashRangesFieldNumber = 3,
    kKeySharedModeFieldNumber = 1,
    kAllowOutOfOrderDeliveryFieldNumber = 4,
  };
  // repeated .pulsar.proto.IntRange hashRanges = 3;
  int hashranges_size() const;
  private:
  int _internal_hashranges_size() const;
  public:
  void clear_hashranges();
  ::pulsar::proto::IntRange* mutable_hashranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::IntRange >*
      mutable_hashranges();
  private:
  const ::pulsar::proto::IntRange& _internal_hashranges(int index) const;
  ::pulsar::proto::IntRange* _internal_add_hashranges();
  public:
  const ::pulsar::proto::IntRange& hashranges(int index) const;
  ::pulsar::proto::IntRange* add_hashranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::IntRange >&
      hashranges() const;

  // required .pulsar.proto.KeySharedMode keySharedMode = 1;
  bool has_keysharedmode() const;
  private:
  bool _internal_has_keysharedmode() const;
  public:
  void clear_keysharedmode();
  ::pulsar::proto::KeySharedMode keysharedmode() const;
  void set_keysharedmode(::pulsar::proto::KeySharedMode value);
  private:
  ::pulsar::proto::KeySharedMode _internal_keysharedmode() const;
  void _internal_set_keysharedmode(::pulsar::proto::KeySharedMode value);
  public:

  // optional bool allowOutOfOrderDelivery = 4 [default = false];
  bool has_allowoutoforderdelivery() const;
  private:
  bool _internal_has_allowoutoforderdelivery() const;
  public:
  void clear_allowoutoforderdelivery();
  bool allowoutoforderdelivery() const;
  void set_allowoutoforderdelivery(bool value);
  private:
  bool _internal_allowoutoforderdelivery() const;
  void _internal_set_allowoutoforderdelivery(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.KeySharedMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::IntRange > hashranges_;
  int keysharedmode_;
  bool allowoutoforderdelivery_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandSubscribe final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSubscribe) */ {
 public:
  inline CommandSubscribe() : CommandSubscribe(nullptr) {}
  ~CommandSubscribe() override;
  explicit constexpr CommandSubscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandSubscribe(const CommandSubscribe& from);
  CommandSubscribe(CommandSubscribe&& from) noexcept
    : CommandSubscribe() {
    *this = ::std::move(from);
  }

  inline CommandSubscribe& operator=(const CommandSubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSubscribe& operator=(CommandSubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSubscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSubscribe* internal_default_instance() {
    return reinterpret_cast<const CommandSubscribe*>(
               &_CommandSubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CommandSubscribe& a, CommandSubscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSubscribe* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSubscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandSubscribe* New() const final {
    return new CommandSubscribe();
  }

  CommandSubscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandSubscribe>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandSubscribe& from);
  void MergeFrom(const CommandSubscribe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandSubscribe* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandSubscribe";
  }
  protected:
  explicit CommandSubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CommandSubscribe_SubType SubType;
  static constexpr SubType Exclusive =
    CommandSubscribe_SubType_Exclusive;
  static constexpr SubType Shared =
    CommandSubscribe_SubType_Shared;
  static constexpr SubType Failover =
    CommandSubscribe_SubType_Failover;
  static constexpr SubType Key_Shared =
    CommandSubscribe_SubType_Key_Shared;
  static inline bool SubType_IsValid(int value) {
    return CommandSubscribe_SubType_IsValid(value);
  }
  static constexpr SubType SubType_MIN =
    CommandSubscribe_SubType_SubType_MIN;
  static constexpr SubType SubType_MAX =
    CommandSubscribe_SubType_SubType_MAX;
  static constexpr int SubType_ARRAYSIZE =
    CommandSubscribe_SubType_SubType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SubType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubType_Name.");
    return CommandSubscribe_SubType_Name(enum_t_value);
  }
  static inline bool SubType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SubType* value) {
    return CommandSubscribe_SubType_Parse(name, value);
  }

  typedef CommandSubscribe_InitialPosition InitialPosition;
  static constexpr InitialPosition Latest =
    CommandSubscribe_InitialPosition_Latest;
  static constexpr InitialPosition Earliest =
    CommandSubscribe_InitialPosition_Earliest;
  static inline bool InitialPosition_IsValid(int value) {
    return CommandSubscribe_InitialPosition_IsValid(value);
  }
  static constexpr InitialPosition InitialPosition_MIN =
    CommandSubscribe_InitialPosition_InitialPosition_MIN;
  static constexpr InitialPosition InitialPosition_MAX =
    CommandSubscribe_InitialPosition_InitialPosition_MAX;
  static constexpr int InitialPosition_ARRAYSIZE =
    CommandSubscribe_InitialPosition_InitialPosition_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InitialPosition_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InitialPosition>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InitialPosition_Name.");
    return CommandSubscribe_InitialPosition_Name(enum_t_value);
  }
  static inline bool InitialPosition_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InitialPosition* value) {
    return CommandSubscribe_InitialPosition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 10,
    kSubscriptionPropertiesFieldNumber = 18,
    kTopicFieldNumber = 1,
    kSubscriptionFieldNumber = 2,
    kConsumerNameFieldNumber = 6,
    kStartMessageIdFieldNumber = 9,
    kSchemaFieldNumber = 12,
    kKeySharedMetaFieldNumber = 17,
    kConsumerIdFieldNumber = 4,
    kRequestIdFieldNumber = 5,
    kSubTypeFieldNumber = 3,
    kPriorityLevelFieldNumber = 7,
    kReadCompactedFieldNumber = 11,
    kReplicateSubscriptionStateFieldNumber = 14,
    kInitialPositionFieldNumber = 13,
    kStartMessageRollbackDurationSecFieldNumber = 16,
    kConsumerEpochFieldNumber = 19,
    kDurableFieldNumber = 8,
    kForceTopicCreationFieldNumber = 15,
  };
  // repeated .pulsar.proto.KeyValue metadata = 10;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::pulsar::proto::KeyValue* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_metadata();
  private:
  const ::pulsar::proto::KeyValue& _internal_metadata(int index) const;
  ::pulsar::proto::KeyValue* _internal_add_metadata();
  public:
  const ::pulsar::proto::KeyValue& metadata(int index) const;
  ::pulsar::proto::KeyValue* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      metadata() const;

  // repeated .pulsar.proto.KeyValue subscription_properties = 18;
  int subscription_properties_size() const;
  private:
  int _internal_subscription_properties_size() const;
  public:
  void clear_subscription_properties();
  ::pulsar::proto::KeyValue* mutable_subscription_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_subscription_properties();
  private:
  const ::pulsar::proto::KeyValue& _internal_subscription_properties(int index) const;
  ::pulsar::proto::KeyValue* _internal_add_subscription_properties();
  public:
  const ::pulsar::proto::KeyValue& subscription_properties(int index) const;
  ::pulsar::proto::KeyValue* add_subscription_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      subscription_properties() const;

  // required string topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // required string subscription = 2;
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const std::string& subscription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscription();
  void set_allocated_subscription(std::string* subscription);
  private:
  const std::string& _internal_subscription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription(const std::string& value);
  std::string* _internal_mutable_subscription();
  public:

  // optional string consumer_name = 6;
  bool has_consumer_name() const;
  private:
  bool _internal_has_consumer_name() const;
  public:
  void clear_consumer_name();
  const std::string& consumer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consumer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consumer_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_consumer_name();
  void set_allocated_consumer_name(std::string* consumer_name);
  private:
  const std::string& _internal_consumer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumer_name(const std::string& value);
  std::string* _internal_mutable_consumer_name();
  public:

  // optional .pulsar.proto.MessageIdData start_message_id = 9;
  bool has_start_message_id() const;
  private:
  bool _internal_has_start_message_id() const;
  public:
  void clear_start_message_id();
  const ::pulsar::proto::MessageIdData& start_message_id() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::MessageIdData* release_start_message_id();
  ::pulsar::proto::MessageIdData* mutable_start_message_id();
  void set_allocated_start_message_id(::pulsar::proto::MessageIdData* start_message_id);
  private:
  const ::pulsar::proto::MessageIdData& _internal_start_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_start_message_id();
  public:
  void unsafe_arena_set_allocated_start_message_id(
      ::pulsar::proto::MessageIdData* start_message_id);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_start_message_id();

  // optional .pulsar.proto.Schema schema = 12;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* schema);
  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::pulsar::proto::Schema* schema);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
  bool has_keysharedmeta() const;
  private:
  bool _internal_has_keysharedmeta() const;
  public:
  void clear_keysharedmeta();
  const ::pulsar::proto::KeySharedMeta& keysharedmeta() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::KeySharedMeta* release_keysharedmeta();
  ::pulsar::proto::KeySharedMeta* mutable_keysharedmeta();
  void set_allocated_keysharedmeta(::pulsar::proto::KeySharedMeta* keysharedmeta);
  private:
  const ::pulsar::proto::KeySharedMeta& _internal_keysharedmeta() const;
  ::pulsar::proto::KeySharedMeta* _internal_mutable_keysharedmeta();
  public:
  void unsafe_arena_set_allocated_keysharedmeta(
      ::pulsar::proto::KeySharedMeta* keysharedmeta);
  ::pulsar::proto::KeySharedMeta* unsafe_arena_release_keysharedmeta();

  // required uint64 consumer_id = 4;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 request_id = 5;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
  bool has_subtype() const;
  private:
  bool _internal_has_subtype() const;
  public:
  void clear_subtype();
  ::pulsar::proto::CommandSubscribe_SubType subtype() const;
  void set_subtype(::pulsar::proto::CommandSubscribe_SubType value);
  private:
  ::pulsar::proto::CommandSubscribe_SubType _internal_subtype() const;
  void _internal_set_subtype(::pulsar::proto::CommandSubscribe_SubType value);
  public:

  // optional int32 priority_level = 7;
  bool has_priority_level() const;
  private:
  bool _internal_has_priority_level() const;
  public:
  void clear_priority_level();
  ::PROTOBUF_NAMESPACE_ID::int32 priority_level() const;
  void set_priority_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_priority_level() const;
  void _internal_set_priority_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool read_compacted = 11;
  bool has_read_compacted() const;
  private:
  bool _internal_has_read_compacted() const;
  public:
  void clear_read_compacted();
  bool read_compacted() const;
  void set_read_compacted(bool value);
  private:
  bool _internal_read_compacted() const;
  void _internal_set_read_compacted(bool value);
  public:

  // optional bool replicate_subscription_state = 14;
  bool has_replicate_subscription_state() const;
  private:
  bool _internal_has_replicate_subscription_state() const;
  public:
  void clear_replicate_subscription_state();
  bool replicate_subscription_state() const;
  void set_replicate_subscription_state(bool value);
  private:
  bool _internal_replicate_subscription_state() const;
  void _internal_set_replicate_subscription_state(bool value);
  public:

  // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
  bool has_initialposition() const;
  private:
  bool _internal_has_initialposition() const;
  public:
  void clear_initialposition();
  ::pulsar::proto::CommandSubscribe_InitialPosition initialposition() const;
  void set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value);
  private:
  ::pulsar::proto::CommandSubscribe_InitialPosition _internal_initialposition() const;
  void _internal_set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value);
  public:

  // optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
  bool has_start_message_rollback_duration_sec() const;
  private:
  bool _internal_has_start_message_rollback_duration_sec() const;
  public:
  void clear_start_message_rollback_duration_sec();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_message_rollback_duration_sec() const;
  void set_start_message_rollback_duration_sec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_message_rollback_duration_sec() const;
  void _internal_set_start_message_rollback_duration_sec(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 consumer_epoch = 19;
  bool has_consumer_epoch() const;
  private:
  bool _internal_has_consumer_epoch() const;
  public:
  void clear_consumer_epoch();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_epoch() const;
  void set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_epoch() const;
  void _internal_set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool durable = 8 [default = true];
  bool has_durable() const;
  private:
  bool _internal_has_durable() const;
  public:
  void clear_durable();
  bool durable() const;
  void set_durable(bool value);
  private:
  bool _internal_durable() const;
  void _internal_set_durable(bool value);
  public:

  // optional bool force_topic_creation = 15 [default = true];
  bool has_force_topic_creation() const;
  private:
  bool _internal_has_force_topic_creation() const;
  public:
  void clear_force_topic_creation();
  bool force_topic_creation() const;
  void set_force_topic_creation(bool value);
  private:
  bool _internal_force_topic_creation() const;
  void _internal_set_force_topic_creation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSubscribe)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue > metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue > subscription_properties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consumer_name_;
  ::pulsar::proto::MessageIdData* start_message_id_;
  ::pulsar::proto::Schema* schema_;
  ::pulsar::proto::KeySharedMeta* keysharedmeta_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  int subtype_;
  ::PROTOBUF_NAMESPACE_ID::int32 priority_level_;
  bool read_compacted_;
  bool replicate_subscription_state_;
  int initialposition_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_message_rollback_duration_sec_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_epoch_;
  bool durable_;
  bool force_topic_creation_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandPartitionedTopicMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandPartitionedTopicMetadata) */ {
 public:
  inline CommandPartitionedTopicMetadata() : CommandPartitionedTopicMetadata(nullptr) {}
  ~CommandPartitionedTopicMetadata() override;
  explicit constexpr CommandPartitionedTopicMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandPartitionedTopicMetadata(const CommandPartitionedTopicMetadata& from);
  CommandPartitionedTopicMetadata(CommandPartitionedTopicMetadata&& from) noexcept
    : CommandPartitionedTopicMetadata() {
    *this = ::std::move(from);
  }

  inline CommandPartitionedTopicMetadata& operator=(const CommandPartitionedTopicMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPartitionedTopicMetadata& operator=(CommandPartitionedTopicMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandPartitionedTopicMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandPartitionedTopicMetadata* internal_default_instance() {
    return reinterpret_cast<const CommandPartitionedTopicMetadata*>(
               &_CommandPartitionedTopicMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CommandPartitionedTopicMetadata& a, CommandPartitionedTopicMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPartitionedTopicMetadata* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPartitionedTopicMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandPartitionedTopicMetadata* New() const final {
    return new CommandPartitionedTopicMetadata();
  }

  CommandPartitionedTopicMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandPartitionedTopicMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandPartitionedTopicMetadata& from);
  void MergeFrom(const CommandPartitionedTopicMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandPartitionedTopicMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandPartitionedTopicMetadata";
  }
  protected:
  explicit CommandPartitionedTopicMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kOriginalPrincipalFieldNumber = 3,
    kOriginalAuthDataFieldNumber = 4,
    kOriginalAuthMethodFieldNumber = 5,
    kRequestIdFieldNumber = 2,
  };
  // required string topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // optional string original_principal = 3;
  bool has_original_principal() const;
  private:
  bool _internal_has_original_principal() const;
  public:
  void clear_original_principal();
  const std::string& original_principal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_principal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_principal();
  PROTOBUF_MUST_USE_RESULT std::string* release_original_principal();
  void set_allocated_original_principal(std::string* original_principal);
  private:
  const std::string& _internal_original_principal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_principal(const std::string& value);
  std::string* _internal_mutable_original_principal();
  public:

  // optional string original_auth_data = 4;
  bool has_original_auth_data() const;
  private:
  bool _internal_has_original_auth_data() const;
  public:
  void clear_original_auth_data();
  const std::string& original_auth_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_auth_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_auth_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_original_auth_data();
  void set_allocated_original_auth_data(std::string* original_auth_data);
  private:
  const std::string& _internal_original_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_data(const std::string& value);
  std::string* _internal_mutable_original_auth_data();
  public:

  // optional string original_auth_method = 5;
  bool has_original_auth_method() const;
  private:
  bool _internal_has_original_auth_method() const;
  public:
  void clear_original_auth_method();
  const std::string& original_auth_method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_auth_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_auth_method();
  PROTOBUF_MUST_USE_RESULT std::string* release_original_auth_method();
  void set_allocated_original_auth_method(std::string* original_auth_method);
  private:
  const std::string& _internal_original_auth_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_method(const std::string& value);
  std::string* _internal_mutable_original_auth_method();
  public:

  // required uint64 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPartitionedTopicMetadata)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_principal_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_auth_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_auth_method_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandPartitionedTopicMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandPartitionedTopicMetadataResponse) */ {
 public:
  inline CommandPartitionedTopicMetadataResponse() : CommandPartitionedTopicMetadataResponse(nullptr) {}
  ~CommandPartitionedTopicMetadataResponse() override;
  explicit constexpr CommandPartitionedTopicMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandPartitionedTopicMetadataResponse(const CommandPartitionedTopicMetadataResponse& from);
  CommandPartitionedTopicMetadataResponse(CommandPartitionedTopicMetadataResponse&& from) noexcept
    : CommandPartitionedTopicMetadataResponse() {
    *this = ::std::move(from);
  }

  inline CommandPartitionedTopicMetadataResponse& operator=(const CommandPartitionedTopicMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPartitionedTopicMetadataResponse& operator=(CommandPartitionedTopicMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandPartitionedTopicMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandPartitionedTopicMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const CommandPartitionedTopicMetadataResponse*>(
               &_CommandPartitionedTopicMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CommandPartitionedTopicMetadataResponse& a, CommandPartitionedTopicMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPartitionedTopicMetadataResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPartitionedTopicMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandPartitionedTopicMetadataResponse* New() const final {
    return new CommandPartitionedTopicMetadataResponse();
  }

  CommandPartitionedTopicMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandPartitionedTopicMetadataResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandPartitionedTopicMetadataResponse& from);
  void MergeFrom(const CommandPartitionedTopicMetadataResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandPartitionedTopicMetadataResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandPartitionedTopicMetadataResponse";
  }
  protected:
  explicit CommandPartitionedTopicMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CommandPartitionedTopicMetadataResponse_LookupType LookupType;
  static constexpr LookupType Success =
    CommandPartitionedTopicMetadataResponse_LookupType_Success;
  static constexpr LookupType Failed =
    CommandPartitionedTopicMetadataResponse_LookupType_Failed;
  static inline bool LookupType_IsValid(int value) {
    return CommandPartitionedTopicMetadataResponse_LookupType_IsValid(value);
  }
  static constexpr LookupType LookupType_MIN =
    CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MIN;
  static constexpr LookupType LookupType_MAX =
    CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MAX;
  static constexpr int LookupType_ARRAYSIZE =
    CommandPartitionedTopicMetadataResponse_LookupType_LookupType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LookupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LookupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LookupType_Name.");
    return CommandPartitionedTopicMetadataResponse_LookupType_Name(enum_t_value);
  }
  static inline bool LookupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LookupType* value) {
    return CommandPartitionedTopicMetadataResponse_LookupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 2,
    kPartitionsFieldNumber = 1,
    kResponseFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 partitions = 1;
  bool has_partitions() const;
  private:
  bool _internal_has_partitions() const;
  public:
  void clear_partitions();
  ::PROTOBUF_NAMESPACE_ID::uint32 partitions() const;
  void set_partitions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_partitions() const;
  void _internal_set_partitions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType response() const;
  void set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value);
  private:
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType _internal_response() const;
  void _internal_set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value);
  public:

  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPartitionedTopicMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 partitions_;
  int response_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandLookupTopic final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandLookupTopic) */ {
 public:
  inline CommandLookupTopic() : CommandLookupTopic(nullptr) {}
  ~CommandLookupTopic() override;
  explicit constexpr CommandLookupTopic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandLookupTopic(const CommandLookupTopic& from);
  CommandLookupTopic(CommandLookupTopic&& from) noexcept
    : CommandLookupTopic() {
    *this = ::std::move(from);
  }

  inline CommandLookupTopic& operator=(const CommandLookupTopic& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandLookupTopic& operator=(CommandLookupTopic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandLookupTopic& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandLookupTopic* internal_default_instance() {
    return reinterpret_cast<const CommandLookupTopic*>(
               &_CommandLookupTopic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CommandLookupTopic& a, CommandLookupTopic& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandLookupTopic* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandLookupTopic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandLookupTopic* New() const final {
    return new CommandLookupTopic();
  }

  CommandLookupTopic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandLookupTopic>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandLookupTopic& from);
  void MergeFrom(const CommandLookupTopic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandLookupTopic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandLookupTopic";
  }
  protected:
  explicit CommandLookupTopic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kOriginalPrincipalFieldNumber = 4,
    kOriginalAuthDataFieldNumber = 5,
    kOriginalAuthMethodFieldNumber = 6,
    kAdvertisedListenerNameFieldNumber = 7,
    kRequestIdFieldNumber = 2,
    kAuthoritativeFieldNumber = 3,
  };
  // required string topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // optional string original_principal = 4;
  bool has_original_principal() const;
  private:
  bool _internal_has_original_principal() const;
  public:
  void clear_original_principal();
  const std::string& original_principal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_principal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_principal();
  PROTOBUF_MUST_USE_RESULT std::string* release_original_principal();
  void set_allocated_original_principal(std::string* original_principal);
  private:
  const std::string& _internal_original_principal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_principal(const std::string& value);
  std::string* _internal_mutable_original_principal();
  public:

  // optional string original_auth_data = 5;
  bool has_original_auth_data() const;
  private:
  bool _internal_has_original_auth_data() const;
  public:
  void clear_original_auth_data();
  const std::string& original_auth_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_auth_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_auth_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_original_auth_data();
  void set_allocated_original_auth_data(std::string* original_auth_data);
  private:
  const std::string& _internal_original_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_data(const std::string& value);
  std::string* _internal_mutable_original_auth_data();
  public:

  // optional string original_auth_method = 6;
  bool has_original_auth_method() const;
  private:
  bool _internal_has_original_auth_method() const;
  public:
  void clear_original_auth_method();
  const std::string& original_auth_method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_auth_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_auth_method();
  PROTOBUF_MUST_USE_RESULT std::string* release_original_auth_method();
  void set_allocated_original_auth_method(std::string* original_auth_method);
  private:
  const std::string& _internal_original_auth_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_method(const std::string& value);
  std::string* _internal_mutable_original_auth_method();
  public:

  // optional string advertised_listener_name = 7;
  bool has_advertised_listener_name() const;
  private:
  bool _internal_has_advertised_listener_name() const;
  public:
  void clear_advertised_listener_name();
  const std::string& advertised_listener_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_advertised_listener_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_advertised_listener_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_advertised_listener_name();
  void set_allocated_advertised_listener_name(std::string* advertised_listener_name);
  private:
  const std::string& _internal_advertised_listener_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_advertised_listener_name(const std::string& value);
  std::string* _internal_mutable_advertised_listener_name();
  public:

  // required uint64 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool authoritative = 3 [default = false];
  bool has_authoritative() const;
  private:
  bool _internal_has_authoritative() const;
  public:
  void clear_authoritative();
  bool authoritative() const;
  void set_authoritative(bool value);
  private:
  bool _internal_authoritative() const;
  void _internal_set_authoritative(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandLookupTopic)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_principal_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_auth_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_auth_method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr advertised_listener_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  bool authoritative_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandLookupTopicResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandLookupTopicResponse) */ {
 public:
  inline CommandLookupTopicResponse() : CommandLookupTopicResponse(nullptr) {}
  ~CommandLookupTopicResponse() override;
  explicit constexpr CommandLookupTopicResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandLookupTopicResponse(const CommandLookupTopicResponse& from);
  CommandLookupTopicResponse(CommandLookupTopicResponse&& from) noexcept
    : CommandLookupTopicResponse() {
    *this = ::std::move(from);
  }

  inline CommandLookupTopicResponse& operator=(const CommandLookupTopicResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandLookupTopicResponse& operator=(CommandLookupTopicResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandLookupTopicResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandLookupTopicResponse* internal_default_instance() {
    return reinterpret_cast<const CommandLookupTopicResponse*>(
               &_CommandLookupTopicResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CommandLookupTopicResponse& a, CommandLookupTopicResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandLookupTopicResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandLookupTopicResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandLookupTopicResponse* New() const final {
    return new CommandLookupTopicResponse();
  }

  CommandLookupTopicResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandLookupTopicResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandLookupTopicResponse& from);
  void MergeFrom(const CommandLookupTopicResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandLookupTopicResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandLookupTopicResponse";
  }
  protected:
  explicit CommandLookupTopicResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CommandLookupTopicResponse_LookupType LookupType;
  static constexpr LookupType Redirect =
    CommandLookupTopicResponse_LookupType_Redirect;
  static constexpr LookupType Connect =
    CommandLookupTopicResponse_LookupType_Connect;
  static constexpr LookupType Failed =
    CommandLookupTopicResponse_LookupType_Failed;
  static inline bool LookupType_IsValid(int value) {
    return CommandLookupTopicResponse_LookupType_IsValid(value);
  }
  static constexpr LookupType LookupType_MIN =
    CommandLookupTopicResponse_LookupType_LookupType_MIN;
  static constexpr LookupType LookupType_MAX =
    CommandLookupTopicResponse_LookupType_LookupType_MAX;
  static constexpr int LookupType_ARRAYSIZE =
    CommandLookupTopicResponse_LookupType_LookupType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LookupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LookupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LookupType_Name.");
    return CommandLookupTopicResponse_LookupType_Name(enum_t_value);
  }
  static inline bool LookupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LookupType* value) {
    return CommandLookupTopicResponse_LookupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBrokerServiceUrlFieldNumber = 1,
    kBrokerServiceUrlTlsFieldNumber = 2,
    kMessageFieldNumber = 7,
    kRequestIdFieldNumber = 4,
    kResponseFieldNumber = 3,
    kErrorFieldNumber = 6,
    kAuthoritativeFieldNumber = 5,
    kProxyThroughServiceUrlFieldNumber = 8,
  };
  // optional string brokerServiceUrl = 1;
  bool has_brokerserviceurl() const;
  private:
  bool _internal_has_brokerserviceurl() const;
  public:
  void clear_brokerserviceurl();
  const std::string& brokerserviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brokerserviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brokerserviceurl();
  PROTOBUF_MUST_USE_RESULT std::string* release_brokerserviceurl();
  void set_allocated_brokerserviceurl(std::string* brokerserviceurl);
  private:
  const std::string& _internal_brokerserviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brokerserviceurl(const std::string& value);
  std::string* _internal_mutable_brokerserviceurl();
  public:

  // optional string brokerServiceUrlTls = 2;
  bool has_brokerserviceurltls() const;
  private:
  bool _internal_has_brokerserviceurltls() const;
  public:
  void clear_brokerserviceurltls();
  const std::string& brokerserviceurltls() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brokerserviceurltls(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brokerserviceurltls();
  PROTOBUF_MUST_USE_RESULT std::string* release_brokerserviceurltls();
  void set_allocated_brokerserviceurltls(std::string* brokerserviceurltls);
  private:
  const std::string& _internal_brokerserviceurltls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brokerserviceurltls(const std::string& value);
  std::string* _internal_mutable_brokerserviceurltls();
  public:

  // optional string message = 7;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 4;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::pulsar::proto::CommandLookupTopicResponse_LookupType response() const;
  void set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value);
  private:
  ::pulsar::proto::CommandLookupTopicResponse_LookupType _internal_response() const;
  void _internal_set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value);
  public:

  // optional .pulsar.proto.ServerError error = 6;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // optional bool authoritative = 5 [default = false];
  bool has_authoritative() const;
  private:
  bool _internal_has_authoritative() const;
  public:
  void clear_authoritative();
  bool authoritative() const;
  void set_authoritative(bool value);
  private:
  bool _internal_authoritative() const;
  void _internal_set_authoritative(bool value);
  public:

  // optional bool proxy_through_service_url = 8 [default = false];
  bool has_proxy_through_service_url() const;
  private:
  bool _internal_has_proxy_through_service_url() const;
  public:
  void clear_proxy_through_service_url();
  bool proxy_through_service_url() const;
  void set_proxy_through_service_url(bool value);
  private:
  bool _internal_proxy_through_service_url() const;
  void _internal_set_proxy_through_service_url(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandLookupTopicResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brokerserviceurl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brokerserviceurltls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  int response_;
  int error_;
  bool authoritative_;
  bool proxy_through_service_url_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandProducer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandProducer) */ {
 public:
  inline CommandProducer() : CommandProducer(nullptr) {}
  ~CommandProducer() override;
  explicit constexpr CommandProducer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandProducer(const CommandProducer& from);
  CommandProducer(CommandProducer&& from) noexcept
    : CommandProducer() {
    *this = ::std::move(from);
  }

  inline CommandProducer& operator=(const CommandProducer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandProducer& operator=(CommandProducer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandProducer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandProducer* internal_default_instance() {
    return reinterpret_cast<const CommandProducer*>(
               &_CommandProducer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CommandProducer& a, CommandProducer& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandProducer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandProducer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandProducer* New() const final {
    return new CommandProducer();
  }

  CommandProducer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandProducer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandProducer& from);
  void MergeFrom(const CommandProducer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandProducer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandProducer";
  }
  protected:
  explicit CommandProducer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 6,
    kTopicFieldNumber = 1,
    kProducerNameFieldNumber = 4,
    kInitialSubscriptionNameFieldNumber = 13,
    kSchemaFieldNumber = 7,
    kProducerIdFieldNumber = 2,
    kRequestIdFieldNumber = 3,
    kEpochFieldNumber = 8,
    kEncryptedFieldNumber = 5,
    kTxnEnabledFieldNumber = 12,
    kProducerAccessModeFieldNumber = 10,
    kTopicEpochFieldNumber = 11,
    kUserProvidedProducerNameFieldNumber = 9,
  };
  // repeated .pulsar.proto.KeyValue metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::pulsar::proto::KeyValue* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_metadata();
  private:
  const ::pulsar::proto::KeyValue& _internal_metadata(int index) const;
  ::pulsar::proto::KeyValue* _internal_add_metadata();
  public:
  const ::pulsar::proto::KeyValue& metadata(int index) const;
  ::pulsar::proto::KeyValue* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      metadata() const;

  // required string topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // optional string producer_name = 4;
  bool has_producer_name() const;
  private:
  bool _internal_has_producer_name() const;
  public:
  void clear_producer_name();
  const std::string& producer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_producer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_producer_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_producer_name();
  void set_allocated_producer_name(std::string* producer_name);
  private:
  const std::string& _internal_producer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_name(const std::string& value);
  std::string* _internal_mutable_producer_name();
  public:

  // optional string initial_subscription_name = 13;
  bool has_initial_subscription_name() const;
  private:
  bool _internal_has_initial_subscription_name() const;
  public:
  void clear_initial_subscription_name();
  const std::string& initial_subscription_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial_subscription_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial_subscription_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_initial_subscription_name();
  void set_allocated_initial_subscription_name(std::string* initial_subscription_name);
  private:
  const std::string& _internal_initial_subscription_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_subscription_name(const std::string& value);
  std::string* _internal_mutable_initial_subscription_name();
  public:

  // optional .pulsar.proto.Schema schema = 7;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* schema);
  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::pulsar::proto::Schema* schema);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  // required uint64 producer_id = 2;
  bool has_producer_id() const;
  private:
  bool _internal_has_producer_id() const;
  public:
  void clear_producer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id() const;
  void set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_producer_id() const;
  void _internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 request_id = 3;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 epoch = 8 [default = 0];
  bool has_epoch() const;
  private:
  bool _internal_has_epoch() const;
  public:
  void clear_epoch();
  ::PROTOBUF_NAMESPACE_ID::uint64 epoch() const;
  void set_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_epoch() const;
  void _internal_set_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool encrypted = 5 [default = false];
  bool has_encrypted() const;
  private:
  bool _internal_has_encrypted() const;
  public:
  void clear_encrypted();
  bool encrypted() const;
  void set_encrypted(bool value);
  private:
  bool _internal_encrypted() const;
  void _internal_set_encrypted(bool value);
  public:

  // optional bool txn_enabled = 12 [default = false];
  bool has_txn_enabled() const;
  private:
  bool _internal_has_txn_enabled() const;
  public:
  void clear_txn_enabled();
  bool txn_enabled() const;
  void set_txn_enabled(bool value);
  private:
  bool _internal_txn_enabled() const;
  void _internal_set_txn_enabled(bool value);
  public:

  // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
  bool has_producer_access_mode() const;
  private:
  bool _internal_has_producer_access_mode() const;
  public:
  void clear_producer_access_mode();
  ::pulsar::proto::ProducerAccessMode producer_access_mode() const;
  void set_producer_access_mode(::pulsar::proto::ProducerAccessMode value);
  private:
  ::pulsar::proto::ProducerAccessMode _internal_producer_access_mode() const;
  void _internal_set_producer_access_mode(::pulsar::proto::ProducerAccessMode value);
  public:

  // optional uint64 topic_epoch = 11;
  bool has_topic_epoch() const;
  private:
  bool _internal_has_topic_epoch() const;
  public:
  void clear_topic_epoch();
  ::PROTOBUF_NAMESPACE_ID::uint64 topic_epoch() const;
  void set_topic_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_topic_epoch() const;
  void _internal_set_topic_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool user_provided_producer_name = 9 [default = true];
  bool has_user_provided_producer_name() const;
  private:
  bool _internal_has_user_provided_producer_name() const;
  public:
  void clear_user_provided_producer_name();
  bool user_provided_producer_name() const;
  void set_user_provided_producer_name(bool value);
  private:
  bool _internal_user_provided_producer_name() const;
  void _internal_set_user_provided_producer_name(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandProducer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue > metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr producer_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_subscription_name_;
  ::pulsar::proto::Schema* schema_;
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 epoch_;
  bool encrypted_;
  bool txn_enabled_;
  int producer_access_mode_;
  ::PROTOBUF_NAMESPACE_ID::uint64 topic_epoch_;
  bool user_provided_producer_name_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandSend final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSend) */ {
 public:
  inline CommandSend() : CommandSend(nullptr) {}
  ~CommandSend() override;
  explicit constexpr CommandSend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandSend(const CommandSend& from);
  CommandSend(CommandSend&& from) noexcept
    : CommandSend() {
    *this = ::std::move(from);
  }

  inline CommandSend& operator=(const CommandSend& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSend& operator=(CommandSend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSend& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSend* internal_default_instance() {
    return reinterpret_cast<const CommandSend*>(
               &_CommandSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CommandSend& a, CommandSend& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSend* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandSend* New() const final {
    return new CommandSend();
  }

  CommandSend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandSend>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandSend& from);
  void MergeFrom(const CommandSend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandSend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandSend";
  }
  protected:
  explicit CommandSend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 9,
    kProducerIdFieldNumber = 1,
    kSequenceIdFieldNumber = 2,
    kTxnidLeastBitsFieldNumber = 4,
    kTxnidMostBitsFieldNumber = 5,
    kHighestSequenceIdFieldNumber = 6,
    kIsChunkFieldNumber = 7,
    kMarkerFieldNumber = 8,
    kNumMessagesFieldNumber = 3,
  };
  // optional .pulsar.proto.MessageIdData message_id = 9;
  bool has_message_id() const;
  private:
  bool _internal_has_message_id() const;
  public:
  void clear_message_id();
  const ::pulsar::proto::MessageIdData& message_id() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::MessageIdData* release_message_id();
  ::pulsar::proto::MessageIdData* mutable_message_id();
  void set_allocated_message_id(::pulsar::proto::MessageIdData* message_id);
  private:
  const ::pulsar::proto::MessageIdData& _internal_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_message_id();
  public:
  void unsafe_arena_set_allocated_message_id(
      ::pulsar::proto::MessageIdData* message_id);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_message_id();

  // required uint64 producer_id = 1;
  bool has_producer_id() const;
  private:
  bool _internal_has_producer_id() const;
  public:
  void clear_producer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id() const;
  void set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_producer_id() const;
  void _internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 sequence_id = 2;
  bool has_sequence_id() const;
  private:
  bool _internal_has_sequence_id() const;
  public:
  void clear_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id() const;
  void set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence_id() const;
  void _internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 4 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 5 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 highest_sequence_id = 6 [default = 0];
  bool has_highest_sequence_id() const;
  private:
  bool _internal_has_highest_sequence_id() const;
  public:
  void clear_highest_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 highest_sequence_id() const;
  void set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_highest_sequence_id() const;
  void _internal_set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool is_chunk = 7 [default = false];
  bool has_is_chunk() const;
  private:
  bool _internal_has_is_chunk() const;
  public:
  void clear_is_chunk();
  bool is_chunk() const;
  void set_is_chunk(bool value);
  private:
  bool _internal_is_chunk() const;
  void _internal_set_is_chunk(bool value);
  public:

  // optional bool marker = 8 [default = false];
  bool has_marker() const;
  private:
  bool _internal_has_marker() const;
  public:
  void clear_marker();
  bool marker() const;
  void set_marker(bool value);
  private:
  bool _internal_marker() const;
  void _internal_set_marker(bool value);
  public:

  // optional int32 num_messages = 3 [default = 1];
  bool has_num_messages() const;
  private:
  bool _internal_has_num_messages() const;
  public:
  void clear_num_messages();
  ::PROTOBUF_NAMESPACE_ID::int32 num_messages() const;
  void set_num_messages(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_messages() const;
  void _internal_set_num_messages(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSend)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pulsar::proto::MessageIdData* message_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 highest_sequence_id_;
  bool is_chunk_;
  bool marker_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_messages_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandSendReceipt final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSendReceipt) */ {
 public:
  inline CommandSendReceipt() : CommandSendReceipt(nullptr) {}
  ~CommandSendReceipt() override;
  explicit constexpr CommandSendReceipt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandSendReceipt(const CommandSendReceipt& from);
  CommandSendReceipt(CommandSendReceipt&& from) noexcept
    : CommandSendReceipt() {
    *this = ::std::move(from);
  }

  inline CommandSendReceipt& operator=(const CommandSendReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSendReceipt& operator=(CommandSendReceipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSendReceipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSendReceipt* internal_default_instance() {
    return reinterpret_cast<const CommandSendReceipt*>(
               &_CommandSendReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CommandSendReceipt& a, CommandSendReceipt& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSendReceipt* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSendReceipt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandSendReceipt* New() const final {
    return new CommandSendReceipt();
  }

  CommandSendReceipt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandSendReceipt>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandSendReceipt& from);
  void MergeFrom(const CommandSendReceipt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandSendReceipt* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandSendReceipt";
  }
  protected:
  explicit CommandSendReceipt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 3,
    kProducerIdFieldNumber = 1,
    kSequenceIdFieldNumber = 2,
    kHighestSequenceIdFieldNumber = 4,
  };
  // optional .pulsar.proto.MessageIdData message_id = 3;
  bool has_message_id() const;
  private:
  bool _internal_has_message_id() const;
  public:
  void clear_message_id();
  const ::pulsar::proto::MessageIdData& message_id() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::MessageIdData* release_message_id();
  ::pulsar::proto::MessageIdData* mutable_message_id();
  void set_allocated_message_id(::pulsar::proto::MessageIdData* message_id);
  private:
  const ::pulsar::proto::MessageIdData& _internal_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_message_id();
  public:
  void unsafe_arena_set_allocated_message_id(
      ::pulsar::proto::MessageIdData* message_id);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_message_id();

  // required uint64 producer_id = 1;
  bool has_producer_id() const;
  private:
  bool _internal_has_producer_id() const;
  public:
  void clear_producer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id() const;
  void set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_producer_id() const;
  void _internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 sequence_id = 2;
  bool has_sequence_id() const;
  private:
  bool _internal_has_sequence_id() const;
  public:
  void clear_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id() const;
  void set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence_id() const;
  void _internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 highest_sequence_id = 4 [default = 0];
  bool has_highest_sequence_id() const;
  private:
  bool _internal_has_highest_sequence_id() const;
  public:
  void clear_highest_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 highest_sequence_id() const;
  void set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_highest_sequence_id() const;
  void _internal_set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSendReceipt)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pulsar::proto::MessageIdData* message_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 highest_sequence_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandSendError final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSendError) */ {
 public:
  inline CommandSendError() : CommandSendError(nullptr) {}
  ~CommandSendError() override;
  explicit constexpr CommandSendError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandSendError(const CommandSendError& from);
  CommandSendError(CommandSendError&& from) noexcept
    : CommandSendError() {
    *this = ::std::move(from);
  }

  inline CommandSendError& operator=(const CommandSendError& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSendError& operator=(CommandSendError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSendError& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSendError* internal_default_instance() {
    return reinterpret_cast<const CommandSendError*>(
               &_CommandSendError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CommandSendError& a, CommandSendError& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSendError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSendError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandSendError* New() const final {
    return new CommandSendError();
  }

  CommandSendError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandSendError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandSendError& from);
  void MergeFrom(const CommandSendError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandSendError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandSendError";
  }
  protected:
  explicit CommandSendError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 4,
    kProducerIdFieldNumber = 1,
    kSequenceIdFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // required string message = 4;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 producer_id = 1;
  bool has_producer_id() const;
  private:
  bool _internal_has_producer_id() const;
  public:
  void clear_producer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id() const;
  void set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_producer_id() const;
  void _internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 sequence_id = 2;
  bool has_sequence_id() const;
  private:
  bool _internal_has_sequence_id() const;
  public:
  void clear_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id() const;
  void set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence_id() const;
  void _internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .pulsar.proto.ServerError error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSendError)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandMessage) */ {
 public:
  inline CommandMessage() : CommandMessage(nullptr) {}
  ~CommandMessage() override;
  explicit constexpr CommandMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandMessage(const CommandMessage& from);
  CommandMessage(CommandMessage&& from) noexcept
    : CommandMessage() {
    *this = ::std::move(from);
  }

  inline CommandMessage& operator=(const CommandMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandMessage& operator=(CommandMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandMessage* internal_default_instance() {
    return reinterpret_cast<const CommandMessage*>(
               &_CommandMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CommandMessage& a, CommandMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandMessage* New() const final {
    return new CommandMessage();
  }

  CommandMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandMessage& from);
  void MergeFrom(const CommandMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandMessage";
  }
  protected:
  explicit CommandMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckSetFieldNumber = 4,
    kMessageIdFieldNumber = 2,
    kConsumerIdFieldNumber = 1,
    kConsumerEpochFieldNumber = 5,
    kRedeliveryCountFieldNumber = 3,
  };
  // repeated int64 ack_set = 4;
  int ack_set_size() const;
  private:
  int _internal_ack_set_size() const;
  public:
  void clear_ack_set();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ack_set(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_ack_set() const;
  void _internal_add_ack_set(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_ack_set();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 ack_set(int index) const;
  void set_ack_set(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_ack_set(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      ack_set() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_ack_set();

  // required .pulsar.proto.MessageIdData message_id = 2;
  bool has_message_id() const;
  private:
  bool _internal_has_message_id() const;
  public:
  void clear_message_id();
  const ::pulsar::proto::MessageIdData& message_id() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::MessageIdData* release_message_id();
  ::pulsar::proto::MessageIdData* mutable_message_id();
  void set_allocated_message_id(::pulsar::proto::MessageIdData* message_id);
  private:
  const ::pulsar::proto::MessageIdData& _internal_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_message_id();
  public:
  void unsafe_arena_set_allocated_message_id(
      ::pulsar::proto::MessageIdData* message_id);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_message_id();

  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 consumer_epoch = 5;
  bool has_consumer_epoch() const;
  private:
  bool _internal_has_consumer_epoch() const;
  public:
  void clear_consumer_epoch();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_epoch() const;
  void set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_epoch() const;
  void _internal_set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 redelivery_count = 3 [default = 0];
  bool has_redelivery_count() const;
  private:
  bool _internal_has_redelivery_count() const;
  public:
  void clear_redelivery_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 redelivery_count() const;
  void set_redelivery_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_redelivery_count() const;
  void _internal_set_redelivery_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > ack_set_;
  ::pulsar::proto::MessageIdData* message_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_epoch_;
  ::PROTOBUF_NAMESPACE_ID::uint32 redelivery_count_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandAck final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAck) */ {
 public:
  inline CommandAck() : CommandAck(nullptr) {}
  ~CommandAck() override;
  explicit constexpr CommandAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandAck(const CommandAck& from);
  CommandAck(CommandAck&& from) noexcept
    : CommandAck() {
    *this = ::std::move(from);
  }

  inline CommandAck& operator=(const CommandAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAck& operator=(CommandAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAck* internal_default_instance() {
    return reinterpret_cast<const CommandAck*>(
               &_CommandAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CommandAck& a, CommandAck& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAck* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandAck* New() const final {
    return new CommandAck();
  }

  CommandAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandAck& from);
  void MergeFrom(const CommandAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandAck";
  }
  protected:
  explicit CommandAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CommandAck_AckType AckType;
  static constexpr AckType Individual =
    CommandAck_AckType_Individual;
  static constexpr AckType Cumulative =
    CommandAck_AckType_Cumulative;
  static inline bool AckType_IsValid(int value) {
    return CommandAck_AckType_IsValid(value);
  }
  static constexpr AckType AckType_MIN =
    CommandAck_AckType_AckType_MIN;
  static constexpr AckType AckType_MAX =
    CommandAck_AckType_AckType_MAX;
  static constexpr int AckType_ARRAYSIZE =
    CommandAck_AckType_AckType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AckType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AckType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AckType_Name.");
    return CommandAck_AckType_Name(enum_t_value);
  }
  static inline bool AckType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AckType* value) {
    return CommandAck_AckType_Parse(name, value);
  }

  typedef CommandAck_ValidationError ValidationError;
  static constexpr ValidationError UncompressedSizeCorruption =
    CommandAck_ValidationError_UncompressedSizeCorruption;
  static constexpr ValidationError DecompressionError =
    CommandAck_ValidationError_DecompressionError;
  static constexpr ValidationError ChecksumMismatch =
    CommandAck_ValidationError_ChecksumMismatch;
  static constexpr ValidationError BatchDeSerializeError =
    CommandAck_ValidationError_BatchDeSerializeError;
  static constexpr ValidationError DecryptionError =
    CommandAck_ValidationError_DecryptionError;
  static inline bool ValidationError_IsValid(int value) {
    return CommandAck_ValidationError_IsValid(value);
  }
  static constexpr ValidationError ValidationError_MIN =
    CommandAck_ValidationError_ValidationError_MIN;
  static constexpr ValidationError ValidationError_MAX =
    CommandAck_ValidationError_ValidationError_MAX;
  static constexpr int ValidationError_ARRAYSIZE =
    CommandAck_ValidationError_ValidationError_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ValidationError_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ValidationError>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ValidationError_Name.");
    return CommandAck_ValidationError_Name(enum_t_value);
  }
  static inline bool ValidationError_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ValidationError* value) {
    return CommandAck_ValidationError_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 3,
    kPropertiesFieldNumber = 5,
    kConsumerIdFieldNumber = 1,
    kAckTypeFieldNumber = 2,
    kValidationErrorFieldNumber = 4,
    kTxnidLeastBitsFieldNumber = 6,
    kTxnidMostBitsFieldNumber = 7,
    kRequestIdFieldNumber = 8,
  };
  // repeated .pulsar.proto.MessageIdData message_id = 3;
  int message_id_size() const;
  private:
  int _internal_message_id_size() const;
  public:
  void clear_message_id();
  ::pulsar::proto::MessageIdData* mutable_message_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
      mutable_message_id();
  private:
  const ::pulsar::proto::MessageIdData& _internal_message_id(int index) const;
  ::pulsar::proto::MessageIdData* _internal_add_message_id();
  public:
  const ::pulsar::proto::MessageIdData& message_id(int index) const;
  ::pulsar::proto::MessageIdData* add_message_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
      message_id() const;

  // repeated .pulsar.proto.KeyLongValue properties = 5;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::pulsar::proto::KeyLongValue* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyLongValue >*
      mutable_properties();
  private:
  const ::pulsar::proto::KeyLongValue& _internal_properties(int index) const;
  ::pulsar::proto::KeyLongValue* _internal_add_properties();
  public:
  const ::pulsar::proto::KeyLongValue& properties(int index) const;
  ::pulsar::proto::KeyLongValue* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyLongValue >&
      properties() const;

  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .pulsar.proto.CommandAck.AckType ack_type = 2;
  bool has_ack_type() const;
  private:
  bool _internal_has_ack_type() const;
  public:
  void clear_ack_type();
  ::pulsar::proto::CommandAck_AckType ack_type() const;
  void set_ack_type(::pulsar::proto::CommandAck_AckType value);
  private:
  ::pulsar::proto::CommandAck_AckType _internal_ack_type() const;
  void _internal_set_ack_type(::pulsar::proto::CommandAck_AckType value);
  public:

  // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
  bool has_validation_error() const;
  private:
  bool _internal_has_validation_error() const;
  public:
  void clear_validation_error();
  ::pulsar::proto::CommandAck_ValidationError validation_error() const;
  void set_validation_error(::pulsar::proto::CommandAck_ValidationError value);
  private:
  ::pulsar::proto::CommandAck_ValidationError _internal_validation_error() const;
  void _internal_set_validation_error(::pulsar::proto::CommandAck_ValidationError value);
  public:

  // optional uint64 txnid_least_bits = 6 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 7 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 request_id = 8;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAck)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData > message_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyLongValue > properties_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  int ack_type_;
  int validation_error_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandAckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAckResponse) */ {
 public:
  inline CommandAckResponse() : CommandAckResponse(nullptr) {}
  ~CommandAckResponse() override;
  explicit constexpr CommandAckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandAckResponse(const CommandAckResponse& from);
  CommandAckResponse(CommandAckResponse&& from) noexcept
    : CommandAckResponse() {
    *this = ::std::move(from);
  }

  inline CommandAckResponse& operator=(const CommandAckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAckResponse& operator=(CommandAckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAckResponse* internal_default_instance() {
    return reinterpret_cast<const CommandAckResponse*>(
               &_CommandAckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CommandAckResponse& a, CommandAckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAckResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandAckResponse* New() const final {
    return new CommandAckResponse();
  }

  CommandAckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandAckResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandAckResponse& from);
  void MergeFrom(const CommandAckResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandAckResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandAckResponse";
  }
  protected:
  explicit CommandAckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kConsumerIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kRequestIdFieldNumber = 6,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 request_id = 6;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandActiveConsumerChange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandActiveConsumerChange) */ {
 public:
  inline CommandActiveConsumerChange() : CommandActiveConsumerChange(nullptr) {}
  ~CommandActiveConsumerChange() override;
  explicit constexpr CommandActiveConsumerChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandActiveConsumerChange(const CommandActiveConsumerChange& from);
  CommandActiveConsumerChange(CommandActiveConsumerChange&& from) noexcept
    : CommandActiveConsumerChange() {
    *this = ::std::move(from);
  }

  inline CommandActiveConsumerChange& operator=(const CommandActiveConsumerChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandActiveConsumerChange& operator=(CommandActiveConsumerChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandActiveConsumerChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandActiveConsumerChange* internal_default_instance() {
    return reinterpret_cast<const CommandActiveConsumerChange*>(
               &_CommandActiveConsumerChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CommandActiveConsumerChange& a, CommandActiveConsumerChange& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandActiveConsumerChange* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandActiveConsumerChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandActiveConsumerChange* New() const final {
    return new CommandActiveConsumerChange();
  }

  CommandActiveConsumerChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandActiveConsumerChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandActiveConsumerChange& from);
  void MergeFrom(const CommandActiveConsumerChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandActiveConsumerChange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandActiveConsumerChange";
  }
  protected:
  explicit CommandActiveConsumerChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
    kIsActiveFieldNumber = 2,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool is_active = 2 [default = false];
  bool has_is_active() const;
  private:
  bool _internal_has_is_active() const;
  public:
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandActiveConsumerChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  bool is_active_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandFlow final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandFlow) */ {
 public:
  inline CommandFlow() : CommandFlow(nullptr) {}
  ~CommandFlow() override;
  explicit constexpr CommandFlow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandFlow(const CommandFlow& from);
  CommandFlow(CommandFlow&& from) noexcept
    : CommandFlow() {
    *this = ::std::move(from);
  }

  inline CommandFlow& operator=(const CommandFlow& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandFlow& operator=(CommandFlow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandFlow& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandFlow* internal_default_instance() {
    return reinterpret_cast<const CommandFlow*>(
               &_CommandFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CommandFlow& a, CommandFlow& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandFlow* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandFlow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandFlow* New() const final {
    return new CommandFlow();
  }

  CommandFlow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandFlow>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandFlow& from);
  void MergeFrom(const CommandFlow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandFlow* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandFlow";
  }
  protected:
  explicit CommandFlow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
    kMessagePermitsFieldNumber = 2,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint32 messagePermits = 2;
  bool has_messagepermits() const;
  private:
  bool _internal_has_messagepermits() const;
  public:
  void clear_messagepermits();
  ::PROTOBUF_NAMESPACE_ID::uint32 messagepermits() const;
  void set_messagepermits(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_messagepermits() const;
  void _internal_set_messagepermits(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandFlow)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 messagepermits_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandUnsubscribe final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandUnsubscribe) */ {
 public:
  inline CommandUnsubscribe() : CommandUnsubscribe(nullptr) {}
  ~CommandUnsubscribe() override;
  explicit constexpr CommandUnsubscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandUnsubscribe(const CommandUnsubscribe& from);
  CommandUnsubscribe(CommandUnsubscribe&& from) noexcept
    : CommandUnsubscribe() {
    *this = ::std::move(from);
  }

  inline CommandUnsubscribe& operator=(const CommandUnsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandUnsubscribe& operator=(CommandUnsubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandUnsubscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandUnsubscribe* internal_default_instance() {
    return reinterpret_cast<const CommandUnsubscribe*>(
               &_CommandUnsubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CommandUnsubscribe& a, CommandUnsubscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandUnsubscribe* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandUnsubscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandUnsubscribe* New() const final {
    return new CommandUnsubscribe();
  }

  CommandUnsubscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandUnsubscribe>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandUnsubscribe& from);
  void MergeFrom(const CommandUnsubscribe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandUnsubscribe* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandUnsubscribe";
  }
  protected:
  explicit CommandUnsubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandUnsubscribe)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandSeek final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSeek) */ {
 public:
  inline CommandSeek() : CommandSeek(nullptr) {}
  ~CommandSeek() override;
  explicit constexpr CommandSeek(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandSeek(const CommandSeek& from);
  CommandSeek(CommandSeek&& from) noexcept
    : CommandSeek() {
    *this = ::std::move(from);
  }

  inline CommandSeek& operator=(const CommandSeek& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSeek& operator=(CommandSeek&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSeek& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSeek* internal_default_instance() {
    return reinterpret_cast<const CommandSeek*>(
               &_CommandSeek_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CommandSeek& a, CommandSeek& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSeek* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSeek* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandSeek* New() const final {
    return new CommandSeek();
  }

  CommandSeek* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandSeek>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandSeek& from);
  void MergeFrom(const CommandSeek& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandSeek* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandSeek";
  }
  protected:
  explicit CommandSeek(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 3,
    kConsumerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kMessagePublishTimeFieldNumber = 4,
  };
  // optional .pulsar.proto.MessageIdData message_id = 3;
  bool has_message_id() const;
  private:
  bool _internal_has_message_id() const;
  public:
  void clear_message_id();
  const ::pulsar::proto::MessageIdData& message_id() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::MessageIdData* release_message_id();
  ::pulsar::proto::MessageIdData* mutable_message_id();
  void set_allocated_message_id(::pulsar::proto::MessageIdData* message_id);
  private:
  const ::pulsar::proto::MessageIdData& _internal_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_message_id();
  public:
  void unsafe_arena_set_allocated_message_id(
      ::pulsar::proto::MessageIdData* message_id);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_message_id();

  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 message_publish_time = 4;
  bool has_message_publish_time() const;
  private:
  bool _internal_has_message_publish_time() const;
  public:
  void clear_message_publish_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 message_publish_time() const;
  void set_message_publish_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_message_publish_time() const;
  void _internal_set_message_publish_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSeek)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pulsar::proto::MessageIdData* message_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 message_publish_time_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandReachedEndOfTopic final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandReachedEndOfTopic) */ {
 public:
  inline CommandReachedEndOfTopic() : CommandReachedEndOfTopic(nullptr) {}
  ~CommandReachedEndOfTopic() override;
  explicit constexpr CommandReachedEndOfTopic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandReachedEndOfTopic(const CommandReachedEndOfTopic& from);
  CommandReachedEndOfTopic(CommandReachedEndOfTopic&& from) noexcept
    : CommandReachedEndOfTopic() {
    *this = ::std::move(from);
  }

  inline CommandReachedEndOfTopic& operator=(const CommandReachedEndOfTopic& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandReachedEndOfTopic& operator=(CommandReachedEndOfTopic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandReachedEndOfTopic& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandReachedEndOfTopic* internal_default_instance() {
    return reinterpret_cast<const CommandReachedEndOfTopic*>(
               &_CommandReachedEndOfTopic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CommandReachedEndOfTopic& a, CommandReachedEndOfTopic& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandReachedEndOfTopic* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandReachedEndOfTopic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandReachedEndOfTopic* New() const final {
    return new CommandReachedEndOfTopic();
  }

  CommandReachedEndOfTopic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandReachedEndOfTopic>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandReachedEndOfTopic& from);
  void MergeFrom(const CommandReachedEndOfTopic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandReachedEndOfTopic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandReachedEndOfTopic";
  }
  protected:
  explicit CommandReachedEndOfTopic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandReachedEndOfTopic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandTopicMigrated final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandTopicMigrated) */ {
 public:
  inline CommandTopicMigrated() : CommandTopicMigrated(nullptr) {}
  ~CommandTopicMigrated() override;
  explicit constexpr CommandTopicMigrated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandTopicMigrated(const CommandTopicMigrated& from);
  CommandTopicMigrated(CommandTopicMigrated&& from) noexcept
    : CommandTopicMigrated() {
    *this = ::std::move(from);
  }

  inline CommandTopicMigrated& operator=(const CommandTopicMigrated& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandTopicMigrated& operator=(CommandTopicMigrated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandTopicMigrated& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandTopicMigrated* internal_default_instance() {
    return reinterpret_cast<const CommandTopicMigrated*>(
               &_CommandTopicMigrated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CommandTopicMigrated& a, CommandTopicMigrated& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandTopicMigrated* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandTopicMigrated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandTopicMigrated* New() const final {
    return new CommandTopicMigrated();
  }

  CommandTopicMigrated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandTopicMigrated>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandTopicMigrated& from);
  void MergeFrom(const CommandTopicMigrated& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandTopicMigrated* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandTopicMigrated";
  }
  protected:
  explicit CommandTopicMigrated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CommandTopicMigrated_ResourceType ResourceType;
  static constexpr ResourceType Producer =
    CommandTopicMigrated_ResourceType_Producer;
  static constexpr ResourceType Consumer =
    CommandTopicMigrated_ResourceType_Consumer;
  static inline bool ResourceType_IsValid(int value) {
    return CommandTopicMigrated_ResourceType_IsValid(value);
  }
  static constexpr ResourceType ResourceType_MIN =
    CommandTopicMigrated_ResourceType_ResourceType_MIN;
  static constexpr ResourceType ResourceType_MAX =
    CommandTopicMigrated_ResourceType_ResourceType_MAX;
  static constexpr int ResourceType_ARRAYSIZE =
    CommandTopicMigrated_ResourceType_ResourceType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResourceType_Name.");
    return CommandTopicMigrated_ResourceType_Name(enum_t_value);
  }
  static inline bool ResourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResourceType* value) {
    return CommandTopicMigrated_ResourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBrokerServiceUrlFieldNumber = 3,
    kBrokerServiceUrlTlsFieldNumber = 4,
    kResourceIdFieldNumber = 1,
    kResourceTypeFieldNumber = 2,
  };
  // optional string brokerServiceUrl = 3;
  bool has_brokerserviceurl() const;
  private:
  bool _internal_has_brokerserviceurl() const;
  public:
  void clear_brokerserviceurl();
  const std::string& brokerserviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brokerserviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brokerserviceurl();
  PROTOBUF_MUST_USE_RESULT std::string* release_brokerserviceurl();
  void set_allocated_brokerserviceurl(std::string* brokerserviceurl);
  private:
  const std::string& _internal_brokerserviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brokerserviceurl(const std::string& value);
  std::string* _internal_mutable_brokerserviceurl();
  public:

  // optional string brokerServiceUrlTls = 4;
  bool has_brokerserviceurltls() const;
  private:
  bool _internal_has_brokerserviceurltls() const;
  public:
  void clear_brokerserviceurltls();
  const std::string& brokerserviceurltls() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brokerserviceurltls(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brokerserviceurltls();
  PROTOBUF_MUST_USE_RESULT std::string* release_brokerserviceurltls();
  void set_allocated_brokerserviceurltls(std::string* brokerserviceurltls);
  private:
  const std::string& _internal_brokerserviceurltls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brokerserviceurltls(const std::string& value);
  std::string* _internal_mutable_brokerserviceurltls();
  public:

  // required uint64 resource_id = 1;
  bool has_resource_id() const;
  private:
  bool _internal_has_resource_id() const;
  public:
  void clear_resource_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 resource_id() const;
  void set_resource_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_resource_id() const;
  void _internal_set_resource_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
  bool has_resource_type() const;
  private:
  bool _internal_has_resource_type() const;
  public:
  void clear_resource_type();
  ::pulsar::proto::CommandTopicMigrated_ResourceType resource_type() const;
  void set_resource_type(::pulsar::proto::CommandTopicMigrated_ResourceType value);
  private:
  ::pulsar::proto::CommandTopicMigrated_ResourceType _internal_resource_type() const;
  void _internal_set_resource_type(::pulsar::proto::CommandTopicMigrated_ResourceType value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandTopicMigrated)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brokerserviceurl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brokerserviceurltls_;
  ::PROTOBUF_NAMESPACE_ID::uint64 resource_id_;
  int resource_type_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandCloseProducer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandCloseProducer) */ {
 public:
  inline CommandCloseProducer() : CommandCloseProducer(nullptr) {}
  ~CommandCloseProducer() override;
  explicit constexpr CommandCloseProducer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandCloseProducer(const CommandCloseProducer& from);
  CommandCloseProducer(CommandCloseProducer&& from) noexcept
    : CommandCloseProducer() {
    *this = ::std::move(from);
  }

  inline CommandCloseProducer& operator=(const CommandCloseProducer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandCloseProducer& operator=(CommandCloseProducer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandCloseProducer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandCloseProducer* internal_default_instance() {
    return reinterpret_cast<const CommandCloseProducer*>(
               &_CommandCloseProducer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CommandCloseProducer& a, CommandCloseProducer& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandCloseProducer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandCloseProducer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandCloseProducer* New() const final {
    return new CommandCloseProducer();
  }

  CommandCloseProducer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandCloseProducer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandCloseProducer& from);
  void MergeFrom(const CommandCloseProducer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandCloseProducer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandCloseProducer";
  }
  protected:
  explicit CommandCloseProducer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignedBrokerServiceUrlFieldNumber = 3,
    kAssignedBrokerServiceUrlTlsFieldNumber = 4,
    kProducerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // optional string assignedBrokerServiceUrl = 3;
  bool has_assignedbrokerserviceurl() const;
  private:
  bool _internal_has_assignedbrokerserviceurl() const;
  public:
  void clear_assignedbrokerserviceurl();
  const std::string& assignedbrokerserviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assignedbrokerserviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assignedbrokerserviceurl();
  PROTOBUF_MUST_USE_RESULT std::string* release_assignedbrokerserviceurl();
  void set_allocated_assignedbrokerserviceurl(std::string* assignedbrokerserviceurl);
  private:
  const std::string& _internal_assignedbrokerserviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assignedbrokerserviceurl(const std::string& value);
  std::string* _internal_mutable_assignedbrokerserviceurl();
  public:

  // optional string assignedBrokerServiceUrlTls = 4;
  bool has_assignedbrokerserviceurltls() const;
  private:
  bool _internal_has_assignedbrokerserviceurltls() const;
  public:
  void clear_assignedbrokerserviceurltls();
  const std::string& assignedbrokerserviceurltls() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assignedbrokerserviceurltls(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assignedbrokerserviceurltls();
  PROTOBUF_MUST_USE_RESULT std::string* release_assignedbrokerserviceurltls();
  void set_allocated_assignedbrokerserviceurltls(std::string* assignedbrokerserviceurltls);
  private:
  const std::string& _internal_assignedbrokerserviceurltls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assignedbrokerserviceurltls(const std::string& value);
  std::string* _internal_mutable_assignedbrokerserviceurltls();
  public:

  // required uint64 producer_id = 1;
  bool has_producer_id() const;
  private:
  bool _internal_has_producer_id() const;
  public:
  void clear_producer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id() const;
  void set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_producer_id() const;
  void _internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandCloseProducer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assignedbrokerserviceurl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assignedbrokerserviceurltls_;
  ::PROTOBUF_NAMESPACE_ID::uint64 producer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandCloseConsumer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandCloseConsumer) */ {
 public:
  inline CommandCloseConsumer() : CommandCloseConsumer(nullptr) {}
  ~CommandCloseConsumer() override;
  explicit constexpr CommandCloseConsumer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandCloseConsumer(const CommandCloseConsumer& from);
  CommandCloseConsumer(CommandCloseConsumer&& from) noexcept
    : CommandCloseConsumer() {
    *this = ::std::move(from);
  }

  inline CommandCloseConsumer& operator=(const CommandCloseConsumer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandCloseConsumer& operator=(CommandCloseConsumer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandCloseConsumer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandCloseConsumer* internal_default_instance() {
    return reinterpret_cast<const CommandCloseConsumer*>(
               &_CommandCloseConsumer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CommandCloseConsumer& a, CommandCloseConsumer& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandCloseConsumer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandCloseConsumer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandCloseConsumer* New() const final {
    return new CommandCloseConsumer();
  }

  CommandCloseConsumer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandCloseConsumer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandCloseConsumer& from);
  void MergeFrom(const CommandCloseConsumer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandCloseConsumer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandCloseConsumer";
  }
  protected:
  explicit CommandCloseConsumer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignedBrokerServiceUrlFieldNumber = 3,
    kAssignedBrokerServiceUrlTlsFieldNumber = 4,
    kConsumerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // optional string assignedBrokerServiceUrl = 3;
  bool has_assignedbrokerserviceurl() const;
  private:
  bool _internal_has_assignedbrokerserviceurl() const;
  public:
  void clear_assignedbrokerserviceurl();
  const std::string& assignedbrokerserviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assignedbrokerserviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assignedbrokerserviceurl();
  PROTOBUF_MUST_USE_RESULT std::string* release_assignedbrokerserviceurl();
  void set_allocated_assignedbrokerserviceurl(std::string* assignedbrokerserviceurl);
  private:
  const std::string& _internal_assignedbrokerserviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assignedbrokerserviceurl(const std::string& value);
  std::string* _internal_mutable_assignedbrokerserviceurl();
  public:

  // optional string assignedBrokerServiceUrlTls = 4;
  bool has_assignedbrokerserviceurltls() const;
  private:
  bool _internal_has_assignedbrokerserviceurltls() const;
  public:
  void clear_assignedbrokerserviceurltls();
  const std::string& assignedbrokerserviceurltls() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assignedbrokerserviceurltls(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assignedbrokerserviceurltls();
  PROTOBUF_MUST_USE_RESULT std::string* release_assignedbrokerserviceurltls();
  void set_allocated_assignedbrokerserviceurltls(std::string* assignedbrokerserviceurltls);
  private:
  const std::string& _internal_assignedbrokerserviceurltls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assignedbrokerserviceurltls(const std::string& value);
  std::string* _internal_mutable_assignedbrokerserviceurltls();
  public:

  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandCloseConsumer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assignedbrokerserviceurl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assignedbrokerserviceurltls_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandRedeliverUnacknowledgedMessages final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandRedeliverUnacknowledgedMessages) */ {
 public:
  inline CommandRedeliverUnacknowledgedMessages() : CommandRedeliverUnacknowledgedMessages(nullptr) {}
  ~CommandRedeliverUnacknowledgedMessages() override;
  explicit constexpr CommandRedeliverUnacknowledgedMessages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandRedeliverUnacknowledgedMessages(const CommandRedeliverUnacknowledgedMessages& from);
  CommandRedeliverUnacknowledgedMessages(CommandRedeliverUnacknowledgedMessages&& from) noexcept
    : CommandRedeliverUnacknowledgedMessages() {
    *this = ::std::move(from);
  }

  inline CommandRedeliverUnacknowledgedMessages& operator=(const CommandRedeliverUnacknowledgedMessages& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandRedeliverUnacknowledgedMessages& operator=(CommandRedeliverUnacknowledgedMessages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandRedeliverUnacknowledgedMessages& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandRedeliverUnacknowledgedMessages* internal_default_instance() {
    return reinterpret_cast<const CommandRedeliverUnacknowledgedMessages*>(
               &_CommandRedeliverUnacknowledgedMessages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CommandRedeliverUnacknowledgedMessages& a, CommandRedeliverUnacknowledgedMessages& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandRedeliverUnacknowledgedMessages* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandRedeliverUnacknowledgedMessages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandRedeliverUnacknowledgedMessages* New() const final {
    return new CommandRedeliverUnacknowledgedMessages();
  }

  CommandRedeliverUnacknowledgedMessages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandRedeliverUnacknowledgedMessages>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandRedeliverUnacknowledgedMessages& from);
  void MergeFrom(const CommandRedeliverUnacknowledgedMessages& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandRedeliverUnacknowledgedMessages* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandRedeliverUnacknowledgedMessages";
  }
  protected:
  explicit CommandRedeliverUnacknowledgedMessages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdsFieldNumber = 2,
    kConsumerIdFieldNumber = 1,
    kConsumerEpochFieldNumber = 3,
  };
  // repeated .pulsar.proto.MessageIdData message_ids = 2;
  int message_ids_size() const;
  private:
  int _internal_message_ids_size() const;
  public:
  void clear_message_ids();
  ::pulsar::proto::MessageIdData* mutable_message_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
      mutable_message_ids();
  private:
  const ::pulsar::proto::MessageIdData& _internal_message_ids(int index) const;
  ::pulsar::proto::MessageIdData* _internal_add_message_ids();
  public:
  const ::pulsar::proto::MessageIdData& message_ids(int index) const;
  ::pulsar::proto::MessageIdData* add_message_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
      message_ids() const;

  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 consumer_epoch = 3;
  bool has_consumer_epoch() const;
  private:
  bool _internal_has_consumer_epoch() const;
  public:
  void clear_consumer_epoch();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_epoch() const;
  void set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_epoch() const;
  void _internal_set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData > message_ids_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_epoch_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandSuccess final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSuccess) */ {
 public:
  inline CommandSuccess() : CommandSuccess(nullptr) {}
  ~CommandSuccess() override;
  explicit constexpr CommandSuccess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandSuccess(const CommandSuccess& from);
  CommandSuccess(CommandSuccess&& from) noexcept
    : CommandSuccess() {
    *this = ::std::move(from);
  }

  inline CommandSuccess& operator=(const CommandSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSuccess& operator=(CommandSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSuccess* internal_default_instance() {
    return reinterpret_cast<const CommandSuccess*>(
               &_CommandSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CommandSuccess& a, CommandSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSuccess* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSuccess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandSuccess* New() const final {
    return new CommandSuccess();
  }

  CommandSuccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandSuccess>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandSuccess& from);
  void MergeFrom(const CommandSuccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandSuccess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandSuccess";
  }
  protected:
  explicit CommandSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // optional .pulsar.proto.Schema schema = 2;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* schema);
  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::pulsar::proto::Schema* schema);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSuccess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pulsar::proto::Schema* schema_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandProducerSuccess final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandProducerSuccess) */ {
 public:
  inline CommandProducerSuccess() : CommandProducerSuccess(nullptr) {}
  ~CommandProducerSuccess() override;
  explicit constexpr CommandProducerSuccess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandProducerSuccess(const CommandProducerSuccess& from);
  CommandProducerSuccess(CommandProducerSuccess&& from) noexcept
    : CommandProducerSuccess() {
    *this = ::std::move(from);
  }

  inline CommandProducerSuccess& operator=(const CommandProducerSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandProducerSuccess& operator=(CommandProducerSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandProducerSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandProducerSuccess* internal_default_instance() {
    return reinterpret_cast<const CommandProducerSuccess*>(
               &_CommandProducerSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CommandProducerSuccess& a, CommandProducerSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandProducerSuccess* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandProducerSuccess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandProducerSuccess* New() const final {
    return new CommandProducerSuccess();
  }

  CommandProducerSuccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandProducerSuccess>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandProducerSuccess& from);
  void MergeFrom(const CommandProducerSuccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandProducerSuccess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandProducerSuccess";
  }
  protected:
  explicit CommandProducerSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProducerNameFieldNumber = 2,
    kSchemaVersionFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTopicEpochFieldNumber = 5,
    kProducerReadyFieldNumber = 6,
    kLastSequenceIdFieldNumber = 3,
  };
  // required string producer_name = 2;
  bool has_producer_name() const;
  private:
  bool _internal_has_producer_name() const;
  public:
  void clear_producer_name();
  const std::string& producer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_producer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_producer_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_producer_name();
  void set_allocated_producer_name(std::string* producer_name);
  private:
  const std::string& _internal_producer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_name(const std::string& value);
  std::string* _internal_mutable_producer_name();
  public:

  // optional bytes schema_version = 4;
  bool has_schema_version() const;
  private:
  bool _internal_has_schema_version() const;
  public:
  void clear_schema_version();
  const std::string& schema_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema_version();
  void set_allocated_schema_version(std::string* schema_version);
  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(const std::string& value);
  std::string* _internal_mutable_schema_version();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 topic_epoch = 5;
  bool has_topic_epoch() const;
  private:
  bool _internal_has_topic_epoch() const;
  public:
  void clear_topic_epoch();
  ::PROTOBUF_NAMESPACE_ID::uint64 topic_epoch() const;
  void set_topic_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_topic_epoch() const;
  void _internal_set_topic_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool producer_ready = 6 [default = true];
  bool has_producer_ready() const;
  private:
  bool _internal_has_producer_ready() const;
  public:
  void clear_producer_ready();
  bool producer_ready() const;
  void set_producer_ready(bool value);
  private:
  bool _internal_producer_ready() const;
  void _internal_set_producer_ready(bool value);
  public:

  // optional int64 last_sequence_id = 3 [default = -1];
  bool has_last_sequence_id() const;
  private:
  bool _internal_has_last_sequence_id() const;
  public:
  void clear_last_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::int64 last_sequence_id() const;
  void set_last_sequence_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_last_sequence_id() const;
  void _internal_set_last_sequence_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandProducerSuccess)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr producer_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_version_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 topic_epoch_;
  bool producer_ready_;
  ::PROTOBUF_NAMESPACE_ID::int64 last_sequence_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandError final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandError) */ {
 public:
  inline CommandError() : CommandError(nullptr) {}
  ~CommandError() override;
  explicit constexpr CommandError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandError(const CommandError& from);
  CommandError(CommandError&& from) noexcept
    : CommandError() {
    *this = ::std::move(from);
  }

  inline CommandError& operator=(const CommandError& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandError& operator=(CommandError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandError& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandError* internal_default_instance() {
    return reinterpret_cast<const CommandError*>(
               &_CommandError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CommandError& a, CommandError& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandError* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandError* New() const final {
    return new CommandError();
  }

  CommandError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandError& from);
  void MergeFrom(const CommandError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandError";
  }
  protected:
  explicit CommandError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // required string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .pulsar.proto.ServerError error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandError)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandPing final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandPing) */ {
 public:
  inline CommandPing() : CommandPing(nullptr) {}
  ~CommandPing() override;
  explicit constexpr CommandPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandPing(const CommandPing& from);
  CommandPing(CommandPing&& from) noexcept
    : CommandPing() {
    *this = ::std::move(from);
  }

  inline CommandPing& operator=(const CommandPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPing& operator=(CommandPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandPing* internal_default_instance() {
    return reinterpret_cast<const CommandPing*>(
               &_CommandPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(CommandPing& a, CommandPing& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPing* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandPing* New() const final {
    return new CommandPing();
  }

  CommandPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandPing>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandPing& from);
  void MergeFrom(const CommandPing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandPing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandPing";
  }
  protected:
  explicit CommandPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandPong final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandPong) */ {
 public:
  inline CommandPong() : CommandPong(nullptr) {}
  ~CommandPong() override;
  explicit constexpr CommandPong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandPong(const CommandPong& from);
  CommandPong(CommandPong&& from) noexcept
    : CommandPong() {
    *this = ::std::move(from);
  }

  inline CommandPong& operator=(const CommandPong& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPong& operator=(CommandPong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandPong& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandPong* internal_default_instance() {
    return reinterpret_cast<const CommandPong*>(
               &_CommandPong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(CommandPong& a, CommandPong& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPong* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandPong* New() const final {
    return new CommandPong();
  }

  CommandPong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandPong>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandPong& from);
  void MergeFrom(const CommandPong& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandPong* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandPong";
  }
  protected:
  explicit CommandPong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandConsumerStats final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandConsumerStats) */ {
 public:
  inline CommandConsumerStats() : CommandConsumerStats(nullptr) {}
  ~CommandConsumerStats() override;
  explicit constexpr CommandConsumerStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandConsumerStats(const CommandConsumerStats& from);
  CommandConsumerStats(CommandConsumerStats&& from) noexcept
    : CommandConsumerStats() {
    *this = ::std::move(from);
  }

  inline CommandConsumerStats& operator=(const CommandConsumerStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConsumerStats& operator=(CommandConsumerStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandConsumerStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConsumerStats* internal_default_instance() {
    return reinterpret_cast<const CommandConsumerStats*>(
               &_CommandConsumerStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CommandConsumerStats& a, CommandConsumerStats& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandConsumerStats* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConsumerStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandConsumerStats* New() const final {
    return new CommandConsumerStats();
  }

  CommandConsumerStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandConsumerStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandConsumerStats& from);
  void MergeFrom(const CommandConsumerStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandConsumerStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandConsumerStats";
  }
  protected:
  explicit CommandConsumerStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kConsumerIdFieldNumber = 4,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 consumer_id = 4;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConsumerStats)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandConsumerStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandConsumerStatsResponse) */ {
 public:
  inline CommandConsumerStatsResponse() : CommandConsumerStatsResponse(nullptr) {}
  ~CommandConsumerStatsResponse() override;
  explicit constexpr CommandConsumerStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandConsumerStatsResponse(const CommandConsumerStatsResponse& from);
  CommandConsumerStatsResponse(CommandConsumerStatsResponse&& from) noexcept
    : CommandConsumerStatsResponse() {
    *this = ::std::move(from);
  }

  inline CommandConsumerStatsResponse& operator=(const CommandConsumerStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConsumerStatsResponse& operator=(CommandConsumerStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandConsumerStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConsumerStatsResponse* internal_default_instance() {
    return reinterpret_cast<const CommandConsumerStatsResponse*>(
               &_CommandConsumerStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CommandConsumerStatsResponse& a, CommandConsumerStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandConsumerStatsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConsumerStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandConsumerStatsResponse* New() const final {
    return new CommandConsumerStatsResponse();
  }

  CommandConsumerStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandConsumerStatsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandConsumerStatsResponse& from);
  void MergeFrom(const CommandConsumerStatsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandConsumerStatsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandConsumerStatsResponse";
  }
  protected:
  explicit CommandConsumerStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kConsumerNameFieldNumber = 7,
    kAddressFieldNumber = 11,
    kConnectedSinceFieldNumber = 12,
    kTypeFieldNumber = 13,
    kRequestIdFieldNumber = 1,
    kMsgRateOutFieldNumber = 4,
    kMsgThroughputOutFieldNumber = 5,
    kMsgRateRedeliverFieldNumber = 6,
    kErrorCodeFieldNumber = 2,
    kBlockedConsumerOnUnackedMsgsFieldNumber = 10,
    kAvailablePermitsFieldNumber = 8,
    kUnackedMessagesFieldNumber = 9,
    kMsgRateExpiredFieldNumber = 14,
    kMsgBacklogFieldNumber = 15,
    kMessageAckRateFieldNumber = 16,
  };
  // optional string error_message = 3;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional string consumerName = 7;
  bool has_consumername() const;
  private:
  bool _internal_has_consumername() const;
  public:
  void clear_consumername();
  const std::string& consumername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consumername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consumername();
  PROTOBUF_MUST_USE_RESULT std::string* release_consumername();
  void set_allocated_consumername(std::string* consumername);
  private:
  const std::string& _internal_consumername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumername(const std::string& value);
  std::string* _internal_mutable_consumername();
  public:

  // optional string address = 11;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string connectedSince = 12;
  bool has_connectedsince() const;
  private:
  bool _internal_has_connectedsince() const;
  public:
  void clear_connectedsince();
  const std::string& connectedsince() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectedsince(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectedsince();
  PROTOBUF_MUST_USE_RESULT std::string* release_connectedsince();
  void set_allocated_connectedsince(std::string* connectedsince);
  private:
  const std::string& _internal_connectedsince() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectedsince(const std::string& value);
  std::string* _internal_mutable_connectedsince();
  public:

  // optional string type = 13;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional double msgRateOut = 4;
  bool has_msgrateout() const;
  private:
  bool _internal_has_msgrateout() const;
  public:
  void clear_msgrateout();
  double msgrateout() const;
  void set_msgrateout(double value);
  private:
  double _internal_msgrateout() const;
  void _internal_set_msgrateout(double value);
  public:

  // optional double msgThroughputOut = 5;
  bool has_msgthroughputout() const;
  private:
  bool _internal_has_msgthroughputout() const;
  public:
  void clear_msgthroughputout();
  double msgthroughputout() const;
  void set_msgthroughputout(double value);
  private:
  double _internal_msgthroughputout() const;
  void _internal_set_msgthroughputout(double value);
  public:

  // optional double msgRateRedeliver = 6;
  bool has_msgrateredeliver() const;
  private:
  bool _internal_has_msgrateredeliver() const;
  public:
  void clear_msgrateredeliver();
  double msgrateredeliver() const;
  void set_msgrateredeliver(double value);
  private:
  double _internal_msgrateredeliver() const;
  void _internal_set_msgrateredeliver(double value);
  public:

  // optional .pulsar.proto.ServerError error_code = 2;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::pulsar::proto::ServerError error_code() const;
  void set_error_code(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error_code() const;
  void _internal_set_error_code(::pulsar::proto::ServerError value);
  public:

  // optional bool blockedConsumerOnUnackedMsgs = 10;
  bool has_blockedconsumeronunackedmsgs() const;
  private:
  bool _internal_has_blockedconsumeronunackedmsgs() const;
  public:
  void clear_blockedconsumeronunackedmsgs();
  bool blockedconsumeronunackedmsgs() const;
  void set_blockedconsumeronunackedmsgs(bool value);
  private:
  bool _internal_blockedconsumeronunackedmsgs() const;
  void _internal_set_blockedconsumeronunackedmsgs(bool value);
  public:

  // optional uint64 availablePermits = 8;
  bool has_availablepermits() const;
  private:
  bool _internal_has_availablepermits() const;
  public:
  void clear_availablepermits();
  ::PROTOBUF_NAMESPACE_ID::uint64 availablepermits() const;
  void set_availablepermits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_availablepermits() const;
  void _internal_set_availablepermits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 unackedMessages = 9;
  bool has_unackedmessages() const;
  private:
  bool _internal_has_unackedmessages() const;
  public:
  void clear_unackedmessages();
  ::PROTOBUF_NAMESPACE_ID::uint64 unackedmessages() const;
  void set_unackedmessages(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_unackedmessages() const;
  void _internal_set_unackedmessages(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional double msgRateExpired = 14;
  bool has_msgrateexpired() const;
  private:
  bool _internal_has_msgrateexpired() const;
  public:
  void clear_msgrateexpired();
  double msgrateexpired() const;
  void set_msgrateexpired(double value);
  private:
  double _internal_msgrateexpired() const;
  void _internal_set_msgrateexpired(double value);
  public:

  // optional uint64 msgBacklog = 15;
  bool has_msgbacklog() const;
  private:
  bool _internal_has_msgbacklog() const;
  public:
  void clear_msgbacklog();
  ::PROTOBUF_NAMESPACE_ID::uint64 msgbacklog() const;
  void set_msgbacklog(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_msgbacklog() const;
  void _internal_set_msgbacklog(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional double messageAckRate = 16;
  bool has_messageackrate() const;
  private:
  bool _internal_has_messageackrate() const;
  public:
  void clear_messageackrate();
  double messageackrate() const;
  void set_messageackrate(double value);
  private:
  double _internal_messageackrate() const;
  void _internal_set_messageackrate(double value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConsumerStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consumername_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectedsince_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  double msgrateout_;
  double msgthroughputout_;
  double msgrateredeliver_;
  int error_code_;
  bool blockedconsumeronunackedmsgs_;
  ::PROTOBUF_NAMESPACE_ID::uint64 availablepermits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 unackedmessages_;
  double msgrateexpired_;
  ::PROTOBUF_NAMESPACE_ID::uint64 msgbacklog_;
  double messageackrate_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandGetLastMessageId final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetLastMessageId) */ {
 public:
  inline CommandGetLastMessageId() : CommandGetLastMessageId(nullptr) {}
  ~CommandGetLastMessageId() override;
  explicit constexpr CommandGetLastMessageId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandGetLastMessageId(const CommandGetLastMessageId& from);
  CommandGetLastMessageId(CommandGetLastMessageId&& from) noexcept
    : CommandGetLastMessageId() {
    *this = ::std::move(from);
  }

  inline CommandGetLastMessageId& operator=(const CommandGetLastMessageId& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetLastMessageId& operator=(CommandGetLastMessageId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetLastMessageId& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetLastMessageId* internal_default_instance() {
    return reinterpret_cast<const CommandGetLastMessageId*>(
               &_CommandGetLastMessageId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(CommandGetLastMessageId& a, CommandGetLastMessageId& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetLastMessageId* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetLastMessageId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandGetLastMessageId* New() const final {
    return new CommandGetLastMessageId();
  }

  CommandGetLastMessageId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandGetLastMessageId>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandGetLastMessageId& from);
  void MergeFrom(const CommandGetLastMessageId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandGetLastMessageId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandGetLastMessageId";
  }
  protected:
  explicit CommandGetLastMessageId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  private:
  bool _internal_has_consumer_id() const;
  public:
  void clear_consumer_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id() const;
  void set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_consumer_id() const;
  void _internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetLastMessageId)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 consumer_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandGetLastMessageIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetLastMessageIdResponse) */ {
 public:
  inline CommandGetLastMessageIdResponse() : CommandGetLastMessageIdResponse(nullptr) {}
  ~CommandGetLastMessageIdResponse() override;
  explicit constexpr CommandGetLastMessageIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandGetLastMessageIdResponse(const CommandGetLastMessageIdResponse& from);
  CommandGetLastMessageIdResponse(CommandGetLastMessageIdResponse&& from) noexcept
    : CommandGetLastMessageIdResponse() {
    *this = ::std::move(from);
  }

  inline CommandGetLastMessageIdResponse& operator=(const CommandGetLastMessageIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetLastMessageIdResponse& operator=(CommandGetLastMessageIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetLastMessageIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetLastMessageIdResponse* internal_default_instance() {
    return reinterpret_cast<const CommandGetLastMessageIdResponse*>(
               &_CommandGetLastMessageIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CommandGetLastMessageIdResponse& a, CommandGetLastMessageIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetLastMessageIdResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetLastMessageIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandGetLastMessageIdResponse* New() const final {
    return new CommandGetLastMessageIdResponse();
  }

  CommandGetLastMessageIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandGetLastMessageIdResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandGetLastMessageIdResponse& from);
  void MergeFrom(const CommandGetLastMessageIdResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandGetLastMessageIdResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandGetLastMessageIdResponse";
  }
  protected:
  explicit CommandGetLastMessageIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastMessageIdFieldNumber = 1,
    kConsumerMarkDeletePositionFieldNumber = 3,
    kRequestIdFieldNumber = 2,
  };
  // required .pulsar.proto.MessageIdData last_message_id = 1;
  bool has_last_message_id() const;
  private:
  bool _internal_has_last_message_id() const;
  public:
  void clear_last_message_id();
  const ::pulsar::proto::MessageIdData& last_message_id() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::MessageIdData* release_last_message_id();
  ::pulsar::proto::MessageIdData* mutable_last_message_id();
  void set_allocated_last_message_id(::pulsar::proto::MessageIdData* last_message_id);
  private:
  const ::pulsar::proto::MessageIdData& _internal_last_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_last_message_id();
  public:
  void unsafe_arena_set_allocated_last_message_id(
      ::pulsar::proto::MessageIdData* last_message_id);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_last_message_id();

  // optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
  bool has_consumer_mark_delete_position() const;
  private:
  bool _internal_has_consumer_mark_delete_position() const;
  public:
  void clear_consumer_mark_delete_position();
  const ::pulsar::proto::MessageIdData& consumer_mark_delete_position() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::MessageIdData* release_consumer_mark_delete_position();
  ::pulsar::proto::MessageIdData* mutable_consumer_mark_delete_position();
  void set_allocated_consumer_mark_delete_position(::pulsar::proto::MessageIdData* consumer_mark_delete_position);
  private:
  const ::pulsar::proto::MessageIdData& _internal_consumer_mark_delete_position() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_consumer_mark_delete_position();
  public:
  void unsafe_arena_set_allocated_consumer_mark_delete_position(
      ::pulsar::proto::MessageIdData* consumer_mark_delete_position);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_consumer_mark_delete_position();

  // required uint64 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetLastMessageIdResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pulsar::proto::MessageIdData* last_message_id_;
  ::pulsar::proto::MessageIdData* consumer_mark_delete_position_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandGetTopicsOfNamespace final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetTopicsOfNamespace) */ {
 public:
  inline CommandGetTopicsOfNamespace() : CommandGetTopicsOfNamespace(nullptr) {}
  ~CommandGetTopicsOfNamespace() override;
  explicit constexpr CommandGetTopicsOfNamespace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandGetTopicsOfNamespace(const CommandGetTopicsOfNamespace& from);
  CommandGetTopicsOfNamespace(CommandGetTopicsOfNamespace&& from) noexcept
    : CommandGetTopicsOfNamespace() {
    *this = ::std::move(from);
  }

  inline CommandGetTopicsOfNamespace& operator=(const CommandGetTopicsOfNamespace& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetTopicsOfNamespace& operator=(CommandGetTopicsOfNamespace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetTopicsOfNamespace& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetTopicsOfNamespace* internal_default_instance() {
    return reinterpret_cast<const CommandGetTopicsOfNamespace*>(
               &_CommandGetTopicsOfNamespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CommandGetTopicsOfNamespace& a, CommandGetTopicsOfNamespace& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetTopicsOfNamespace* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetTopicsOfNamespace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandGetTopicsOfNamespace* New() const final {
    return new CommandGetTopicsOfNamespace();
  }

  CommandGetTopicsOfNamespace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandGetTopicsOfNamespace>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandGetTopicsOfNamespace& from);
  void MergeFrom(const CommandGetTopicsOfNamespace& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandGetTopicsOfNamespace* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandGetTopicsOfNamespace";
  }
  protected:
  explicit CommandGetTopicsOfNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CommandGetTopicsOfNamespace_Mode Mode;
  static constexpr Mode PERSISTENT =
    CommandGetTopicsOfNamespace_Mode_PERSISTENT;
  static constexpr Mode NON_PERSISTENT =
    CommandGetTopicsOfNamespace_Mode_NON_PERSISTENT;
  static constexpr Mode ALL =
    CommandGetTopicsOfNamespace_Mode_ALL;
  static inline bool Mode_IsValid(int value) {
    return CommandGetTopicsOfNamespace_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    CommandGetTopicsOfNamespace_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    CommandGetTopicsOfNamespace_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    CommandGetTopicsOfNamespace_Mode_Mode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return CommandGetTopicsOfNamespace_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return CommandGetTopicsOfNamespace_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 2,
    kTopicsPatternFieldNumber = 4,
    kTopicsHashFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kModeFieldNumber = 3,
  };
  // required string namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // optional string topics_pattern = 4;
  bool has_topics_pattern() const;
  private:
  bool _internal_has_topics_pattern() const;
  public:
  void clear_topics_pattern();
  const std::string& topics_pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topics_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topics_pattern();
  PROTOBUF_MUST_USE_RESULT std::string* release_topics_pattern();
  void set_allocated_topics_pattern(std::string* topics_pattern);
  private:
  const std::string& _internal_topics_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_pattern(const std::string& value);
  std::string* _internal_mutable_topics_pattern();
  public:

  // optional string topics_hash = 5;
  bool has_topics_hash() const;
  private:
  bool _internal_has_topics_hash() const;
  public:
  void clear_topics_hash();
  const std::string& topics_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topics_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topics_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* topics_hash);
  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(const std::string& value);
  std::string* _internal_mutable_topics_hash();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::pulsar::proto::CommandGetTopicsOfNamespace_Mode mode() const;
  void set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value);
  private:
  ::pulsar::proto::CommandGetTopicsOfNamespace_Mode _internal_mode() const;
  void _internal_set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetTopicsOfNamespace)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topics_pattern_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topics_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  int mode_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandGetTopicsOfNamespaceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetTopicsOfNamespaceResponse) */ {
 public:
  inline CommandGetTopicsOfNamespaceResponse() : CommandGetTopicsOfNamespaceResponse(nullptr) {}
  ~CommandGetTopicsOfNamespaceResponse() override;
  explicit constexpr CommandGetTopicsOfNamespaceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandGetTopicsOfNamespaceResponse(const CommandGetTopicsOfNamespaceResponse& from);
  CommandGetTopicsOfNamespaceResponse(CommandGetTopicsOfNamespaceResponse&& from) noexcept
    : CommandGetTopicsOfNamespaceResponse() {
    *this = ::std::move(from);
  }

  inline CommandGetTopicsOfNamespaceResponse& operator=(const CommandGetTopicsOfNamespaceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetTopicsOfNamespaceResponse& operator=(CommandGetTopicsOfNamespaceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetTopicsOfNamespaceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetTopicsOfNamespaceResponse* internal_default_instance() {
    return reinterpret_cast<const CommandGetTopicsOfNamespaceResponse*>(
               &_CommandGetTopicsOfNamespaceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CommandGetTopicsOfNamespaceResponse& a, CommandGetTopicsOfNamespaceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetTopicsOfNamespaceResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetTopicsOfNamespaceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandGetTopicsOfNamespaceResponse* New() const final {
    return new CommandGetTopicsOfNamespaceResponse();
  }

  CommandGetTopicsOfNamespaceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandGetTopicsOfNamespaceResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandGetTopicsOfNamespaceResponse& from);
  void MergeFrom(const CommandGetTopicsOfNamespaceResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandGetTopicsOfNamespaceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandGetTopicsOfNamespaceResponse";
  }
  protected:
  explicit CommandGetTopicsOfNamespaceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 2,
    kTopicsHashFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kFilteredFieldNumber = 3,
    kChangedFieldNumber = 5,
  };
  // repeated string topics = 2;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const char* value, size_t size);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topics();
  private:
  const std::string& _internal_topics(int index) const;
  std::string* _internal_add_topics();
  public:

  // optional string topics_hash = 4;
  bool has_topics_hash() const;
  private:
  bool _internal_has_topics_hash() const;
  public:
  void clear_topics_hash();
  const std::string& topics_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topics_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topics_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* topics_hash);
  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(const std::string& value);
  std::string* _internal_mutable_topics_hash();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool filtered = 3 [default = false];
  bool has_filtered() const;
  private:
  bool _internal_has_filtered() const;
  public:
  void clear_filtered();
  bool filtered() const;
  void set_filtered(bool value);
  private:
  bool _internal_filtered() const;
  void _internal_set_filtered(bool value);
  public:

  // optional bool changed = 5 [default = true];
  bool has_changed() const;
  private:
  bool _internal_has_changed() const;
  public:
  void clear_changed();
  bool changed() const;
  void set_changed(bool value);
  private:
  bool _internal_changed() const;
  void _internal_set_changed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topics_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topics_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  bool filtered_;
  bool changed_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandWatchTopicList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandWatchTopicList) */ {
 public:
  inline CommandWatchTopicList() : CommandWatchTopicList(nullptr) {}
  ~CommandWatchTopicList() override;
  explicit constexpr CommandWatchTopicList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandWatchTopicList(const CommandWatchTopicList& from);
  CommandWatchTopicList(CommandWatchTopicList&& from) noexcept
    : CommandWatchTopicList() {
    *this = ::std::move(from);
  }

  inline CommandWatchTopicList& operator=(const CommandWatchTopicList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandWatchTopicList& operator=(CommandWatchTopicList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandWatchTopicList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandWatchTopicList* internal_default_instance() {
    return reinterpret_cast<const CommandWatchTopicList*>(
               &_CommandWatchTopicList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CommandWatchTopicList& a, CommandWatchTopicList& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandWatchTopicList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandWatchTopicList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandWatchTopicList* New() const final {
    return new CommandWatchTopicList();
  }

  CommandWatchTopicList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandWatchTopicList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandWatchTopicList& from);
  void MergeFrom(const CommandWatchTopicList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandWatchTopicList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandWatchTopicList";
  }
  protected:
  explicit CommandWatchTopicList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 3,
    kTopicsPatternFieldNumber = 4,
    kTopicsHashFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kWatcherIdFieldNumber = 2,
  };
  // required string namespace = 3;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // required string topics_pattern = 4;
  bool has_topics_pattern() const;
  private:
  bool _internal_has_topics_pattern() const;
  public:
  void clear_topics_pattern();
  const std::string& topics_pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topics_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topics_pattern();
  PROTOBUF_MUST_USE_RESULT std::string* release_topics_pattern();
  void set_allocated_topics_pattern(std::string* topics_pattern);
  private:
  const std::string& _internal_topics_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_pattern(const std::string& value);
  std::string* _internal_mutable_topics_pattern();
  public:

  // optional string topics_hash = 5;
  bool has_topics_hash() const;
  private:
  bool _internal_has_topics_hash() const;
  public:
  void clear_topics_hash();
  const std::string& topics_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topics_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topics_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* topics_hash);
  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(const std::string& value);
  std::string* _internal_mutable_topics_hash();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 watcher_id = 2;
  bool has_watcher_id() const;
  private:
  bool _internal_has_watcher_id() const;
  public:
  void clear_watcher_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 watcher_id() const;
  void set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_watcher_id() const;
  void _internal_set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandWatchTopicList)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topics_pattern_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topics_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 watcher_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandWatchTopicListSuccess final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandWatchTopicListSuccess) */ {
 public:
  inline CommandWatchTopicListSuccess() : CommandWatchTopicListSuccess(nullptr) {}
  ~CommandWatchTopicListSuccess() override;
  explicit constexpr CommandWatchTopicListSuccess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandWatchTopicListSuccess(const CommandWatchTopicListSuccess& from);
  CommandWatchTopicListSuccess(CommandWatchTopicListSuccess&& from) noexcept
    : CommandWatchTopicListSuccess() {
    *this = ::std::move(from);
  }

  inline CommandWatchTopicListSuccess& operator=(const CommandWatchTopicListSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandWatchTopicListSuccess& operator=(CommandWatchTopicListSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandWatchTopicListSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandWatchTopicListSuccess* internal_default_instance() {
    return reinterpret_cast<const CommandWatchTopicListSuccess*>(
               &_CommandWatchTopicListSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CommandWatchTopicListSuccess& a, CommandWatchTopicListSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandWatchTopicListSuccess* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandWatchTopicListSuccess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandWatchTopicListSuccess* New() const final {
    return new CommandWatchTopicListSuccess();
  }

  CommandWatchTopicListSuccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandWatchTopicListSuccess>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandWatchTopicListSuccess& from);
  void MergeFrom(const CommandWatchTopicListSuccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandWatchTopicListSuccess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandWatchTopicListSuccess";
  }
  protected:
  explicit CommandWatchTopicListSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 3,
    kTopicsHashFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kWatcherIdFieldNumber = 2,
  };
  // repeated string topic = 3;
  int topic_size() const;
  private:
  int _internal_topic_size() const;
  public:
  void clear_topic();
  const std::string& topic(int index) const;
  std::string* mutable_topic(int index);
  void set_topic(int index, const std::string& value);
  void set_topic(int index, std::string&& value);
  void set_topic(int index, const char* value);
  void set_topic(int index, const char* value, size_t size);
  std::string* add_topic();
  void add_topic(const std::string& value);
  void add_topic(std::string&& value);
  void add_topic(const char* value);
  void add_topic(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topic();
  private:
  const std::string& _internal_topic(int index) const;
  std::string* _internal_add_topic();
  public:

  // required string topics_hash = 4;
  bool has_topics_hash() const;
  private:
  bool _internal_has_topics_hash() const;
  public:
  void clear_topics_hash();
  const std::string& topics_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topics_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topics_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* topics_hash);
  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(const std::string& value);
  std::string* _internal_mutable_topics_hash();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 watcher_id = 2;
  bool has_watcher_id() const;
  private:
  bool _internal_has_watcher_id() const;
  public:
  void clear_watcher_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 watcher_id() const;
  void set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_watcher_id() const;
  void _internal_set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandWatchTopicListSuccess)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topics_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 watcher_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandWatchTopicUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandWatchTopicUpdate) */ {
 public:
  inline CommandWatchTopicUpdate() : CommandWatchTopicUpdate(nullptr) {}
  ~CommandWatchTopicUpdate() override;
  explicit constexpr CommandWatchTopicUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandWatchTopicUpdate(const CommandWatchTopicUpdate& from);
  CommandWatchTopicUpdate(CommandWatchTopicUpdate&& from) noexcept
    : CommandWatchTopicUpdate() {
    *this = ::std::move(from);
  }

  inline CommandWatchTopicUpdate& operator=(const CommandWatchTopicUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandWatchTopicUpdate& operator=(CommandWatchTopicUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandWatchTopicUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandWatchTopicUpdate* internal_default_instance() {
    return reinterpret_cast<const CommandWatchTopicUpdate*>(
               &_CommandWatchTopicUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CommandWatchTopicUpdate& a, CommandWatchTopicUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandWatchTopicUpdate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandWatchTopicUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandWatchTopicUpdate* New() const final {
    return new CommandWatchTopicUpdate();
  }

  CommandWatchTopicUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandWatchTopicUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandWatchTopicUpdate& from);
  void MergeFrom(const CommandWatchTopicUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandWatchTopicUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandWatchTopicUpdate";
  }
  protected:
  explicit CommandWatchTopicUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewTopicsFieldNumber = 2,
    kDeletedTopicsFieldNumber = 3,
    kTopicsHashFieldNumber = 4,
    kWatcherIdFieldNumber = 1,
  };
  // repeated string new_topics = 2;
  int new_topics_size() const;
  private:
  int _internal_new_topics_size() const;
  public:
  void clear_new_topics();
  const std::string& new_topics(int index) const;
  std::string* mutable_new_topics(int index);
  void set_new_topics(int index, const std::string& value);
  void set_new_topics(int index, std::string&& value);
  void set_new_topics(int index, const char* value);
  void set_new_topics(int index, const char* value, size_t size);
  std::string* add_new_topics();
  void add_new_topics(const std::string& value);
  void add_new_topics(std::string&& value);
  void add_new_topics(const char* value);
  void add_new_topics(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& new_topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_new_topics();
  private:
  const std::string& _internal_new_topics(int index) const;
  std::string* _internal_add_new_topics();
  public:

  // repeated string deleted_topics = 3;
  int deleted_topics_size() const;
  private:
  int _internal_deleted_topics_size() const;
  public:
  void clear_deleted_topics();
  const std::string& deleted_topics(int index) const;
  std::string* mutable_deleted_topics(int index);
  void set_deleted_topics(int index, const std::string& value);
  void set_deleted_topics(int index, std::string&& value);
  void set_deleted_topics(int index, const char* value);
  void set_deleted_topics(int index, const char* value, size_t size);
  std::string* add_deleted_topics();
  void add_deleted_topics(const std::string& value);
  void add_deleted_topics(std::string&& value);
  void add_deleted_topics(const char* value);
  void add_deleted_topics(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& deleted_topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_deleted_topics();
  private:
  const std::string& _internal_deleted_topics(int index) const;
  std::string* _internal_add_deleted_topics();
  public:

  // required string topics_hash = 4;
  bool has_topics_hash() const;
  private:
  bool _internal_has_topics_hash() const;
  public:
  void clear_topics_hash();
  const std::string& topics_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topics_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topics_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* topics_hash);
  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(const std::string& value);
  std::string* _internal_mutable_topics_hash();
  public:

  // required uint64 watcher_id = 1;
  bool has_watcher_id() const;
  private:
  bool _internal_has_watcher_id() const;
  public:
  void clear_watcher_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 watcher_id() const;
  void set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_watcher_id() const;
  void _internal_set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandWatchTopicUpdate)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> new_topics_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> deleted_topics_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topics_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint64 watcher_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandWatchTopicListClose final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandWatchTopicListClose) */ {
 public:
  inline CommandWatchTopicListClose() : CommandWatchTopicListClose(nullptr) {}
  ~CommandWatchTopicListClose() override;
  explicit constexpr CommandWatchTopicListClose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandWatchTopicListClose(const CommandWatchTopicListClose& from);
  CommandWatchTopicListClose(CommandWatchTopicListClose&& from) noexcept
    : CommandWatchTopicListClose() {
    *this = ::std::move(from);
  }

  inline CommandWatchTopicListClose& operator=(const CommandWatchTopicListClose& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandWatchTopicListClose& operator=(CommandWatchTopicListClose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandWatchTopicListClose& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandWatchTopicListClose* internal_default_instance() {
    return reinterpret_cast<const CommandWatchTopicListClose*>(
               &_CommandWatchTopicListClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CommandWatchTopicListClose& a, CommandWatchTopicListClose& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandWatchTopicListClose* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandWatchTopicListClose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandWatchTopicListClose* New() const final {
    return new CommandWatchTopicListClose();
  }

  CommandWatchTopicListClose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandWatchTopicListClose>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandWatchTopicListClose& from);
  void MergeFrom(const CommandWatchTopicListClose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandWatchTopicListClose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandWatchTopicListClose";
  }
  protected:
  explicit CommandWatchTopicListClose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kWatcherIdFieldNumber = 2,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 watcher_id = 2;
  bool has_watcher_id() const;
  private:
  bool _internal_has_watcher_id() const;
  public:
  void clear_watcher_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 watcher_id() const;
  void set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_watcher_id() const;
  void _internal_set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandWatchTopicListClose)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 watcher_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandGetSchema final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetSchema) */ {
 public:
  inline CommandGetSchema() : CommandGetSchema(nullptr) {}
  ~CommandGetSchema() override;
  explicit constexpr CommandGetSchema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandGetSchema(const CommandGetSchema& from);
  CommandGetSchema(CommandGetSchema&& from) noexcept
    : CommandGetSchema() {
    *this = ::std::move(from);
  }

  inline CommandGetSchema& operator=(const CommandGetSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetSchema& operator=(CommandGetSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetSchema* internal_default_instance() {
    return reinterpret_cast<const CommandGetSchema*>(
               &_CommandGetSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CommandGetSchema& a, CommandGetSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetSchema* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetSchema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandGetSchema* New() const final {
    return new CommandGetSchema();
  }

  CommandGetSchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandGetSchema>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandGetSchema& from);
  void MergeFrom(const CommandGetSchema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandGetSchema* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandGetSchema";
  }
  protected:
  explicit CommandGetSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 2,
    kSchemaVersionFieldNumber = 3,
    kRequestIdFieldNumber = 1,
  };
  // required string topic = 2;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // optional bytes schema_version = 3;
  bool has_schema_version() const;
  private:
  bool _internal_has_schema_version() const;
  public:
  void clear_schema_version();
  const std::string& schema_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema_version();
  void set_allocated_schema_version(std::string* schema_version);
  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(const std::string& value);
  std::string* _internal_mutable_schema_version();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetSchema)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_version_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandGetSchemaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetSchemaResponse) */ {
 public:
  inline CommandGetSchemaResponse() : CommandGetSchemaResponse(nullptr) {}
  ~CommandGetSchemaResponse() override;
  explicit constexpr CommandGetSchemaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandGetSchemaResponse(const CommandGetSchemaResponse& from);
  CommandGetSchemaResponse(CommandGetSchemaResponse&& from) noexcept
    : CommandGetSchemaResponse() {
    *this = ::std::move(from);
  }

  inline CommandGetSchemaResponse& operator=(const CommandGetSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetSchemaResponse& operator=(CommandGetSchemaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetSchemaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const CommandGetSchemaResponse*>(
               &_CommandGetSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CommandGetSchemaResponse& a, CommandGetSchemaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetSchemaResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetSchemaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandGetSchemaResponse* New() const final {
    return new CommandGetSchemaResponse();
  }

  CommandGetSchemaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandGetSchemaResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandGetSchemaResponse& from);
  void MergeFrom(const CommandGetSchemaResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandGetSchemaResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandGetSchemaResponse";
  }
  protected:
  explicit CommandGetSchemaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kSchemaVersionFieldNumber = 5,
    kSchemaFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // optional string error_message = 3;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional bytes schema_version = 5;
  bool has_schema_version() const;
  private:
  bool _internal_has_schema_version() const;
  public:
  void clear_schema_version();
  const std::string& schema_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema_version();
  void set_allocated_schema_version(std::string* schema_version);
  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(const std::string& value);
  std::string* _internal_mutable_schema_version();
  public:

  // optional .pulsar.proto.Schema schema = 4;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* schema);
  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::pulsar::proto::Schema* schema);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error_code = 2;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::pulsar::proto::ServerError error_code() const;
  void set_error_code(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error_code() const;
  void _internal_set_error_code(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetSchemaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_version_;
  ::pulsar::proto::Schema* schema_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  int error_code_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandGetOrCreateSchema final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetOrCreateSchema) */ {
 public:
  inline CommandGetOrCreateSchema() : CommandGetOrCreateSchema(nullptr) {}
  ~CommandGetOrCreateSchema() override;
  explicit constexpr CommandGetOrCreateSchema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandGetOrCreateSchema(const CommandGetOrCreateSchema& from);
  CommandGetOrCreateSchema(CommandGetOrCreateSchema&& from) noexcept
    : CommandGetOrCreateSchema() {
    *this = ::std::move(from);
  }

  inline CommandGetOrCreateSchema& operator=(const CommandGetOrCreateSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetOrCreateSchema& operator=(CommandGetOrCreateSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetOrCreateSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetOrCreateSchema* internal_default_instance() {
    return reinterpret_cast<const CommandGetOrCreateSchema*>(
               &_CommandGetOrCreateSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CommandGetOrCreateSchema& a, CommandGetOrCreateSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetOrCreateSchema* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetOrCreateSchema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandGetOrCreateSchema* New() const final {
    return new CommandGetOrCreateSchema();
  }

  CommandGetOrCreateSchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandGetOrCreateSchema>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandGetOrCreateSchema& from);
  void MergeFrom(const CommandGetOrCreateSchema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandGetOrCreateSchema* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandGetOrCreateSchema";
  }
  protected:
  explicit CommandGetOrCreateSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 2,
    kSchemaFieldNumber = 3,
    kRequestIdFieldNumber = 1,
  };
  // required string topic = 2;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // required .pulsar.proto.Schema schema = 3;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* schema);
  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::pulsar::proto::Schema* schema);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetOrCreateSchema)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::pulsar::proto::Schema* schema_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandGetOrCreateSchemaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetOrCreateSchemaResponse) */ {
 public:
  inline CommandGetOrCreateSchemaResponse() : CommandGetOrCreateSchemaResponse(nullptr) {}
  ~CommandGetOrCreateSchemaResponse() override;
  explicit constexpr CommandGetOrCreateSchemaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandGetOrCreateSchemaResponse(const CommandGetOrCreateSchemaResponse& from);
  CommandGetOrCreateSchemaResponse(CommandGetOrCreateSchemaResponse&& from) noexcept
    : CommandGetOrCreateSchemaResponse() {
    *this = ::std::move(from);
  }

  inline CommandGetOrCreateSchemaResponse& operator=(const CommandGetOrCreateSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetOrCreateSchemaResponse& operator=(CommandGetOrCreateSchemaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetOrCreateSchemaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetOrCreateSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const CommandGetOrCreateSchemaResponse*>(
               &_CommandGetOrCreateSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CommandGetOrCreateSchemaResponse& a, CommandGetOrCreateSchemaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetOrCreateSchemaResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetOrCreateSchemaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandGetOrCreateSchemaResponse* New() const final {
    return new CommandGetOrCreateSchemaResponse();
  }

  CommandGetOrCreateSchemaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandGetOrCreateSchemaResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandGetOrCreateSchemaResponse& from);
  void MergeFrom(const CommandGetOrCreateSchemaResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandGetOrCreateSchemaResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandGetOrCreateSchemaResponse";
  }
  protected:
  explicit CommandGetOrCreateSchemaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kSchemaVersionFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // optional string error_message = 3;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional bytes schema_version = 4;
  bool has_schema_version() const;
  private:
  bool _internal_has_schema_version() const;
  public:
  void clear_schema_version();
  const std::string& schema_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema_version();
  void set_allocated_schema_version(std::string* schema_version);
  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(const std::string& value);
  std::string* _internal_mutable_schema_version();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error_code = 2;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::pulsar::proto::ServerError error_code() const;
  void set_error_code(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error_code() const;
  void _internal_set_error_code(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetOrCreateSchemaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_version_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  int error_code_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandTcClientConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandTcClientConnectRequest) */ {
 public:
  inline CommandTcClientConnectRequest() : CommandTcClientConnectRequest(nullptr) {}
  ~CommandTcClientConnectRequest() override;
  explicit constexpr CommandTcClientConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandTcClientConnectRequest(const CommandTcClientConnectRequest& from);
  CommandTcClientConnectRequest(CommandTcClientConnectRequest&& from) noexcept
    : CommandTcClientConnectRequest() {
    *this = ::std::move(from);
  }

  inline CommandTcClientConnectRequest& operator=(const CommandTcClientConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandTcClientConnectRequest& operator=(CommandTcClientConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandTcClientConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandTcClientConnectRequest* internal_default_instance() {
    return reinterpret_cast<const CommandTcClientConnectRequest*>(
               &_CommandTcClientConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(CommandTcClientConnectRequest& a, CommandTcClientConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandTcClientConnectRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandTcClientConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandTcClientConnectRequest* New() const final {
    return new CommandTcClientConnectRequest();
  }

  CommandTcClientConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandTcClientConnectRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandTcClientConnectRequest& from);
  void MergeFrom(const CommandTcClientConnectRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandTcClientConnectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandTcClientConnectRequest";
  }
  protected:
  explicit CommandTcClientConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kTcIdFieldNumber = 2,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 tc_id = 2 [default = 0];
  bool has_tc_id() const;
  private:
  bool _internal_has_tc_id() const;
  public:
  void clear_tc_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 tc_id() const;
  void set_tc_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tc_id() const;
  void _internal_set_tc_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandTcClientConnectRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tc_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandTcClientConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandTcClientConnectResponse) */ {
 public:
  inline CommandTcClientConnectResponse() : CommandTcClientConnectResponse(nullptr) {}
  ~CommandTcClientConnectResponse() override;
  explicit constexpr CommandTcClientConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandTcClientConnectResponse(const CommandTcClientConnectResponse& from);
  CommandTcClientConnectResponse(CommandTcClientConnectResponse&& from) noexcept
    : CommandTcClientConnectResponse() {
    *this = ::std::move(from);
  }

  inline CommandTcClientConnectResponse& operator=(const CommandTcClientConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandTcClientConnectResponse& operator=(CommandTcClientConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandTcClientConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandTcClientConnectResponse* internal_default_instance() {
    return reinterpret_cast<const CommandTcClientConnectResponse*>(
               &_CommandTcClientConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CommandTcClientConnectResponse& a, CommandTcClientConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandTcClientConnectResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandTcClientConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandTcClientConnectResponse* New() const final {
    return new CommandTcClientConnectResponse();
  }

  CommandTcClientConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandTcClientConnectResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandTcClientConnectResponse& from);
  void MergeFrom(const CommandTcClientConnectResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandTcClientConnectResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandTcClientConnectResponse";
  }
  protected:
  explicit CommandTcClientConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandTcClientConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandNewTxn final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandNewTxn) */ {
 public:
  inline CommandNewTxn() : CommandNewTxn(nullptr) {}
  ~CommandNewTxn() override;
  explicit constexpr CommandNewTxn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandNewTxn(const CommandNewTxn& from);
  CommandNewTxn(CommandNewTxn&& from) noexcept
    : CommandNewTxn() {
    *this = ::std::move(from);
  }

  inline CommandNewTxn& operator=(const CommandNewTxn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandNewTxn& operator=(CommandNewTxn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandNewTxn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandNewTxn* internal_default_instance() {
    return reinterpret_cast<const CommandNewTxn*>(
               &_CommandNewTxn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CommandNewTxn& a, CommandNewTxn& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandNewTxn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandNewTxn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandNewTxn* New() const final {
    return new CommandNewTxn();
  }

  CommandNewTxn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandNewTxn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandNewTxn& from);
  void MergeFrom(const CommandNewTxn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandNewTxn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandNewTxn";
  }
  protected:
  explicit CommandNewTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kTxnTtlSecondsFieldNumber = 2,
    kTcIdFieldNumber = 3,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txn_ttl_seconds = 2 [default = 0];
  bool has_txn_ttl_seconds() const;
  private:
  bool _internal_has_txn_ttl_seconds() const;
  public:
  void clear_txn_ttl_seconds();
  ::PROTOBUF_NAMESPACE_ID::uint64 txn_ttl_seconds() const;
  void set_txn_ttl_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txn_ttl_seconds() const;
  void _internal_set_txn_ttl_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 tc_id = 3 [default = 0];
  bool has_tc_id() const;
  private:
  bool _internal_has_tc_id() const;
  public:
  void clear_tc_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 tc_id() const;
  void set_tc_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tc_id() const;
  void _internal_set_tc_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandNewTxn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txn_ttl_seconds_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tc_id_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandNewTxnResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandNewTxnResponse) */ {
 public:
  inline CommandNewTxnResponse() : CommandNewTxnResponse(nullptr) {}
  ~CommandNewTxnResponse() override;
  explicit constexpr CommandNewTxnResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandNewTxnResponse(const CommandNewTxnResponse& from);
  CommandNewTxnResponse(CommandNewTxnResponse&& from) noexcept
    : CommandNewTxnResponse() {
    *this = ::std::move(from);
  }

  inline CommandNewTxnResponse& operator=(const CommandNewTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandNewTxnResponse& operator=(CommandNewTxnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandNewTxnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandNewTxnResponse* internal_default_instance() {
    return reinterpret_cast<const CommandNewTxnResponse*>(
               &_CommandNewTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(CommandNewTxnResponse& a, CommandNewTxnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandNewTxnResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandNewTxnResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandNewTxnResponse* New() const final {
    return new CommandNewTxnResponse();
  }

  CommandNewTxnResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandNewTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandNewTxnResponse& from);
  void MergeFrom(const CommandNewTxnResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandNewTxnResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandNewTxnResponse";
  }
  protected:
  explicit CommandNewTxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandNewTxnResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandAddPartitionToTxn final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAddPartitionToTxn) */ {
 public:
  inline CommandAddPartitionToTxn() : CommandAddPartitionToTxn(nullptr) {}
  ~CommandAddPartitionToTxn() override;
  explicit constexpr CommandAddPartitionToTxn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandAddPartitionToTxn(const CommandAddPartitionToTxn& from);
  CommandAddPartitionToTxn(CommandAddPartitionToTxn&& from) noexcept
    : CommandAddPartitionToTxn() {
    *this = ::std::move(from);
  }

  inline CommandAddPartitionToTxn& operator=(const CommandAddPartitionToTxn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAddPartitionToTxn& operator=(CommandAddPartitionToTxn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAddPartitionToTxn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAddPartitionToTxn* internal_default_instance() {
    return reinterpret_cast<const CommandAddPartitionToTxn*>(
               &_CommandAddPartitionToTxn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(CommandAddPartitionToTxn& a, CommandAddPartitionToTxn& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAddPartitionToTxn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAddPartitionToTxn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandAddPartitionToTxn* New() const final {
    return new CommandAddPartitionToTxn();
  }

  CommandAddPartitionToTxn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandAddPartitionToTxn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandAddPartitionToTxn& from);
  void MergeFrom(const CommandAddPartitionToTxn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandAddPartitionToTxn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandAddPartitionToTxn";
  }
  protected:
  explicit CommandAddPartitionToTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionsFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
  };
  // repeated string partitions = 4;
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;
  public:
  void clear_partitions();
  const std::string& partitions(int index) const;
  std::string* mutable_partitions(int index);
  void set_partitions(int index, const std::string& value);
  void set_partitions(int index, std::string&& value);
  void set_partitions(int index, const char* value);
  void set_partitions(int index, const char* value, size_t size);
  std::string* add_partitions();
  void add_partitions(const std::string& value);
  void add_partitions(std::string&& value);
  void add_partitions(const char* value);
  void add_partitions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& partitions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_partitions();
  private:
  const std::string& _internal_partitions(int index) const;
  std::string* _internal_add_partitions();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAddPartitionToTxn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> partitions_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandAddPartitionToTxnResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAddPartitionToTxnResponse) */ {
 public:
  inline CommandAddPartitionToTxnResponse() : CommandAddPartitionToTxnResponse(nullptr) {}
  ~CommandAddPartitionToTxnResponse() override;
  explicit constexpr CommandAddPartitionToTxnResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandAddPartitionToTxnResponse(const CommandAddPartitionToTxnResponse& from);
  CommandAddPartitionToTxnResponse(CommandAddPartitionToTxnResponse&& from) noexcept
    : CommandAddPartitionToTxnResponse() {
    *this = ::std::move(from);
  }

  inline CommandAddPartitionToTxnResponse& operator=(const CommandAddPartitionToTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAddPartitionToTxnResponse& operator=(CommandAddPartitionToTxnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAddPartitionToTxnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAddPartitionToTxnResponse* internal_default_instance() {
    return reinterpret_cast<const CommandAddPartitionToTxnResponse*>(
               &_CommandAddPartitionToTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(CommandAddPartitionToTxnResponse& a, CommandAddPartitionToTxnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAddPartitionToTxnResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAddPartitionToTxnResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandAddPartitionToTxnResponse* New() const final {
    return new CommandAddPartitionToTxnResponse();
  }

  CommandAddPartitionToTxnResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandAddPartitionToTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandAddPartitionToTxnResponse& from);
  void MergeFrom(const CommandAddPartitionToTxnResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandAddPartitionToTxnResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandAddPartitionToTxnResponse";
  }
  protected:
  explicit CommandAddPartitionToTxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAddPartitionToTxnResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class Subscription final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.Subscription) */ {
 public:
  inline Subscription() : Subscription(nullptr) {}
  ~Subscription() override;
  explicit constexpr Subscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscription(const Subscription& from);
  Subscription(Subscription&& from) noexcept
    : Subscription() {
    *this = ::std::move(from);
  }

  inline Subscription& operator=(const Subscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscription& operator=(Subscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Subscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscription* internal_default_instance() {
    return reinterpret_cast<const Subscription*>(
               &_Subscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(Subscription& a, Subscription& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscription* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Subscription* New() const final {
    return new Subscription();
  }

  Subscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Subscription>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Subscription& from);
  void MergeFrom(const Subscription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Subscription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.Subscription";
  }
  protected:
  explicit Subscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kSubscriptionFieldNumber = 2,
  };
  // required string topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // required string subscription = 2;
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const std::string& subscription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription();
  PROTOBUF_MUST_USE_RESULT std::string* release_subscription();
  void set_allocated_subscription(std::string* subscription);
  private:
  const std::string& _internal_subscription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription(const std::string& value);
  std::string* _internal_mutable_subscription();
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.Subscription)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandAddSubscriptionToTxn final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAddSubscriptionToTxn) */ {
 public:
  inline CommandAddSubscriptionToTxn() : CommandAddSubscriptionToTxn(nullptr) {}
  ~CommandAddSubscriptionToTxn() override;
  explicit constexpr CommandAddSubscriptionToTxn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandAddSubscriptionToTxn(const CommandAddSubscriptionToTxn& from);
  CommandAddSubscriptionToTxn(CommandAddSubscriptionToTxn&& from) noexcept
    : CommandAddSubscriptionToTxn() {
    *this = ::std::move(from);
  }

  inline CommandAddSubscriptionToTxn& operator=(const CommandAddSubscriptionToTxn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAddSubscriptionToTxn& operator=(CommandAddSubscriptionToTxn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAddSubscriptionToTxn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAddSubscriptionToTxn* internal_default_instance() {
    return reinterpret_cast<const CommandAddSubscriptionToTxn*>(
               &_CommandAddSubscriptionToTxn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(CommandAddSubscriptionToTxn& a, CommandAddSubscriptionToTxn& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAddSubscriptionToTxn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAddSubscriptionToTxn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandAddSubscriptionToTxn* New() const final {
    return new CommandAddSubscriptionToTxn();
  }

  CommandAddSubscriptionToTxn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandAddSubscriptionToTxn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandAddSubscriptionToTxn& from);
  void MergeFrom(const CommandAddSubscriptionToTxn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandAddSubscriptionToTxn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandAddSubscriptionToTxn";
  }
  protected:
  explicit CommandAddSubscriptionToTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
  };
  // repeated .pulsar.proto.Subscription subscription = 4;
  int subscription_size() const;
  private:
  int _internal_subscription_size() const;
  public:
  void clear_subscription();
  ::pulsar::proto::Subscription* mutable_subscription(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::Subscription >*
      mutable_subscription();
  private:
  const ::pulsar::proto::Subscription& _internal_subscription(int index) const;
  ::pulsar::proto::Subscription* _internal_add_subscription();
  public:
  const ::pulsar::proto::Subscription& subscription(int index) const;
  ::pulsar::proto::Subscription* add_subscription();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::Subscription >&
      subscription() const;

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAddSubscriptionToTxn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::Subscription > subscription_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandAddSubscriptionToTxnResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAddSubscriptionToTxnResponse) */ {
 public:
  inline CommandAddSubscriptionToTxnResponse() : CommandAddSubscriptionToTxnResponse(nullptr) {}
  ~CommandAddSubscriptionToTxnResponse() override;
  explicit constexpr CommandAddSubscriptionToTxnResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandAddSubscriptionToTxnResponse(const CommandAddSubscriptionToTxnResponse& from);
  CommandAddSubscriptionToTxnResponse(CommandAddSubscriptionToTxnResponse&& from) noexcept
    : CommandAddSubscriptionToTxnResponse() {
    *this = ::std::move(from);
  }

  inline CommandAddSubscriptionToTxnResponse& operator=(const CommandAddSubscriptionToTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAddSubscriptionToTxnResponse& operator=(CommandAddSubscriptionToTxnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAddSubscriptionToTxnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAddSubscriptionToTxnResponse* internal_default_instance() {
    return reinterpret_cast<const CommandAddSubscriptionToTxnResponse*>(
               &_CommandAddSubscriptionToTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(CommandAddSubscriptionToTxnResponse& a, CommandAddSubscriptionToTxnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAddSubscriptionToTxnResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAddSubscriptionToTxnResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandAddSubscriptionToTxnResponse* New() const final {
    return new CommandAddSubscriptionToTxnResponse();
  }

  CommandAddSubscriptionToTxnResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandAddSubscriptionToTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandAddSubscriptionToTxnResponse& from);
  void MergeFrom(const CommandAddSubscriptionToTxnResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandAddSubscriptionToTxnResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandAddSubscriptionToTxnResponse";
  }
  protected:
  explicit CommandAddSubscriptionToTxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAddSubscriptionToTxnResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandEndTxn final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxn) */ {
 public:
  inline CommandEndTxn() : CommandEndTxn(nullptr) {}
  ~CommandEndTxn() override;
  explicit constexpr CommandEndTxn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandEndTxn(const CommandEndTxn& from);
  CommandEndTxn(CommandEndTxn&& from) noexcept
    : CommandEndTxn() {
    *this = ::std::move(from);
  }

  inline CommandEndTxn& operator=(const CommandEndTxn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxn& operator=(CommandEndTxn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxn* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxn*>(
               &_CommandEndTxn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(CommandEndTxn& a, CommandEndTxn& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandEndTxn* New() const final {
    return new CommandEndTxn();
  }

  CommandEndTxn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandEndTxn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxn& from);
  void MergeFrom(const CommandEndTxn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandEndTxn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandEndTxn";
  }
  protected:
  explicit CommandEndTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kTxnActionFieldNumber = 4,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.TxnAction txn_action = 4;
  bool has_txn_action() const;
  private:
  bool _internal_has_txn_action() const;
  public:
  void clear_txn_action();
  ::pulsar::proto::TxnAction txn_action() const;
  void set_txn_action(::pulsar::proto::TxnAction value);
  private:
  ::pulsar::proto::TxnAction _internal_txn_action() const;
  void _internal_set_txn_action(::pulsar::proto::TxnAction value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  int txn_action_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandEndTxnResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnResponse) */ {
 public:
  inline CommandEndTxnResponse() : CommandEndTxnResponse(nullptr) {}
  ~CommandEndTxnResponse() override;
  explicit constexpr CommandEndTxnResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandEndTxnResponse(const CommandEndTxnResponse& from);
  CommandEndTxnResponse(CommandEndTxnResponse&& from) noexcept
    : CommandEndTxnResponse() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnResponse& operator=(const CommandEndTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnResponse& operator=(CommandEndTxnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnResponse* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnResponse*>(
               &_CommandEndTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(CommandEndTxnResponse& a, CommandEndTxnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandEndTxnResponse* New() const final {
    return new CommandEndTxnResponse();
  }

  CommandEndTxnResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandEndTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnResponse& from);
  void MergeFrom(const CommandEndTxnResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandEndTxnResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandEndTxnResponse";
  }
  protected:
  explicit CommandEndTxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandEndTxnOnPartition final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnOnPartition) */ {
 public:
  inline CommandEndTxnOnPartition() : CommandEndTxnOnPartition(nullptr) {}
  ~CommandEndTxnOnPartition() override;
  explicit constexpr CommandEndTxnOnPartition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandEndTxnOnPartition(const CommandEndTxnOnPartition& from);
  CommandEndTxnOnPartition(CommandEndTxnOnPartition&& from) noexcept
    : CommandEndTxnOnPartition() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnOnPartition& operator=(const CommandEndTxnOnPartition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnOnPartition& operator=(CommandEndTxnOnPartition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnOnPartition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnOnPartition* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnOnPartition*>(
               &_CommandEndTxnOnPartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(CommandEndTxnOnPartition& a, CommandEndTxnOnPartition& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnOnPartition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnOnPartition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandEndTxnOnPartition* New() const final {
    return new CommandEndTxnOnPartition();
  }

  CommandEndTxnOnPartition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandEndTxnOnPartition>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnOnPartition& from);
  void MergeFrom(const CommandEndTxnOnPartition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandEndTxnOnPartition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandEndTxnOnPartition";
  }
  protected:
  explicit CommandEndTxnOnPartition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kTxnidLeastBitsOfLowWatermarkFieldNumber = 6,
    kTxnActionFieldNumber = 5,
  };
  // optional string topic = 4;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_MUST_USE_RESULT std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits_of_low_watermark = 6;
  bool has_txnid_least_bits_of_low_watermark() const;
  private:
  bool _internal_has_txnid_least_bits_of_low_watermark() const;
  public:
  void clear_txnid_least_bits_of_low_watermark();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_of_low_watermark() const;
  void set_txnid_least_bits_of_low_watermark(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits_of_low_watermark() const;
  void _internal_set_txnid_least_bits_of_low_watermark(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.TxnAction txn_action = 5;
  bool has_txn_action() const;
  private:
  bool _internal_has_txn_action() const;
  public:
  void clear_txn_action();
  ::pulsar::proto::TxnAction txn_action() const;
  void set_txn_action(::pulsar::proto::TxnAction value);
  private:
  ::pulsar::proto::TxnAction _internal_txn_action() const;
  void _internal_set_txn_action(::pulsar::proto::TxnAction value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnOnPartition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_of_low_watermark_;
  int txn_action_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandEndTxnOnPartitionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnOnPartitionResponse) */ {
 public:
  inline CommandEndTxnOnPartitionResponse() : CommandEndTxnOnPartitionResponse(nullptr) {}
  ~CommandEndTxnOnPartitionResponse() override;
  explicit constexpr CommandEndTxnOnPartitionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandEndTxnOnPartitionResponse(const CommandEndTxnOnPartitionResponse& from);
  CommandEndTxnOnPartitionResponse(CommandEndTxnOnPartitionResponse&& from) noexcept
    : CommandEndTxnOnPartitionResponse() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnOnPartitionResponse& operator=(const CommandEndTxnOnPartitionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnOnPartitionResponse& operator=(CommandEndTxnOnPartitionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnOnPartitionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnOnPartitionResponse* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnOnPartitionResponse*>(
               &_CommandEndTxnOnPartitionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(CommandEndTxnOnPartitionResponse& a, CommandEndTxnOnPartitionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnOnPartitionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnOnPartitionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandEndTxnOnPartitionResponse* New() const final {
    return new CommandEndTxnOnPartitionResponse();
  }

  CommandEndTxnOnPartitionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandEndTxnOnPartitionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnOnPartitionResponse& from);
  void MergeFrom(const CommandEndTxnOnPartitionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandEndTxnOnPartitionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandEndTxnOnPartitionResponse";
  }
  protected:
  explicit CommandEndTxnOnPartitionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnOnPartitionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandEndTxnOnSubscription final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnOnSubscription) */ {
 public:
  inline CommandEndTxnOnSubscription() : CommandEndTxnOnSubscription(nullptr) {}
  ~CommandEndTxnOnSubscription() override;
  explicit constexpr CommandEndTxnOnSubscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandEndTxnOnSubscription(const CommandEndTxnOnSubscription& from);
  CommandEndTxnOnSubscription(CommandEndTxnOnSubscription&& from) noexcept
    : CommandEndTxnOnSubscription() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnOnSubscription& operator=(const CommandEndTxnOnSubscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnOnSubscription& operator=(CommandEndTxnOnSubscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnOnSubscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnOnSubscription* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnOnSubscription*>(
               &_CommandEndTxnOnSubscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(CommandEndTxnOnSubscription& a, CommandEndTxnOnSubscription& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnOnSubscription* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnOnSubscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandEndTxnOnSubscription* New() const final {
    return new CommandEndTxnOnSubscription();
  }

  CommandEndTxnOnSubscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandEndTxnOnSubscription>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnOnSubscription& from);
  void MergeFrom(const CommandEndTxnOnSubscription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandEndTxnOnSubscription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandEndTxnOnSubscription";
  }
  protected:
  explicit CommandEndTxnOnSubscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kTxnidLeastBitsOfLowWatermarkFieldNumber = 6,
    kTxnActionFieldNumber = 5,
  };
  // optional .pulsar.proto.Subscription subscription = 4;
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::pulsar::proto::Subscription& subscription() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::Subscription* release_subscription();
  ::pulsar::proto::Subscription* mutable_subscription();
  void set_allocated_subscription(::pulsar::proto::Subscription* subscription);
  private:
  const ::pulsar::proto::Subscription& _internal_subscription() const;
  ::pulsar::proto::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::pulsar::proto::Subscription* subscription);
  ::pulsar::proto::Subscription* unsafe_arena_release_subscription();

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits_of_low_watermark = 6;
  bool has_txnid_least_bits_of_low_watermark() const;
  private:
  bool _internal_has_txnid_least_bits_of_low_watermark() const;
  public:
  void clear_txnid_least_bits_of_low_watermark();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_of_low_watermark() const;
  void set_txnid_least_bits_of_low_watermark(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits_of_low_watermark() const;
  void _internal_set_txnid_least_bits_of_low_watermark(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.TxnAction txn_action = 5;
  bool has_txn_action() const;
  private:
  bool _internal_has_txn_action() const;
  public:
  void clear_txn_action();
  ::pulsar::proto::TxnAction txn_action() const;
  void set_txn_action(::pulsar::proto::TxnAction value);
  private:
  ::pulsar::proto::TxnAction _internal_txn_action() const;
  void _internal_set_txn_action(::pulsar::proto::TxnAction value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnOnSubscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pulsar::proto::Subscription* subscription_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_of_low_watermark_;
  int txn_action_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class CommandEndTxnOnSubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnOnSubscriptionResponse) */ {
 public:
  inline CommandEndTxnOnSubscriptionResponse() : CommandEndTxnOnSubscriptionResponse(nullptr) {}
  ~CommandEndTxnOnSubscriptionResponse() override;
  explicit constexpr CommandEndTxnOnSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandEndTxnOnSubscriptionResponse(const CommandEndTxnOnSubscriptionResponse& from);
  CommandEndTxnOnSubscriptionResponse(CommandEndTxnOnSubscriptionResponse&& from) noexcept
    : CommandEndTxnOnSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnOnSubscriptionResponse& operator=(const CommandEndTxnOnSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnOnSubscriptionResponse& operator=(CommandEndTxnOnSubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnOnSubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnOnSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnOnSubscriptionResponse*>(
               &_CommandEndTxnOnSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(CommandEndTxnOnSubscriptionResponse& a, CommandEndTxnOnSubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnOnSubscriptionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnOnSubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandEndTxnOnSubscriptionResponse* New() const final {
    return new CommandEndTxnOnSubscriptionResponse();
  }

  CommandEndTxnOnSubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandEndTxnOnSubscriptionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnOnSubscriptionResponse& from);
  void MergeFrom(const CommandEndTxnOnSubscriptionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommandEndTxnOnSubscriptionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.CommandEndTxnOnSubscriptionResponse";
  }
  protected:
  explicit CommandEndTxnOnSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required uint64 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id() const;
  void set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_request_id() const;
  void _internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  private:
  bool _internal_has_txnid_least_bits() const;
  public:
  void clear_txnid_least_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits() const;
  void set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  private:
  bool _internal_has_txnid_most_bits() const;
  public:
  void clear_txnid_most_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits() const;
  void set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);
  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 request_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_least_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txnid_most_bits_;
  int error_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// -------------------------------------------------------------------

class BaseCommand final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.BaseCommand) */ {
 public:
  inline BaseCommand() : BaseCommand(nullptr) {}
  ~BaseCommand() override;
  explicit constexpr BaseCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseCommand(const BaseCommand& from);
  BaseCommand(BaseCommand&& from) noexcept
    : BaseCommand() {
    *this = ::std::move(from);
  }

  inline BaseCommand& operator=(const BaseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseCommand& operator=(BaseCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BaseCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseCommand* internal_default_instance() {
    return reinterpret_cast<const BaseCommand*>(
               &_BaseCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(BaseCommand& a, BaseCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaseCommand* New() const final {
    return new BaseCommand();
  }

  BaseCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaseCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BaseCommand& from);
  void MergeFrom(const BaseCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BaseCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulsar.proto.BaseCommand";
  }
  protected:
  explicit BaseCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BaseCommand_Type Type;
  static constexpr Type CONNECT =
    BaseCommand_Type_CONNECT;
  static constexpr Type CONNECTED =
    BaseCommand_Type_CONNECTED;
  static constexpr Type SUBSCRIBE =
    BaseCommand_Type_SUBSCRIBE;
  static constexpr Type PRODUCER =
    BaseCommand_Type_PRODUCER;
  static constexpr Type SEND =
    BaseCommand_Type_SEND;
  static constexpr Type SEND_RECEIPT =
    BaseCommand_Type_SEND_RECEIPT;
  static constexpr Type SEND_ERROR =
    BaseCommand_Type_SEND_ERROR;
  static constexpr Type MESSAGE =
    BaseCommand_Type_MESSAGE;
  static constexpr Type ACK =
    BaseCommand_Type_ACK;
  static constexpr Type FLOW =
    BaseCommand_Type_FLOW;
  static constexpr Type UNSUBSCRIBE =
    BaseCommand_Type_UNSUBSCRIBE;
  static constexpr Type SUCCESS =
    BaseCommand_Type_SUCCESS;
  static constexpr Type ERROR =
    BaseCommand_Type_ERROR;
  static constexpr Type CLOSE_PRODUCER =
    BaseCommand_Type_CLOSE_PRODUCER;
  static constexpr Type CLOSE_CONSUMER =
    BaseCommand_Type_CLOSE_CONSUMER;
  static constexpr Type PRODUCER_SUCCESS =
    BaseCommand_Type_PRODUCER_SUCCESS;
  static constexpr Type PING =
    BaseCommand_Type_PING;
  static constexpr Type PONG =
    BaseCommand_Type_PONG;
  static constexpr Type REDELIVER_UNACKNOWLEDGED_MESSAGES =
    BaseCommand_Type_REDELIVER_UNACKNOWLEDGED_MESSAGES;
  static constexpr Type PARTITIONED_METADATA =
    BaseCommand_Type_PARTITIONED_METADATA;
  static constexpr Type PARTITIONED_METADATA_RESPONSE =
    BaseCommand_Type_PARTITIONED_METADATA_RESPONSE;
  static constexpr Type LOOKUP =
    BaseCommand_Type_LOOKUP;
  static constexpr Type LOOKUP_RESPONSE =
    BaseCommand_Type_LOOKUP_RESPONSE;
  static constexpr Type CONSUMER_STATS =
    BaseCommand_Type_CONSUMER_STATS;
  static constexpr Type CONSUMER_STATS_RESPONSE =
    BaseCommand_Type_CONSUMER_STATS_RESPONSE;
  static constexpr Type REACHED_END_OF_TOPIC =
    BaseCommand_Type_REACHED_END_OF_TOPIC;
  static constexpr Type SEEK =
    BaseCommand_Type_SEEK;
  static constexpr Type GET_LAST_MESSAGE_ID =
    BaseCommand_Type_GET_LAST_MESSAGE_ID;
  static constexpr Type GET_LAST_MESSAGE_ID_RESPONSE =
    BaseCommand_Type_GET_LAST_MESSAGE_ID_RESPONSE;
  static constexpr Type ACTIVE_CONSUMER_CHANGE =
    BaseCommand_Type_ACTIVE_CONSUMER_CHANGE;
  static constexpr Type GET_TOPICS_OF_NAMESPACE =
    BaseCommand_Type_GET_TOPICS_OF_NAMESPACE;
  static constexpr Type GET_TOPICS_OF_NAMESPACE_RESPONSE =
    BaseCommand_Type_GET_TOPICS_OF_NAMESPACE_RESPONSE;
  static constexpr Type GET_SCHEMA =
    BaseCommand_Type_GET_SCHEMA;
  static constexpr Type GET_SCHEMA_RESPONSE =
    BaseCommand_Type_GET_SCHEMA_RESPONSE;
  static constexpr Type AUTH_CHALLENGE =
    BaseCommand_Type_AUTH_CHALLENGE;
  static constexpr Type AUTH_RESPONSE =
    BaseCommand_Type_AUTH_RESPONSE;
  static constexpr Type ACK_RESPONSE =
    BaseCommand_Type_ACK_RESPONSE;
  static constexpr Type GET_OR_CREATE_SCHEMA =
    BaseCommand_Type_GET_OR_CREATE_SCHEMA;
  static constexpr Type GET_OR_CREATE_SCHEMA_RESPONSE =
    BaseCommand_Type_GET_OR_CREATE_SCHEMA_RESPONSE;
  static constexpr Type NEW_TXN =
    BaseCommand_Type_NEW_TXN;
  static constexpr Type NEW_TXN_RESPONSE =
    BaseCommand_Type_NEW_TXN_RESPONSE;
  static constexpr Type ADD_PARTITION_TO_TXN =
    BaseCommand_Type_ADD_PARTITION_TO_TXN;
  static constexpr Type ADD_PARTITION_TO_TXN_RESPONSE =
    BaseCommand_Type_ADD_PARTITION_TO_TXN_RESPONSE;
  static constexpr Type ADD_SUBSCRIPTION_TO_TXN =
    BaseCommand_Type_ADD_SUBSCRIPTION_TO_TXN;
  static constexpr Type ADD_SUBSCRIPTION_TO_TXN_RESPONSE =
    BaseCommand_Type_ADD_SUBSCRIPTION_TO_TXN_RESPONSE;
  static constexpr Type END_TXN =
    BaseCommand_Type_END_TXN;
  static constexpr Type END_TXN_RESPONSE =
    BaseCommand_Type_END_TXN_RESPONSE;
  static constexpr Type END_TXN_ON_PARTITION =
    BaseCommand_Type_END_TXN_ON_PARTITION;
  static constexpr Type END_TXN_ON_PARTITION_RESPONSE =
    BaseCommand_Type_END_TXN_ON_PARTITION_RESPONSE;
  static constexpr Type END_TXN_ON_SUBSCRIPTION =
    BaseCommand_Type_END_TXN_ON_SUBSCRIPTION;
  static constexpr Type END_TXN_ON_SUBSCRIPTION_RESPONSE =
    BaseCommand_Type_END_TXN_ON_SUBSCRIPTION_RESPONSE;
  static constexpr Type TC_CLIENT_CONNECT_REQUEST =
    BaseCommand_Type_TC_CLIENT_CONNECT_REQUEST;
  static constexpr Type TC_CLIENT_CONNECT_RESPONSE =
    BaseCommand_Type_TC_CLIENT_CONNECT_RESPONSE;
  static constexpr Type WATCH_TOPIC_LIST =
    BaseCommand_Type_WATCH_TOPIC_LIST;
  static constexpr Type WATCH_TOPIC_LIST_SUCCESS =
    BaseCommand_Type_WATCH_TOPIC_LIST_SUCCESS;
  static constexpr Type WATCH_TOPIC_UPDATE =
    BaseCommand_Type_WATCH_TOPIC_UPDATE;
  static constexpr Type WATCH_TOPIC_LIST_CLOSE =
    BaseCommand_Type_WATCH_TOPIC_LIST_CLOSE;
  static constexpr Type TOPIC_MIGRATED =
    BaseCommand_Type_TOPIC_MIGRATED;
  static inline bool Type_IsValid(int value) {
    return BaseCommand_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    BaseCommand_Type_Type_MIN;
  static constexpr Type Type_MAX =
    BaseCommand_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    BaseCommand_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return BaseCommand_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return BaseCommand_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConnectFieldNumber = 2,
    kConnectedFieldNumber = 3,
    kSubscribeFieldNumber = 4,
    kProducerFieldNumber = 5,
    kSendFieldNumber = 6,
    kSendReceiptFieldNumber = 7,
    kSendErrorFieldNumber = 8,
    kMessageFieldNumber = 9,
    kAckFieldNumber = 10,
    kFlowFieldNumber = 11,
    kUnsubscribeFieldNumber = 12,
    kSuccessFieldNumber = 13,
    kErrorFieldNumber = 14,
    kCloseProducerFieldNumber = 15,
    kCloseConsumerFieldNumber = 16,
    kProducerSuccessFieldNumber = 17,
    kPingFieldNumber = 18,
    kPongFieldNumber = 19,
    kRedeliverUnacknowledgedMessagesFieldNumber = 20,
    kPartitionMetadataFieldNumber = 21,
    kPartitionMetadataResponseFieldNumber = 22,
    kLookupTopicFieldNumber = 23,
    kLookupTopicResponseFieldNumber = 24,
    kConsumerStatsFieldNumber = 25,
    kConsumerStatsResponseFieldNumber = 26,
    kReachedEndOfTopicFieldNumber = 27,
    kSeekFieldNumber = 28,
    kGetLastMessageIdFieldNumber = 29,
    kGetLastMessageIdResponseFieldNumber = 30,
    kActiveConsumerChangeFieldNumber = 31,
    kGetTopicsOfNamespaceFieldNumber = 32,
    kGetTopicsOfNamespaceResponseFieldNumber = 33,
    kGetSchemaFieldNumber = 34,
    kGetSchemaResponseFieldNumber = 35,
    kAuthChallengeFieldNumber = 36,
    kAuthResponseFieldNumber = 37,
    kAckResponseFieldNumber = 38,
    kGetOrCreateSchemaFieldNumber = 39,
    kGetOrCreateSchemaResponseFieldNumber = 40,
    kNewTxnFieldNumber = 50,
    kNewTxnResponseFieldNumber = 51,
    kAddPartitionToTxnFieldNumber = 52,
    kAddPartitionToTxnResponseFieldNumber = 53,
    kAddSubscriptionToTxnFieldNumber = 54,
    kAddSubscriptionToTxnResponseFieldNumber = 55,
    kEndTxnFieldNumber = 56,
    kEndTxnResponseFieldNumber = 57,
    kEndTxnOnPartitionFieldNumber = 58,
    kEndTxnOnPartitionResponseFieldNumber = 59,
    kEndTxnOnSubscriptionFieldNumber = 60,
    kEndTxnOnSubscriptionResponseFieldNumber = 61,
    kTcClientConnectRequestFieldNumber = 62,
    kTcClientConnectResponseFieldNumber = 63,
    kWatchTopicListFieldNumber = 64,
    kWatchTopicListSuccessFieldNumber = 65,
    kWatchTopicUpdateFieldNumber = 66,
    kWatchTopicListCloseFieldNumber = 67,
    kTopicMigratedFieldNumber = 68,
    kTypeFieldNumber = 1,
  };
  // optional .pulsar.proto.CommandConnect connect = 2;
  bool has_connect() const;
  private:
  bool _internal_has_connect() const;
  public:
  void clear_connect();
  const ::pulsar::proto::CommandConnect& connect() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandConnect* release_connect();
  ::pulsar::proto::CommandConnect* mutable_connect();
  void set_allocated_connect(::pulsar::proto::CommandConnect* connect);
  private:
  const ::pulsar::proto::CommandConnect& _internal_connect() const;
  ::pulsar::proto::CommandConnect* _internal_mutable_connect();
  public:
  void unsafe_arena_set_allocated_connect(
      ::pulsar::proto::CommandConnect* connect);
  ::pulsar::proto::CommandConnect* unsafe_arena_release_connect();

  // optional .pulsar.proto.CommandConnected connected = 3;
  bool has_connected() const;
  private:
  bool _internal_has_connected() const;
  public:
  void clear_connected();
  const ::pulsar::proto::CommandConnected& connected() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandConnected* release_connected();
  ::pulsar::proto::CommandConnected* mutable_connected();
  void set_allocated_connected(::pulsar::proto::CommandConnected* connected);
  private:
  const ::pulsar::proto::CommandConnected& _internal_connected() const;
  ::pulsar::proto::CommandConnected* _internal_mutable_connected();
  public:
  void unsafe_arena_set_allocated_connected(
      ::pulsar::proto::CommandConnected* connected);
  ::pulsar::proto::CommandConnected* unsafe_arena_release_connected();

  // optional .pulsar.proto.CommandSubscribe subscribe = 4;
  bool has_subscribe() const;
  private:
  bool _internal_has_subscribe() const;
  public:
  void clear_subscribe();
  const ::pulsar::proto::CommandSubscribe& subscribe() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandSubscribe* release_subscribe();
  ::pulsar::proto::CommandSubscribe* mutable_subscribe();
  void set_allocated_subscribe(::pulsar::proto::CommandSubscribe* subscribe);
  private:
  const ::pulsar::proto::CommandSubscribe& _internal_subscribe() const;
  ::pulsar::proto::CommandSubscribe* _internal_mutable_subscribe();
  public:
  void unsafe_arena_set_allocated_subscribe(
      ::pulsar::proto::CommandSubscribe* subscribe);
  ::pulsar::proto::CommandSubscribe* unsafe_arena_release_subscribe();

  // optional .pulsar.proto.CommandProducer producer = 5;
  bool has_producer() const;
  private:
  bool _internal_has_producer() const;
  public:
  void clear_producer();
  const ::pulsar::proto::CommandProducer& producer() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandProducer* release_producer();
  ::pulsar::proto::CommandProducer* mutable_producer();
  void set_allocated_producer(::pulsar::proto::CommandProducer* producer);
  private:
  const ::pulsar::proto::CommandProducer& _internal_producer() const;
  ::pulsar::proto::CommandProducer* _internal_mutable_producer();
  public:
  void unsafe_arena_set_allocated_producer(
      ::pulsar::proto::CommandProducer* producer);
  ::pulsar::proto::CommandProducer* unsafe_arena_release_producer();

  // optional .pulsar.proto.CommandSend send = 6;
  bool has_send() const;
  private:
  bool _internal_has_send() const;
  public:
  void clear_send();
  const ::pulsar::proto::CommandSend& send() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandSend* release_send();
  ::pulsar::proto::CommandSend* mutable_send();
  void set_allocated_send(::pulsar::proto::CommandSend* send);
  private:
  const ::pulsar::proto::CommandSend& _internal_send() const;
  ::pulsar::proto::CommandSend* _internal_mutable_send();
  public:
  void unsafe_arena_set_allocated_send(
      ::pulsar::proto::CommandSend* send);
  ::pulsar::proto::CommandSend* unsafe_arena_release_send();

  // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
  bool has_send_receipt() const;
  private:
  bool _internal_has_send_receipt() const;
  public:
  void clear_send_receipt();
  const ::pulsar::proto::CommandSendReceipt& send_receipt() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandSendReceipt* release_send_receipt();
  ::pulsar::proto::CommandSendReceipt* mutable_send_receipt();
  void set_allocated_send_receipt(::pulsar::proto::CommandSendReceipt* send_receipt);
  private:
  const ::pulsar::proto::CommandSendReceipt& _internal_send_receipt() const;
  ::pulsar::proto::CommandSendReceipt* _internal_mutable_send_receipt();
  public:
  void unsafe_arena_set_allocated_send_receipt(
      ::pulsar::proto::CommandSendReceipt* send_receipt);
  ::pulsar::proto::CommandSendReceipt* unsafe_arena_release_send_receipt();

  // optional .pulsar.proto.CommandSendError send_error = 8;
  bool has_send_error() const;
  private:
  bool _internal_has_send_error() const;
  public:
  void clear_send_error();
  const ::pulsar::proto::CommandSendError& send_error() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandSendError* release_send_error();
  ::pulsar::proto::CommandSendError* mutable_send_error();
  void set_allocated_send_error(::pulsar::proto::CommandSendError* send_error);
  private:
  const ::pulsar::proto::CommandSendError& _internal_send_error() const;
  ::pulsar::proto::CommandSendError* _internal_mutable_send_error();
  public:
  void unsafe_arena_set_allocated_send_error(
      ::pulsar::proto::CommandSendError* send_error);
  ::pulsar::proto::CommandSendError* unsafe_arena_release_send_error();

  // optional .pulsar.proto.CommandMessage message = 9;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::pulsar::proto::CommandMessage& message() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandMessage* release_message();
  ::pulsar::proto::CommandMessage* mutable_message();
  void set_allocated_message(::pulsar::proto::CommandMessage* message);
  private:
  const ::pulsar::proto::CommandMessage& _internal_message() const;
  ::pulsar::proto::CommandMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::pulsar::proto::CommandMessage* message);
  ::pulsar::proto::CommandMessage* unsafe_arena_release_message();

  // optional .pulsar.proto.CommandAck ack = 10;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  const ::pulsar::proto::CommandAck& ack() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandAck* release_ack();
  ::pulsar::proto::CommandAck* mutable_ack();
  void set_allocated_ack(::pulsar::proto::CommandAck* ack);
  private:
  const ::pulsar::proto::CommandAck& _internal_ack() const;
  ::pulsar::proto::CommandAck* _internal_mutable_ack();
  public:
  void unsafe_arena_set_allocated_ack(
      ::pulsar::proto::CommandAck* ack);
  ::pulsar::proto::CommandAck* unsafe_arena_release_ack();

  // optional .pulsar.proto.CommandFlow flow = 11;
  bool has_flow() const;
  private:
  bool _internal_has_flow() const;
  public:
  void clear_flow();
  const ::pulsar::proto::CommandFlow& flow() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandFlow* release_flow();
  ::pulsar::proto::CommandFlow* mutable_flow();
  void set_allocated_flow(::pulsar::proto::CommandFlow* flow);
  private:
  const ::pulsar::proto::CommandFlow& _internal_flow() const;
  ::pulsar::proto::CommandFlow* _internal_mutable_flow();
  public:
  void unsafe_arena_set_allocated_flow(
      ::pulsar::proto::CommandFlow* flow);
  ::pulsar::proto::CommandFlow* unsafe_arena_release_flow();

  // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
  bool has_unsubscribe() const;
  private:
  bool _internal_has_unsubscribe() const;
  public:
  void clear_unsubscribe();
  const ::pulsar::proto::CommandUnsubscribe& unsubscribe() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandUnsubscribe* release_unsubscribe();
  ::pulsar::proto::CommandUnsubscribe* mutable_unsubscribe();
  void set_allocated_unsubscribe(::pulsar::proto::CommandUnsubscribe* unsubscribe);
  private:
  const ::pulsar::proto::CommandUnsubscribe& _internal_unsubscribe() const;
  ::pulsar::proto::CommandUnsubscribe* _internal_mutable_unsubscribe();
  public:
  void unsafe_arena_set_allocated_unsubscribe(
      ::pulsar::proto::CommandUnsubscribe* unsubscribe);
  ::pulsar::proto::CommandUnsubscribe* unsafe_arena_release_unsubscribe();

  // optional .pulsar.proto.CommandSuccess success = 13;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  const ::pulsar::proto::CommandSuccess& success() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandSuccess* release_success();
  ::pulsar::proto::CommandSuccess* mutable_success();
  void set_allocated_success(::pulsar::proto::CommandSuccess* success);
  private:
  const ::pulsar::proto::CommandSuccess& _internal_success() const;
  ::pulsar::proto::CommandSuccess* _internal_mutable_success();
  public:
  void unsafe_arena_set_allocated_success(
      ::pulsar::proto::CommandSuccess* success);
  ::pulsar::proto::CommandSuccess* unsafe_arena_release_success();

  // optional .pulsar.proto.CommandError error = 14;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::pulsar::proto::CommandError& error() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandError* release_error();
  ::pulsar::proto::CommandError* mutable_error();
  void set_allocated_error(::pulsar::proto::CommandError* error);
  private:
  const ::pulsar::proto::CommandError& _internal_error() const;
  ::pulsar::proto::CommandError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::pulsar::proto::CommandError* error);
  ::pulsar::proto::CommandError* unsafe_arena_release_error();

  // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
  bool has_close_producer() const;
  private:
  bool _internal_has_close_producer() const;
  public:
  void clear_close_producer();
  const ::pulsar::proto::CommandCloseProducer& close_producer() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandCloseProducer* release_close_producer();
  ::pulsar::proto::CommandCloseProducer* mutable_close_producer();
  void set_allocated_close_producer(::pulsar::proto::CommandCloseProducer* close_producer);
  private:
  const ::pulsar::proto::CommandCloseProducer& _internal_close_producer() const;
  ::pulsar::proto::CommandCloseProducer* _internal_mutable_close_producer();
  public:
  void unsafe_arena_set_allocated_close_producer(
      ::pulsar::proto::CommandCloseProducer* close_producer);
  ::pulsar::proto::CommandCloseProducer* unsafe_arena_release_close_producer();

  // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
  bool has_close_consumer() const;
  private:
  bool _internal_has_close_consumer() const;
  public:
  void clear_close_consumer();
  const ::pulsar::proto::CommandCloseConsumer& close_consumer() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandCloseConsumer* release_close_consumer();
  ::pulsar::proto::CommandCloseConsumer* mutable_close_consumer();
  void set_allocated_close_consumer(::pulsar::proto::CommandCloseConsumer* close_consumer);
  private:
  const ::pulsar::proto::CommandCloseConsumer& _internal_close_consumer() const;
  ::pulsar::proto::CommandCloseConsumer* _internal_mutable_close_consumer();
  public:
  void unsafe_arena_set_allocated_close_consumer(
      ::pulsar::proto::CommandCloseConsumer* close_consumer);
  ::pulsar::proto::CommandCloseConsumer* unsafe_arena_release_close_consumer();

  // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
  bool has_producer_success() const;
  private:
  bool _internal_has_producer_success() const;
  public:
  void clear_producer_success();
  const ::pulsar::proto::CommandProducerSuccess& producer_success() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandProducerSuccess* release_producer_success();
  ::pulsar::proto::CommandProducerSuccess* mutable_producer_success();
  void set_allocated_producer_success(::pulsar::proto::CommandProducerSuccess* producer_success);
  private:
  const ::pulsar::proto::CommandProducerSuccess& _internal_producer_success() const;
  ::pulsar::proto::CommandProducerSuccess* _internal_mutable_producer_success();
  public:
  void unsafe_arena_set_allocated_producer_success(
      ::pulsar::proto::CommandProducerSuccess* producer_success);
  ::pulsar::proto::CommandProducerSuccess* unsafe_arena_release_producer_success();

  // optional .pulsar.proto.CommandPing ping = 18;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::pulsar::proto::CommandPing& ping() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandPing* release_ping();
  ::pulsar::proto::CommandPing* mutable_ping();
  void set_allocated_ping(::pulsar::proto::CommandPing* ping);
  private:
  const ::pulsar::proto::CommandPing& _internal_ping() const;
  ::pulsar::proto::CommandPing* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::pulsar::proto::CommandPing* ping);
  ::pulsar::proto::CommandPing* unsafe_arena_release_ping();

  // optional .pulsar.proto.CommandPong pong = 19;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;
  public:
  void clear_pong();
  const ::pulsar::proto::CommandPong& pong() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandPong* release_pong();
  ::pulsar::proto::CommandPong* mutable_pong();
  void set_allocated_pong(::pulsar::proto::CommandPong* pong);
  private:
  const ::pulsar::proto::CommandPong& _internal_pong() const;
  ::pulsar::proto::CommandPong* _internal_mutable_pong();
  public:
  void unsafe_arena_set_allocated_pong(
      ::pulsar::proto::CommandPong* pong);
  ::pulsar::proto::CommandPong* unsafe_arena_release_pong();

  // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
  bool has_redeliverunacknowledgedmessages() const;
  private:
  bool _internal_has_redeliverunacknowledgedmessages() const;
  public:
  void clear_redeliverunacknowledgedmessages();
  const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& redeliverunacknowledgedmessages() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* release_redeliverunacknowledgedmessages();
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* mutable_redeliverunacknowledgedmessages();
  void set_allocated_redeliverunacknowledgedmessages(::pulsar::proto::CommandRedeliverUnacknowledgedMessages* redeliverunacknowledgedmessages);
  private:
  const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& _internal_redeliverunacknowledgedmessages() const;
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* _internal_mutable_redeliverunacknowledgedmessages();
  public:
  void unsafe_arena_set_allocated_redeliverunacknowledgedmessages(
      ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* redeliverunacknowledgedmessages);
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* unsafe_arena_release_redeliverunacknowledgedmessages();

  // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
  bool has_partitionmetadata() const;
  private:
  bool _internal_has_partitionmetadata() const;
  public:
  void clear_partitionmetadata();
  const ::pulsar::proto::CommandPartitionedTopicMetadata& partitionmetadata() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandPartitionedTopicMetadata* release_partitionmetadata();
  ::pulsar::proto::CommandPartitionedTopicMetadata* mutable_partitionmetadata();
  void set_allocated_partitionmetadata(::pulsar::proto::CommandPartitionedTopicMetadata* partitionmetadata);
  private:
  const ::pulsar::proto::CommandPartitionedTopicMetadata& _internal_partitionmetadata() const;
  ::pulsar::proto::CommandPartitionedTopicMetadata* _internal_mutable_partitionmetadata();
  public:
  void unsafe_arena_set_allocated_partitionmetadata(
      ::pulsar::proto::CommandPartitionedTopicMetadata* partitionmetadata);
  ::pulsar::proto::CommandPartitionedTopicMetadata* unsafe_arena_release_partitionmetadata();

  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
  bool has_partitionmetadataresponse() const;
  private:
  bool _internal_has_partitionmetadataresponse() const;
  public:
  void clear_partitionmetadataresponse();
  const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& partitionmetadataresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandPartitionedTopicMetadataResponse* release_partitionmetadataresponse();
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* mutable_partitionmetadataresponse();
  void set_allocated_partitionmetadataresponse(::pulsar::proto::CommandPartitionedTopicMetadataResponse* partitionmetadataresponse);
  private:
  const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& _internal_partitionmetadataresponse() const;
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* _internal_mutable_partitionmetadataresponse();
  public:
  void unsafe_arena_set_allocated_partitionmetadataresponse(
      ::pulsar::proto::CommandPartitionedTopicMetadataResponse* partitionmetadataresponse);
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* unsafe_arena_release_partitionmetadataresponse();

  // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
  bool has_lookuptopic() const;
  private:
  bool _internal_has_lookuptopic() const;
  public:
  void clear_lookuptopic();
  const ::pulsar::proto::CommandLookupTopic& lookuptopic() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandLookupTopic* release_lookuptopic();
  ::pulsar::proto::CommandLookupTopic* mutable_lookuptopic();
  void set_allocated_lookuptopic(::pulsar::proto::CommandLookupTopic* lookuptopic);
  private:
  const ::pulsar::proto::CommandLookupTopic& _internal_lookuptopic() const;
  ::pulsar::proto::CommandLookupTopic* _internal_mutable_lookuptopic();
  public:
  void unsafe_arena_set_allocated_lookuptopic(
      ::pulsar::proto::CommandLookupTopic* lookuptopic);
  ::pulsar::proto::CommandLookupTopic* unsafe_arena_release_lookuptopic();

  // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
  bool has_lookuptopicresponse() const;
  private:
  bool _internal_has_lookuptopicresponse() const;
  public:
  void clear_lookuptopicresponse();
  const ::pulsar::proto::CommandLookupTopicResponse& lookuptopicresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandLookupTopicResponse* release_lookuptopicresponse();
  ::pulsar::proto::CommandLookupTopicResponse* mutable_lookuptopicresponse();
  void set_allocated_lookuptopicresponse(::pulsar::proto::CommandLookupTopicResponse* lookuptopicresponse);
  private:
  const ::pulsar::proto::CommandLookupTopicResponse& _internal_lookuptopicresponse() const;
  ::pulsar::proto::CommandLookupTopicResponse* _internal_mutable_lookuptopicresponse();
  public:
  void unsafe_arena_set_allocated_lookuptopicresponse(
      ::pulsar::proto::CommandLookupTopicResponse* lookuptopicresponse);
  ::pulsar::proto::CommandLookupTopicResponse* unsafe_arena_release_lookuptopicresponse();

  // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
  bool has_consumerstats() const;
  private:
  bool _internal_has_consumerstats() const;
  public:
  void clear_consumerstats();
  const ::pulsar::proto::CommandConsumerStats& consumerstats() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandConsumerStats* release_consumerstats();
  ::pulsar::proto::CommandConsumerStats* mutable_consumerstats();
  void set_allocated_consumerstats(::pulsar::proto::CommandConsumerStats* consumerstats);
  private:
  const ::pulsar::proto::CommandConsumerStats& _internal_consumerstats() const;
  ::pulsar::proto::CommandConsumerStats* _internal_mutable_consumerstats();
  public:
  void unsafe_arena_set_allocated_consumerstats(
      ::pulsar::proto::CommandConsumerStats* consumerstats);
  ::pulsar::proto::CommandConsumerStats* unsafe_arena_release_consumerstats();

  // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
  bool has_consumerstatsresponse() const;
  private:
  bool _internal_has_consumerstatsresponse() const;
  public:
  void clear_consumerstatsresponse();
  const ::pulsar::proto::CommandConsumerStatsResponse& consumerstatsresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandConsumerStatsResponse* release_consumerstatsresponse();
  ::pulsar::proto::CommandConsumerStatsResponse* mutable_consumerstatsresponse();
  void set_allocated_consumerstatsresponse(::pulsar::proto::CommandConsumerStatsResponse* consumerstatsresponse);
  private:
  const ::pulsar::proto::CommandConsumerStatsResponse& _internal_consumerstatsresponse() const;
  ::pulsar::proto::CommandConsumerStatsResponse* _internal_mutable_consumerstatsresponse();
  public:
  void unsafe_arena_set_allocated_consumerstatsresponse(
      ::pulsar::proto::CommandConsumerStatsResponse* consumerstatsresponse);
  ::pulsar::proto::CommandConsumerStatsResponse* unsafe_arena_release_consumerstatsresponse();

  // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
  bool has_reachedendoftopic() const;
  private:
  bool _internal_has_reachedendoftopic() const;
  public:
  void clear_reachedendoftopic();
  const ::pulsar::proto::CommandReachedEndOfTopic& reachedendoftopic() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandReachedEndOfTopic* release_reachedendoftopic();
  ::pulsar::proto::CommandReachedEndOfTopic* mutable_reachedendoftopic();
  void set_allocated_reachedendoftopic(::pulsar::proto::CommandReachedEndOfTopic* reachedendoftopic);
  private:
  const ::pulsar::proto::CommandReachedEndOfTopic& _internal_reachedendoftopic() const;
  ::pulsar::proto::CommandReachedEndOfTopic* _internal_mutable_reachedendoftopic();
  public:
  void unsafe_arena_set_allocated_reachedendoftopic(
      ::pulsar::proto::CommandReachedEndOfTopic* reachedendoftopic);
  ::pulsar::proto::CommandReachedEndOfTopic* unsafe_arena_release_reachedendoftopic();

  // optional .pulsar.proto.CommandSeek seek = 28;
  bool has_seek() const;
  private:
  bool _internal_has_seek() const;
  public:
  void clear_seek();
  const ::pulsar::proto::CommandSeek& seek() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandSeek* release_seek();
  ::pulsar::proto::CommandSeek* mutable_seek();
  void set_allocated_seek(::pulsar::proto::CommandSeek* seek);
  private:
  const ::pulsar::proto::CommandSeek& _internal_seek() const;
  ::pulsar::proto::CommandSeek* _internal_mutable_seek();
  public:
  void unsafe_arena_set_allocated_seek(
      ::pulsar::proto::CommandSeek* seek);
  ::pulsar::proto::CommandSeek* unsafe_arena_release_seek();

  // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
  bool has_getlastmessageid() const;
  private:
  bool _internal_has_getlastmessageid() const;
  public:
  void clear_getlastmessageid();
  const ::pulsar::proto::CommandGetLastMessageId& getlastmessageid() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandGetLastMessageId* release_getlastmessageid();
  ::pulsar::proto::CommandGetLastMessageId* mutable_getlastmessageid();
  void set_allocated_getlastmessageid(::pulsar::proto::CommandGetLastMessageId* getlastmessageid);
  private:
  const ::pulsar::proto::CommandGetLastMessageId& _internal_getlastmessageid() const;
  ::pulsar::proto::CommandGetLastMessageId* _internal_mutable_getlastmessageid();
  public:
  void unsafe_arena_set_allocated_getlastmessageid(
      ::pulsar::proto::CommandGetLastMessageId* getlastmessageid);
  ::pulsar::proto::CommandGetLastMessageId* unsafe_arena_release_getlastmessageid();

  // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
  bool has_getlastmessageidresponse() const;
  private:
  bool _internal_has_getlastmessageidresponse() const;
  public:
  void clear_getlastmessageidresponse();
  const ::pulsar::proto::CommandGetLastMessageIdResponse& getlastmessageidresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandGetLastMessageIdResponse* release_getlastmessageidresponse();
  ::pulsar::proto::CommandGetLastMessageIdResponse* mutable_getlastmessageidresponse();
  void set_allocated_getlastmessageidresponse(::pulsar::proto::CommandGetLastMessageIdResponse* getlastmessageidresponse);
  private:
  const ::pulsar::proto::CommandGetLastMessageIdResponse& _internal_getlastmessageidresponse() const;
  ::pulsar::proto::CommandGetLastMessageIdResponse* _internal_mutable_getlastmessageidresponse();
  public:
  void unsafe_arena_set_allocated_getlastmessageidresponse(
      ::pulsar::proto::CommandGetLastMessageIdResponse* getlastmessageidresponse);
  ::pulsar::proto::CommandGetLastMessageIdResponse* unsafe_arena_release_getlastmessageidresponse();

  // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
  bool has_active_consumer_change() const;
  private:
  bool _internal_has_active_consumer_change() const;
  public:
  void clear_active_consumer_change();
  const ::pulsar::proto::CommandActiveConsumerChange& active_consumer_change() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandActiveConsumerChange* release_active_consumer_change();
  ::pulsar::proto::CommandActiveConsumerChange* mutable_active_consumer_change();
  void set_allocated_active_consumer_change(::pulsar::proto::CommandActiveConsumerChange* active_consumer_change);
  private:
  const ::pulsar::proto::CommandActiveConsumerChange& _internal_active_consumer_change() const;
  ::pulsar::proto::CommandActiveConsumerChange* _internal_mutable_active_consumer_change();
  public:
  void unsafe_arena_set_allocated_active_consumer_change(
      ::pulsar::proto::CommandActiveConsumerChange* active_consumer_change);
  ::pulsar::proto::CommandActiveConsumerChange* unsafe_arena_release_active_consumer_change();

  // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
  bool has_gettopicsofnamespace() const;
  private:
  bool _internal_has_gettopicsofnamespace() const;
  public:
  void clear_gettopicsofnamespace();
  const ::pulsar::proto::CommandGetTopicsOfNamespace& gettopicsofnamespace() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandGetTopicsOfNamespace* release_gettopicsofnamespace();
  ::pulsar::proto::CommandGetTopicsOfNamespace* mutable_gettopicsofnamespace();
  void set_allocated_gettopicsofnamespace(::pulsar::proto::CommandGetTopicsOfNamespace* gettopicsofnamespace);
  private:
  const ::pulsar::proto::CommandGetTopicsOfNamespace& _internal_gettopicsofnamespace() const;
  ::pulsar::proto::CommandGetTopicsOfNamespace* _internal_mutable_gettopicsofnamespace();
  public:
  void unsafe_arena_set_allocated_gettopicsofnamespace(
      ::pulsar::proto::CommandGetTopicsOfNamespace* gettopicsofnamespace);
  ::pulsar::proto::CommandGetTopicsOfNamespace* unsafe_arena_release_gettopicsofnamespace();

  // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
  bool has_gettopicsofnamespaceresponse() const;
  private:
  bool _internal_has_gettopicsofnamespaceresponse() const;
  public:
  void clear_gettopicsofnamespaceresponse();
  const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& gettopicsofnamespaceresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* release_gettopicsofnamespaceresponse();
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* mutable_gettopicsofnamespaceresponse();
  void set_allocated_gettopicsofnamespaceresponse(::pulsar::proto::CommandGetTopicsOfNamespaceResponse* gettopicsofnamespaceresponse);
  private:
  const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& _internal_gettopicsofnamespaceresponse() const;
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* _internal_mutable_gettopicsofnamespaceresponse();
  public:
  void unsafe_arena_set_allocated_gettopicsofnamespaceresponse(
      ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* gettopicsofnamespaceresponse);
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* unsafe_arena_release_gettopicsofnamespaceresponse();

  // optional .pulsar.proto.CommandGetSchema getSchema = 34;
  bool has_getschema() const;
  private:
  bool _internal_has_getschema() const;
  public:
  void clear_getschema();
  const ::pulsar::proto::CommandGetSchema& getschema() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandGetSchema* release_getschema();
  ::pulsar::proto::CommandGetSchema* mutable_getschema();
  void set_allocated_getschema(::pulsar::proto::CommandGetSchema* getschema);
  private:
  const ::pulsar::proto::CommandGetSchema& _internal_getschema() const;
  ::pulsar::proto::CommandGetSchema* _internal_mutable_getschema();
  public:
  void unsafe_arena_set_allocated_getschema(
      ::pulsar::proto::CommandGetSchema* getschema);
  ::pulsar::proto::CommandGetSchema* unsafe_arena_release_getschema();

  // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
  bool has_getschemaresponse() const;
  private:
  bool _internal_has_getschemaresponse() const;
  public:
  void clear_getschemaresponse();
  const ::pulsar::proto::CommandGetSchemaResponse& getschemaresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandGetSchemaResponse* release_getschemaresponse();
  ::pulsar::proto::CommandGetSchemaResponse* mutable_getschemaresponse();
  void set_allocated_getschemaresponse(::pulsar::proto::CommandGetSchemaResponse* getschemaresponse);
  private:
  const ::pulsar::proto::CommandGetSchemaResponse& _internal_getschemaresponse() const;
  ::pulsar::proto::CommandGetSchemaResponse* _internal_mutable_getschemaresponse();
  public:
  void unsafe_arena_set_allocated_getschemaresponse(
      ::pulsar::proto::CommandGetSchemaResponse* getschemaresponse);
  ::pulsar::proto::CommandGetSchemaResponse* unsafe_arena_release_getschemaresponse();

  // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
  bool has_authchallenge() const;
  private:
  bool _internal_has_authchallenge() const;
  public:
  void clear_authchallenge();
  const ::pulsar::proto::CommandAuthChallenge& authchallenge() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandAuthChallenge* release_authchallenge();
  ::pulsar::proto::CommandAuthChallenge* mutable_authchallenge();
  void set_allocated_authchallenge(::pulsar::proto::CommandAuthChallenge* authchallenge);
  private:
  const ::pulsar::proto::CommandAuthChallenge& _internal_authchallenge() const;
  ::pulsar::proto::CommandAuthChallenge* _internal_mutable_authchallenge();
  public:
  void unsafe_arena_set_allocated_authchallenge(
      ::pulsar::proto::CommandAuthChallenge* authchallenge);
  ::pulsar::proto::CommandAuthChallenge* unsafe_arena_release_authchallenge();

  // optional .pulsar.proto.CommandAuthResponse authResponse = 37;
  bool has_authresponse() const;
  private:
  bool _internal_has_authresponse() const;
  public:
  void clear_authresponse();
  const ::pulsar::proto::CommandAuthResponse& authresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandAuthResponse* release_authresponse();
  ::pulsar::proto::CommandAuthResponse* mutable_authresponse();
  void set_allocated_authresponse(::pulsar::proto::CommandAuthResponse* authresponse);
  private:
  const ::pulsar::proto::CommandAuthResponse& _internal_authresponse() const;
  ::pulsar::proto::CommandAuthResponse* _internal_mutable_authresponse();
  public:
  void unsafe_arena_set_allocated_authresponse(
      ::pulsar::proto::CommandAuthResponse* authresponse);
  ::pulsar::proto::CommandAuthResponse* unsafe_arena_release_authresponse();

  // optional .pulsar.proto.CommandAckResponse ackResponse = 38;
  bool has_ackresponse() const;
  private:
  bool _internal_has_ackresponse() const;
  public:
  void clear_ackresponse();
  const ::pulsar::proto::CommandAckResponse& ackresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandAckResponse* release_ackresponse();
  ::pulsar::proto::CommandAckResponse* mutable_ackresponse();
  void set_allocated_ackresponse(::pulsar::proto::CommandAckResponse* ackresponse);
  private:
  const ::pulsar::proto::CommandAckResponse& _internal_ackresponse() const;
  ::pulsar::proto::CommandAckResponse* _internal_mutable_ackresponse();
  public:
  void unsafe_arena_set_allocated_ackresponse(
      ::pulsar::proto::CommandAckResponse* ackresponse);
  ::pulsar::proto::CommandAckResponse* unsafe_arena_release_ackresponse();

  // optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
  bool has_getorcreateschema() const;
  private:
  bool _internal_has_getorcreateschema() const;
  public:
  void clear_getorcreateschema();
  const ::pulsar::proto::CommandGetOrCreateSchema& getorcreateschema() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandGetOrCreateSchema* release_getorcreateschema();
  ::pulsar::proto::CommandGetOrCreateSchema* mutable_getorcreateschema();
  void set_allocated_getorcreateschema(::pulsar::proto::CommandGetOrCreateSchema* getorcreateschema);
  private:
  const ::pulsar::proto::CommandGetOrCreateSchema& _internal_getorcreateschema() const;
  ::pulsar::proto::CommandGetOrCreateSchema* _internal_mutable_getorcreateschema();
  public:
  void unsafe_arena_set_allocated_getorcreateschema(
      ::pulsar::proto::CommandGetOrCreateSchema* getorcreateschema);
  ::pulsar::proto::CommandGetOrCreateSchema* unsafe_arena_release_getorcreateschema();

  // optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
  bool has_getorcreateschemaresponse() const;
  private:
  bool _internal_has_getorcreateschemaresponse() const;
  public:
  void clear_getorcreateschemaresponse();
  const ::pulsar::proto::CommandGetOrCreateSchemaResponse& getorcreateschemaresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandGetOrCreateSchemaResponse* release_getorcreateschemaresponse();
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* mutable_getorcreateschemaresponse();
  void set_allocated_getorcreateschemaresponse(::pulsar::proto::CommandGetOrCreateSchemaResponse* getorcreateschemaresponse);
  private:
  const ::pulsar::proto::CommandGetOrCreateSchemaResponse& _internal_getorcreateschemaresponse() const;
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* _internal_mutable_getorcreateschemaresponse();
  public:
  void unsafe_arena_set_allocated_getorcreateschemaresponse(
      ::pulsar::proto::CommandGetOrCreateSchemaResponse* getorcreateschemaresponse);
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* unsafe_arena_release_getorcreateschemaresponse();

  // optional .pulsar.proto.CommandNewTxn newTxn = 50;
  bool has_newtxn() const;
  private:
  bool _internal_has_newtxn() const;
  public:
  void clear_newtxn();
  const ::pulsar::proto::CommandNewTxn& newtxn() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandNewTxn* release_newtxn();
  ::pulsar::proto::CommandNewTxn* mutable_newtxn();
  void set_allocated_newtxn(::pulsar::proto::CommandNewTxn* newtxn);
  private:
  const ::pulsar::proto::CommandNewTxn& _internal_newtxn() const;
  ::pulsar::proto::CommandNewTxn* _internal_mutable_newtxn();
  public:
  void unsafe_arena_set_allocated_newtxn(
      ::pulsar::proto::CommandNewTxn* newtxn);
  ::pulsar::proto::CommandNewTxn* unsafe_arena_release_newtxn();

  // optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
  bool has_newtxnresponse() const;
  private:
  bool _internal_has_newtxnresponse() const;
  public:
  void clear_newtxnresponse();
  const ::pulsar::proto::CommandNewTxnResponse& newtxnresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandNewTxnResponse* release_newtxnresponse();
  ::pulsar::proto::CommandNewTxnResponse* mutable_newtxnresponse();
  void set_allocated_newtxnresponse(::pulsar::proto::CommandNewTxnResponse* newtxnresponse);
  private:
  const ::pulsar::proto::CommandNewTxnResponse& _internal_newtxnresponse() const;
  ::pulsar::proto::CommandNewTxnResponse* _internal_mutable_newtxnresponse();
  public:
  void unsafe_arena_set_allocated_newtxnresponse(
      ::pulsar::proto::CommandNewTxnResponse* newtxnresponse);
  ::pulsar::proto::CommandNewTxnResponse* unsafe_arena_release_newtxnresponse();

  // optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
  bool has_addpartitiontotxn() const;
  private:
  bool _internal_has_addpartitiontotxn() const;
  public:
  void clear_addpartitiontotxn();
  const ::pulsar::proto::CommandAddPartitionToTxn& addpartitiontotxn() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandAddPartitionToTxn* release_addpartitiontotxn();
  ::pulsar::proto::CommandAddPartitionToTxn* mutable_addpartitiontotxn();
  void set_allocated_addpartitiontotxn(::pulsar::proto::CommandAddPartitionToTxn* addpartitiontotxn);
  private:
  const ::pulsar::proto::CommandAddPartitionToTxn& _internal_addpartitiontotxn() const;
  ::pulsar::proto::CommandAddPartitionToTxn* _internal_mutable_addpartitiontotxn();
  public:
  void unsafe_arena_set_allocated_addpartitiontotxn(
      ::pulsar::proto::CommandAddPartitionToTxn* addpartitiontotxn);
  ::pulsar::proto::CommandAddPartitionToTxn* unsafe_arena_release_addpartitiontotxn();

  // optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
  bool has_addpartitiontotxnresponse() const;
  private:
  bool _internal_has_addpartitiontotxnresponse() const;
  public:
  void clear_addpartitiontotxnresponse();
  const ::pulsar::proto::CommandAddPartitionToTxnResponse& addpartitiontotxnresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandAddPartitionToTxnResponse* release_addpartitiontotxnresponse();
  ::pulsar::proto::CommandAddPartitionToTxnResponse* mutable_addpartitiontotxnresponse();
  void set_allocated_addpartitiontotxnresponse(::pulsar::proto::CommandAddPartitionToTxnResponse* addpartitiontotxnresponse);
  private:
  const ::pulsar::proto::CommandAddPartitionToTxnResponse& _internal_addpartitiontotxnresponse() const;
  ::pulsar::proto::CommandAddPartitionToTxnResponse* _internal_mutable_addpartitiontotxnresponse();
  public:
  void unsafe_arena_set_allocated_addpartitiontotxnresponse(
      ::pulsar::proto::CommandAddPartitionToTxnResponse* addpartitiontotxnresponse);
  ::pulsar::proto::CommandAddPartitionToTxnResponse* unsafe_arena_release_addpartitiontotxnresponse();

  // optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
  bool has_addsubscriptiontotxn() const;
  private:
  bool _internal_has_addsubscriptiontotxn() const;
  public:
  void clear_addsubscriptiontotxn();
  const ::pulsar::proto::CommandAddSubscriptionToTxn& addsubscriptiontotxn() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandAddSubscriptionToTxn* release_addsubscriptiontotxn();
  ::pulsar::proto::CommandAddSubscriptionToTxn* mutable_addsubscriptiontotxn();
  void set_allocated_addsubscriptiontotxn(::pulsar::proto::CommandAddSubscriptionToTxn* addsubscriptiontotxn);
  private:
  const ::pulsar::proto::CommandAddSubscriptionToTxn& _internal_addsubscriptiontotxn() const;
  ::pulsar::proto::CommandAddSubscriptionToTxn* _internal_mutable_addsubscriptiontotxn();
  public:
  void unsafe_arena_set_allocated_addsubscriptiontotxn(
      ::pulsar::proto::CommandAddSubscriptionToTxn* addsubscriptiontotxn);
  ::pulsar::proto::CommandAddSubscriptionToTxn* unsafe_arena_release_addsubscriptiontotxn();

  // optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
  bool has_addsubscriptiontotxnresponse() const;
  private:
  bool _internal_has_addsubscriptiontotxnresponse() const;
  public:
  void clear_addsubscriptiontotxnresponse();
  const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& addsubscriptiontotxnresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandAddSubscriptionToTxnResponse* release_addsubscriptiontotxnresponse();
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* mutable_addsubscriptiontotxnresponse();
  void set_allocated_addsubscriptiontotxnresponse(::pulsar::proto::CommandAddSubscriptionToTxnResponse* addsubscriptiontotxnresponse);
  private:
  const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& _internal_addsubscriptiontotxnresponse() const;
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* _internal_mutable_addsubscriptiontotxnresponse();
  public:
  void unsafe_arena_set_allocated_addsubscriptiontotxnresponse(
      ::pulsar::proto::CommandAddSubscriptionToTxnResponse* addsubscriptiontotxnresponse);
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* unsafe_arena_release_addsubscriptiontotxnresponse();

  // optional .pulsar.proto.CommandEndTxn endTxn = 56;
  bool has_endtxn() const;
  private:
  bool _internal_has_endtxn() const;
  public:
  void clear_endtxn();
  const ::pulsar::proto::CommandEndTxn& endtxn() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandEndTxn* release_endtxn();
  ::pulsar::proto::CommandEndTxn* mutable_endtxn();
  void set_allocated_endtxn(::pulsar::proto::CommandEndTxn* endtxn);
  private:
  const ::pulsar::proto::CommandEndTxn& _internal_endtxn() const;
  ::pulsar::proto::CommandEndTxn* _internal_mutable_endtxn();
  public:
  void unsafe_arena_set_allocated_endtxn(
      ::pulsar::proto::CommandEndTxn* endtxn);
  ::pulsar::proto::CommandEndTxn* unsafe_arena_release_endtxn();

  // optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
  bool has_endtxnresponse() const;
  private:
  bool _internal_has_endtxnresponse() const;
  public:
  void clear_endtxnresponse();
  const ::pulsar::proto::CommandEndTxnResponse& endtxnresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandEndTxnResponse* release_endtxnresponse();
  ::pulsar::proto::CommandEndTxnResponse* mutable_endtxnresponse();
  void set_allocated_endtxnresponse(::pulsar::proto::CommandEndTxnResponse* endtxnresponse);
  private:
  const ::pulsar::proto::CommandEndTxnResponse& _internal_endtxnresponse() const;
  ::pulsar::proto::CommandEndTxnResponse* _internal_mutable_endtxnresponse();
  public:
  void unsafe_arena_set_allocated_endtxnresponse(
      ::pulsar::proto::CommandEndTxnResponse* endtxnresponse);
  ::pulsar::proto::CommandEndTxnResponse* unsafe_arena_release_endtxnresponse();

  // optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
  bool has_endtxnonpartition() const;
  private:
  bool _internal_has_endtxnonpartition() const;
  public:
  void clear_endtxnonpartition();
  const ::pulsar::proto::CommandEndTxnOnPartition& endtxnonpartition() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandEndTxnOnPartition* release_endtxnonpartition();
  ::pulsar::proto::CommandEndTxnOnPartition* mutable_endtxnonpartition();
  void set_allocated_endtxnonpartition(::pulsar::proto::CommandEndTxnOnPartition* endtxnonpartition);
  private:
  const ::pulsar::proto::CommandEndTxnOnPartition& _internal_endtxnonpartition() const;
  ::pulsar::proto::CommandEndTxnOnPartition* _internal_mutable_endtxnonpartition();
  public:
  void unsafe_arena_set_allocated_endtxnonpartition(
      ::pulsar::proto::CommandEndTxnOnPartition* endtxnonpartition);
  ::pulsar::proto::CommandEndTxnOnPartition* unsafe_arena_release_endtxnonpartition();

  // optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
  bool has_endtxnonpartitionresponse() const;
  private:
  bool _internal_has_endtxnonpartitionresponse() const;
  public:
  void clear_endtxnonpartitionresponse();
  const ::pulsar::proto::CommandEndTxnOnPartitionResponse& endtxnonpartitionresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandEndTxnOnPartitionResponse* release_endtxnonpartitionresponse();
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* mutable_endtxnonpartitionresponse();
  void set_allocated_endtxnonpartitionresponse(::pulsar::proto::CommandEndTxnOnPartitionResponse* endtxnonpartitionresponse);
  private:
  const ::pulsar::proto::CommandEndTxnOnPartitionResponse& _internal_endtxnonpartitionresponse() const;
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* _internal_mutable_endtxnonpartitionresponse();
  public:
  void unsafe_arena_set_allocated_endtxnonpartitionresponse(
      ::pulsar::proto::CommandEndTxnOnPartitionResponse* endtxnonpartitionresponse);
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* unsafe_arena_release_endtxnonpartitionresponse();

  // optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
  bool has_endtxnonsubscription() const;
  private:
  bool _internal_has_endtxnonsubscription() const;
  public:
  void clear_endtxnonsubscription();
  const ::pulsar::proto::CommandEndTxnOnSubscription& endtxnonsubscription() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandEndTxnOnSubscription* release_endtxnonsubscription();
  ::pulsar::proto::CommandEndTxnOnSubscription* mutable_endtxnonsubscription();
  void set_allocated_endtxnonsubscription(::pulsar::proto::CommandEndTxnOnSubscription* endtxnonsubscription);
  private:
  const ::pulsar::proto::CommandEndTxnOnSubscription& _internal_endtxnonsubscription() const;
  ::pulsar::proto::CommandEndTxnOnSubscription* _internal_mutable_endtxnonsubscription();
  public:
  void unsafe_arena_set_allocated_endtxnonsubscription(
      ::pulsar::proto::CommandEndTxnOnSubscription* endtxnonsubscription);
  ::pulsar::proto::CommandEndTxnOnSubscription* unsafe_arena_release_endtxnonsubscription();

  // optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
  bool has_endtxnonsubscriptionresponse() const;
  private:
  bool _internal_has_endtxnonsubscriptionresponse() const;
  public:
  void clear_endtxnonsubscriptionresponse();
  const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& endtxnonsubscriptionresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* release_endtxnonsubscriptionresponse();
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* mutable_endtxnonsubscriptionresponse();
  void set_allocated_endtxnonsubscriptionresponse(::pulsar::proto::CommandEndTxnOnSubscriptionResponse* endtxnonsubscriptionresponse);
  private:
  const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& _internal_endtxnonsubscriptionresponse() const;
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* _internal_mutable_endtxnonsubscriptionresponse();
  public:
  void unsafe_arena_set_allocated_endtxnonsubscriptionresponse(
      ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* endtxnonsubscriptionresponse);
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* unsafe_arena_release_endtxnonsubscriptionresponse();

  // optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
  bool has_tcclientconnectrequest() const;
  private:
  bool _internal_has_tcclientconnectrequest() const;
  public:
  void clear_tcclientconnectrequest();
  const ::pulsar::proto::CommandTcClientConnectRequest& tcclientconnectrequest() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandTcClientConnectRequest* release_tcclientconnectrequest();
  ::pulsar::proto::CommandTcClientConnectRequest* mutable_tcclientconnectrequest();
  void set_allocated_tcclientconnectrequest(::pulsar::proto::CommandTcClientConnectRequest* tcclientconnectrequest);
  private:
  const ::pulsar::proto::CommandTcClientConnectRequest& _internal_tcclientconnectrequest() const;
  ::pulsar::proto::CommandTcClientConnectRequest* _internal_mutable_tcclientconnectrequest();
  public:
  void unsafe_arena_set_allocated_tcclientconnectrequest(
      ::pulsar::proto::CommandTcClientConnectRequest* tcclientconnectrequest);
  ::pulsar::proto::CommandTcClientConnectRequest* unsafe_arena_release_tcclientconnectrequest();

  // optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
  bool has_tcclientconnectresponse() const;
  private:
  bool _internal_has_tcclientconnectresponse() const;
  public:
  void clear_tcclientconnectresponse();
  const ::pulsar::proto::CommandTcClientConnectResponse& tcclientconnectresponse() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandTcClientConnectResponse* release_tcclientconnectresponse();
  ::pulsar::proto::CommandTcClientConnectResponse* mutable_tcclientconnectresponse();
  void set_allocated_tcclientconnectresponse(::pulsar::proto::CommandTcClientConnectResponse* tcclientconnectresponse);
  private:
  const ::pulsar::proto::CommandTcClientConnectResponse& _internal_tcclientconnectresponse() const;
  ::pulsar::proto::CommandTcClientConnectResponse* _internal_mutable_tcclientconnectresponse();
  public:
  void unsafe_arena_set_allocated_tcclientconnectresponse(
      ::pulsar::proto::CommandTcClientConnectResponse* tcclientconnectresponse);
  ::pulsar::proto::CommandTcClientConnectResponse* unsafe_arena_release_tcclientconnectresponse();

  // optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
  bool has_watchtopiclist() const;
  private:
  bool _internal_has_watchtopiclist() const;
  public:
  void clear_watchtopiclist();
  const ::pulsar::proto::CommandWatchTopicList& watchtopiclist() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandWatchTopicList* release_watchtopiclist();
  ::pulsar::proto::CommandWatchTopicList* mutable_watchtopiclist();
  void set_allocated_watchtopiclist(::pulsar::proto::CommandWatchTopicList* watchtopiclist);
  private:
  const ::pulsar::proto::CommandWatchTopicList& _internal_watchtopiclist() const;
  ::pulsar::proto::CommandWatchTopicList* _internal_mutable_watchtopiclist();
  public:
  void unsafe_arena_set_allocated_watchtopiclist(
      ::pulsar::proto::CommandWatchTopicList* watchtopiclist);
  ::pulsar::proto::CommandWatchTopicList* unsafe_arena_release_watchtopiclist();

  // optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
  bool has_watchtopiclistsuccess() const;
  private:
  bool _internal_has_watchtopiclistsuccess() const;
  public:
  void clear_watchtopiclistsuccess();
  const ::pulsar::proto::CommandWatchTopicListSuccess& watchtopiclistsuccess() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandWatchTopicListSuccess* release_watchtopiclistsuccess();
  ::pulsar::proto::CommandWatchTopicListSuccess* mutable_watchtopiclistsuccess();
  void set_allocated_watchtopiclistsuccess(::pulsar::proto::CommandWatchTopicListSuccess* watchtopiclistsuccess);
  private:
  const ::pulsar::proto::CommandWatchTopicListSuccess& _internal_watchtopiclistsuccess() const;
  ::pulsar::proto::CommandWatchTopicListSuccess* _internal_mutable_watchtopiclistsuccess();
  public:
  void unsafe_arena_set_allocated_watchtopiclistsuccess(
      ::pulsar::proto::CommandWatchTopicListSuccess* watchtopiclistsuccess);
  ::pulsar::proto::CommandWatchTopicListSuccess* unsafe_arena_release_watchtopiclistsuccess();

  // optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
  bool has_watchtopicupdate() const;
  private:
  bool _internal_has_watchtopicupdate() const;
  public:
  void clear_watchtopicupdate();
  const ::pulsar::proto::CommandWatchTopicUpdate& watchtopicupdate() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandWatchTopicUpdate* release_watchtopicupdate();
  ::pulsar::proto::CommandWatchTopicUpdate* mutable_watchtopicupdate();
  void set_allocated_watchtopicupdate(::pulsar::proto::CommandWatchTopicUpdate* watchtopicupdate);
  private:
  const ::pulsar::proto::CommandWatchTopicUpdate& _internal_watchtopicupdate() const;
  ::pulsar::proto::CommandWatchTopicUpdate* _internal_mutable_watchtopicupdate();
  public:
  void unsafe_arena_set_allocated_watchtopicupdate(
      ::pulsar::proto::CommandWatchTopicUpdate* watchtopicupdate);
  ::pulsar::proto::CommandWatchTopicUpdate* unsafe_arena_release_watchtopicupdate();

  // optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
  bool has_watchtopiclistclose() const;
  private:
  bool _internal_has_watchtopiclistclose() const;
  public:
  void clear_watchtopiclistclose();
  const ::pulsar::proto::CommandWatchTopicListClose& watchtopiclistclose() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandWatchTopicListClose* release_watchtopiclistclose();
  ::pulsar::proto::CommandWatchTopicListClose* mutable_watchtopiclistclose();
  void set_allocated_watchtopiclistclose(::pulsar::proto::CommandWatchTopicListClose* watchtopiclistclose);
  private:
  const ::pulsar::proto::CommandWatchTopicListClose& _internal_watchtopiclistclose() const;
  ::pulsar::proto::CommandWatchTopicListClose* _internal_mutable_watchtopiclistclose();
  public:
  void unsafe_arena_set_allocated_watchtopiclistclose(
      ::pulsar::proto::CommandWatchTopicListClose* watchtopiclistclose);
  ::pulsar::proto::CommandWatchTopicListClose* unsafe_arena_release_watchtopiclistclose();

  // optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
  bool has_topicmigrated() const;
  private:
  bool _internal_has_topicmigrated() const;
  public:
  void clear_topicmigrated();
  const ::pulsar::proto::CommandTopicMigrated& topicmigrated() const;
  PROTOBUF_MUST_USE_RESULT ::pulsar::proto::CommandTopicMigrated* release_topicmigrated();
  ::pulsar::proto::CommandTopicMigrated* mutable_topicmigrated();
  void set_allocated_topicmigrated(::pulsar::proto::CommandTopicMigrated* topicmigrated);
  private:
  const ::pulsar::proto::CommandTopicMigrated& _internal_topicmigrated() const;
  ::pulsar::proto::CommandTopicMigrated* _internal_mutable_topicmigrated();
  public:
  void unsafe_arena_set_allocated_topicmigrated(
      ::pulsar::proto::CommandTopicMigrated* topicmigrated);
  ::pulsar::proto::CommandTopicMigrated* unsafe_arena_release_topicmigrated();

  // required .pulsar.proto.BaseCommand.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pulsar::proto::BaseCommand_Type type() const;
  void set_type(::pulsar::proto::BaseCommand_Type value);
  private:
  ::pulsar::proto::BaseCommand_Type _internal_type() const;
  void _internal_set_type(::pulsar::proto::BaseCommand_Type value);
  public:

  // @@protoc_insertion_point(class_scope:pulsar.proto.BaseCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pulsar::proto::CommandConnect* connect_;
  ::pulsar::proto::CommandConnected* connected_;
  ::pulsar::proto::CommandSubscribe* subscribe_;
  ::pulsar::proto::CommandProducer* producer_;
  ::pulsar::proto::CommandSend* send_;
  ::pulsar::proto::CommandSendReceipt* send_receipt_;
  ::pulsar::proto::CommandSendError* send_error_;
  ::pulsar::proto::CommandMessage* message_;
  ::pulsar::proto::CommandAck* ack_;
  ::pulsar::proto::CommandFlow* flow_;
  ::pulsar::proto::CommandUnsubscribe* unsubscribe_;
  ::pulsar::proto::CommandSuccess* success_;
  ::pulsar::proto::CommandError* error_;
  ::pulsar::proto::CommandCloseProducer* close_producer_;
  ::pulsar::proto::CommandCloseConsumer* close_consumer_;
  ::pulsar::proto::CommandProducerSuccess* producer_success_;
  ::pulsar::proto::CommandPing* ping_;
  ::pulsar::proto::CommandPong* pong_;
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* redeliverunacknowledgedmessages_;
  ::pulsar::proto::CommandPartitionedTopicMetadata* partitionmetadata_;
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* partitionmetadataresponse_;
  ::pulsar::proto::CommandLookupTopic* lookuptopic_;
  ::pulsar::proto::CommandLookupTopicResponse* lookuptopicresponse_;
  ::pulsar::proto::CommandConsumerStats* consumerstats_;
  ::pulsar::proto::CommandConsumerStatsResponse* consumerstatsresponse_;
  ::pulsar::proto::CommandReachedEndOfTopic* reachedendoftopic_;
  ::pulsar::proto::CommandSeek* seek_;
  ::pulsar::proto::CommandGetLastMessageId* getlastmessageid_;
  ::pulsar::proto::CommandGetLastMessageIdResponse* getlastmessageidresponse_;
  ::pulsar::proto::CommandActiveConsumerChange* active_consumer_change_;
  ::pulsar::proto::CommandGetTopicsOfNamespace* gettopicsofnamespace_;
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* gettopicsofnamespaceresponse_;
  ::pulsar::proto::CommandGetSchema* getschema_;
  ::pulsar::proto::CommandGetSchemaResponse* getschemaresponse_;
  ::pulsar::proto::CommandAuthChallenge* authchallenge_;
  ::pulsar::proto::CommandAuthResponse* authresponse_;
  ::pulsar::proto::CommandAckResponse* ackresponse_;
  ::pulsar::proto::CommandGetOrCreateSchema* getorcreateschema_;
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* getorcreateschemaresponse_;
  ::pulsar::proto::CommandNewTxn* newtxn_;
  ::pulsar::proto::CommandNewTxnResponse* newtxnresponse_;
  ::pulsar::proto::CommandAddPartitionToTxn* addpartitiontotxn_;
  ::pulsar::proto::CommandAddPartitionToTxnResponse* addpartitiontotxnresponse_;
  ::pulsar::proto::CommandAddSubscriptionToTxn* addsubscriptiontotxn_;
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* addsubscriptiontotxnresponse_;
  ::pulsar::proto::CommandEndTxn* endtxn_;
  ::pulsar::proto::CommandEndTxnResponse* endtxnresponse_;
  ::pulsar::proto::CommandEndTxnOnPartition* endtxnonpartition_;
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* endtxnonpartitionresponse_;
  ::pulsar::proto::CommandEndTxnOnSubscription* endtxnonsubscription_;
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* endtxnonsubscriptionresponse_;
  ::pulsar::proto::CommandTcClientConnectRequest* tcclientconnectrequest_;
  ::pulsar::proto::CommandTcClientConnectResponse* tcclientconnectresponse_;
  ::pulsar::proto::CommandWatchTopicList* watchtopiclist_;
  ::pulsar::proto::CommandWatchTopicListSuccess* watchtopiclistsuccess_;
  ::pulsar::proto::CommandWatchTopicUpdate* watchtopicupdate_;
  ::pulsar::proto::CommandWatchTopicListClose* watchtopiclistclose_;
  ::pulsar::proto::CommandTopicMigrated* topicmigrated_;
  int type_;
  friend struct ::TableStruct_PulsarApi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Schema

// required string name = 1;
inline bool Schema::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Schema::has_name() const {
  return _internal_has_name();
}
inline void Schema::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Schema::name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.Schema.name)
}
inline std::string* Schema::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Schema.name)
  return _s;
}
inline const std::string& Schema::_internal_name() const {
  return name_.Get();
}
inline void Schema::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Schema::release_name() {
  // @@protoc_insertion_point(field_release:pulsar.proto.Schema.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Schema::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Schema.name)
}

// required bytes schema_data = 3;
inline bool Schema::_internal_has_schema_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Schema::has_schema_data() const {
  return _internal_has_schema_data();
}
inline void Schema::clear_schema_data() {
  schema_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Schema::schema_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.schema_data)
  return _internal_schema_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_schema_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 schema_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.Schema.schema_data)
}
inline std::string* Schema::mutable_schema_data() {
  std::string* _s = _internal_mutable_schema_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Schema.schema_data)
  return _s;
}
inline const std::string& Schema::_internal_schema_data() const {
  return schema_data_.Get();
}
inline void Schema::_internal_set_schema_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_schema_data() {
  _has_bits_[0] |= 0x00000002u;
  return schema_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Schema::release_schema_data() {
  // @@protoc_insertion_point(field_release:pulsar.proto.Schema.schema_data)
  if (!_internal_has_schema_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return schema_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Schema::set_allocated_schema_data(std::string* schema_data) {
  if (schema_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Schema.schema_data)
}

// required .pulsar.proto.Schema.Type type = 4;
inline bool Schema::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Schema::has_type() const {
  return _internal_has_type();
}
inline void Schema::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::pulsar::proto::Schema_Type Schema::_internal_type() const {
  return static_cast< ::pulsar::proto::Schema_Type >(type_);
}
inline ::pulsar::proto::Schema_Type Schema::type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.type)
  return _internal_type();
}
inline void Schema::_internal_set_type(::pulsar::proto::Schema_Type value) {
  assert(::pulsar::proto::Schema_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void Schema::set_type(::pulsar::proto::Schema_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.Schema.type)
}

// repeated .pulsar.proto.KeyValue properties = 5;
inline int Schema::_internal_properties_size() const {
  return properties_.size();
}
inline int Schema::properties_size() const {
  return _internal_properties_size();
}
inline void Schema::clear_properties() {
  properties_.Clear();
}
inline ::pulsar::proto::KeyValue* Schema::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Schema.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
Schema::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.Schema.properties)
  return &properties_;
}
inline const ::pulsar::proto::KeyValue& Schema::_internal_properties(int index) const {
  return properties_.Get(index);
}
inline const ::pulsar::proto::KeyValue& Schema::properties(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.properties)
  return _internal_properties(index);
}
inline ::pulsar::proto::KeyValue* Schema::_internal_add_properties() {
  return properties_.Add();
}
inline ::pulsar::proto::KeyValue* Schema::add_properties() {
  ::pulsar::proto::KeyValue* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:pulsar.proto.Schema.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
Schema::properties() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.Schema.properties)
  return properties_;
}

// -------------------------------------------------------------------

// MessageIdData

// required uint64 ledgerId = 1;
inline bool MessageIdData::_internal_has_ledgerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MessageIdData::has_ledgerid() const {
  return _internal_has_ledgerid();
}
inline void MessageIdData::clear_ledgerid() {
  ledgerid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageIdData::_internal_ledgerid() const {
  return ledgerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageIdData::ledgerid() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.ledgerId)
  return _internal_ledgerid();
}
inline void MessageIdData::_internal_set_ledgerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerid_ = value;
}
inline void MessageIdData::set_ledgerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ledgerid(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.ledgerId)
}

// required uint64 entryId = 2;
inline bool MessageIdData::_internal_has_entryid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MessageIdData::has_entryid() const {
  return _internal_has_entryid();
}
inline void MessageIdData::clear_entryid() {
  entryid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageIdData::_internal_entryid() const {
  return entryid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageIdData::entryid() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.entryId)
  return _internal_entryid();
}
inline void MessageIdData::_internal_set_entryid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  entryid_ = value;
}
inline void MessageIdData::set_entryid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_entryid(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.entryId)
}

// optional int32 partition = 3 [default = -1];
inline bool MessageIdData::_internal_has_partition() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MessageIdData::has_partition() const {
  return _internal_has_partition();
}
inline void MessageIdData::clear_partition() {
  partition_ = -1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageIdData::_internal_partition() const {
  return partition_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageIdData::partition() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.partition)
  return _internal_partition();
}
inline void MessageIdData::_internal_set_partition(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  partition_ = value;
}
inline void MessageIdData::set_partition(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_partition(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.partition)
}

// optional int32 batch_index = 4 [default = -1];
inline bool MessageIdData::_internal_has_batch_index() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MessageIdData::has_batch_index() const {
  return _internal_has_batch_index();
}
inline void MessageIdData::clear_batch_index() {
  batch_index_ = -1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageIdData::_internal_batch_index() const {
  return batch_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageIdData::batch_index() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.batch_index)
  return _internal_batch_index();
}
inline void MessageIdData::_internal_set_batch_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  batch_index_ = value;
}
inline void MessageIdData::set_batch_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_index(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.batch_index)
}

// repeated int64 ack_set = 5;
inline int MessageIdData::_internal_ack_set_size() const {
  return ack_set_.size();
}
inline int MessageIdData::ack_set_size() const {
  return _internal_ack_set_size();
}
inline void MessageIdData::clear_ack_set() {
  ack_set_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MessageIdData::_internal_ack_set(int index) const {
  return ack_set_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MessageIdData::ack_set(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.ack_set)
  return _internal_ack_set(index);
}
inline void MessageIdData::set_ack_set(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  ack_set_.Set(index, value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.ack_set)
}
inline void MessageIdData::_internal_add_ack_set(::PROTOBUF_NAMESPACE_ID::int64 value) {
  ack_set_.Add(value);
}
inline void MessageIdData::add_ack_set(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_ack_set(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageIdData.ack_set)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
MessageIdData::_internal_ack_set() const {
  return ack_set_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
MessageIdData::ack_set() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageIdData.ack_set)
  return _internal_ack_set();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
MessageIdData::_internal_mutable_ack_set() {
  return &ack_set_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
MessageIdData::mutable_ack_set() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageIdData.ack_set)
  return _internal_mutable_ack_set();
}

// optional int32 batch_size = 6;
inline bool MessageIdData::_internal_has_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MessageIdData::has_batch_size() const {
  return _internal_has_batch_size();
}
inline void MessageIdData::clear_batch_size() {
  batch_size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageIdData::_internal_batch_size() const {
  return batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageIdData::batch_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.batch_size)
  return _internal_batch_size();
}
inline void MessageIdData::_internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  batch_size_ = value;
}
inline void MessageIdData::set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.batch_size)
}

// optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
inline bool MessageIdData::_internal_has_first_chunk_message_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || first_chunk_message_id_ != nullptr);
  return value;
}
inline bool MessageIdData::has_first_chunk_message_id() const {
  return _internal_has_first_chunk_message_id();
}
inline void MessageIdData::clear_first_chunk_message_id() {
  if (first_chunk_message_id_ != nullptr) first_chunk_message_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& MessageIdData::_internal_first_chunk_message_id() const {
  const ::pulsar::proto::MessageIdData* p = first_chunk_message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(
      ::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& MessageIdData::first_chunk_message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.first_chunk_message_id)
  return _internal_first_chunk_message_id();
}
inline void MessageIdData::unsafe_arena_set_allocated_first_chunk_message_id(
    ::pulsar::proto::MessageIdData* first_chunk_message_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(first_chunk_message_id_);
  }
  first_chunk_message_id_ = first_chunk_message_id;
  if (first_chunk_message_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.MessageIdData.first_chunk_message_id)
}
inline ::pulsar::proto::MessageIdData* MessageIdData::release_first_chunk_message_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = first_chunk_message_id_;
  first_chunk_message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::MessageIdData* MessageIdData::unsafe_arena_release_first_chunk_message_id() {
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageIdData.first_chunk_message_id)
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = first_chunk_message_id_;
  first_chunk_message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* MessageIdData::_internal_mutable_first_chunk_message_id() {
  _has_bits_[0] |= 0x00000001u;
  if (first_chunk_message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArenaForAllocation());
    first_chunk_message_id_ = p;
  }
  return first_chunk_message_id_;
}
inline ::pulsar::proto::MessageIdData* MessageIdData::mutable_first_chunk_message_id() {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_first_chunk_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageIdData.first_chunk_message_id)
  return _msg;
}
inline void MessageIdData::set_allocated_first_chunk_message_id(::pulsar::proto::MessageIdData* first_chunk_message_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete first_chunk_message_id_;
  }
  if (first_chunk_message_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::MessageIdData>::GetOwningArena(first_chunk_message_id);
    if (message_arena != submessage_arena) {
      first_chunk_message_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_chunk_message_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  first_chunk_message_id_ = first_chunk_message_id;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageIdData.first_chunk_message_id)
}

// -------------------------------------------------------------------

// KeyValue

// required string key = 1;
inline bool KeyValue::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyValue::has_key() const {
  return _internal_has_key();
}
inline void KeyValue::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyValue.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValue::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyValue.key)
}
inline std::string* KeyValue::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeyValue.key)
  return _s;
}
inline const std::string& KeyValue::_internal_key() const {
  return key_.Get();
}
inline void KeyValue::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyValue::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:pulsar.proto.KeyValue.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyValue::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.KeyValue.key)
}

// required string value = 2;
inline bool KeyValue::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyValue::has_value() const {
  return _internal_has_value();
}
inline void KeyValue::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyValue.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValue::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyValue.value)
}
inline std::string* KeyValue::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeyValue.value)
  return _s;
}
inline const std::string& KeyValue::_internal_value() const {
  return value_.Get();
}
inline void KeyValue::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyValue::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:pulsar.proto.KeyValue.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.KeyValue.value)
}

// -------------------------------------------------------------------

// KeyLongValue

// required string key = 1;
inline bool KeyLongValue::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyLongValue::has_key() const {
  return _internal_has_key();
}
inline void KeyLongValue::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyLongValue::key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyLongValue.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyLongValue::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyLongValue.key)
}
inline std::string* KeyLongValue::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeyLongValue.key)
  return _s;
}
inline const std::string& KeyLongValue::_internal_key() const {
  return key_.Get();
}
inline void KeyLongValue::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyLongValue::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyLongValue::release_key() {
  // @@protoc_insertion_point(field_release:pulsar.proto.KeyLongValue.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyLongValue::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.KeyLongValue.key)
}

// required uint64 value = 2;
inline bool KeyLongValue::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyLongValue::has_value() const {
  return _internal_has_value();
}
inline void KeyLongValue::clear_value() {
  value_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KeyLongValue::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KeyLongValue::value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyLongValue.value)
  return _internal_value();
}
inline void KeyLongValue::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void KeyLongValue::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyLongValue.value)
}

// -------------------------------------------------------------------

// IntRange

// required int32 start = 1;
inline bool IntRange::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IntRange::has_start() const {
  return _internal_has_start();
}
inline void IntRange::clear_start() {
  start_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntRange::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntRange::start() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.IntRange.start)
  return _internal_start();
}
inline void IntRange::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  start_ = value;
}
inline void IntRange::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.IntRange.start)
}

// required int32 end = 2;
inline bool IntRange::_internal_has_end() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IntRange::has_end() const {
  return _internal_has_end();
}
inline void IntRange::clear_end() {
  end_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntRange::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IntRange::end() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.IntRange.end)
  return _internal_end();
}
inline void IntRange::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  end_ = value;
}
inline void IntRange::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.IntRange.end)
}

// -------------------------------------------------------------------

// EncryptionKeys

// required string key = 1;
inline bool EncryptionKeys::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EncryptionKeys::has_key() const {
  return _internal_has_key();
}
inline void EncryptionKeys::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EncryptionKeys::key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.EncryptionKeys.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionKeys::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.EncryptionKeys.key)
}
inline std::string* EncryptionKeys::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.EncryptionKeys.key)
  return _s;
}
inline const std::string& EncryptionKeys::_internal_key() const {
  return key_.Get();
}
inline void EncryptionKeys::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EncryptionKeys::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EncryptionKeys::release_key() {
  // @@protoc_insertion_point(field_release:pulsar.proto.EncryptionKeys.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EncryptionKeys::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.EncryptionKeys.key)
}

// required bytes value = 2;
inline bool EncryptionKeys::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EncryptionKeys::has_value() const {
  return _internal_has_value();
}
inline void EncryptionKeys::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EncryptionKeys::value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.EncryptionKeys.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptionKeys::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.EncryptionKeys.value)
}
inline std::string* EncryptionKeys::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.EncryptionKeys.value)
  return _s;
}
inline const std::string& EncryptionKeys::_internal_value() const {
  return value_.Get();
}
inline void EncryptionKeys::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EncryptionKeys::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EncryptionKeys::release_value() {
  // @@protoc_insertion_point(field_release:pulsar.proto.EncryptionKeys.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EncryptionKeys::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.EncryptionKeys.value)
}

// repeated .pulsar.proto.KeyValue metadata = 3;
inline int EncryptionKeys::_internal_metadata_size() const {
  return metadata_.size();
}
inline int EncryptionKeys::metadata_size() const {
  return _internal_metadata_size();
}
inline void EncryptionKeys::clear_metadata() {
  metadata_.Clear();
}
inline ::pulsar::proto::KeyValue* EncryptionKeys::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.EncryptionKeys.metadata)
  return metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
EncryptionKeys::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.EncryptionKeys.metadata)
  return &metadata_;
}
inline const ::pulsar::proto::KeyValue& EncryptionKeys::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline const ::pulsar::proto::KeyValue& EncryptionKeys::metadata(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.EncryptionKeys.metadata)
  return _internal_metadata(index);
}
inline ::pulsar::proto::KeyValue* EncryptionKeys::_internal_add_metadata() {
  return metadata_.Add();
}
inline ::pulsar::proto::KeyValue* EncryptionKeys::add_metadata() {
  ::pulsar::proto::KeyValue* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:pulsar.proto.EncryptionKeys.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
EncryptionKeys::metadata() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.EncryptionKeys.metadata)
  return metadata_;
}

// -------------------------------------------------------------------

// MessageMetadata

// required string producer_name = 1;
inline bool MessageMetadata::_internal_has_producer_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageMetadata::has_producer_name() const {
  return _internal_has_producer_name();
}
inline void MessageMetadata::clear_producer_name() {
  producer_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageMetadata::producer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.producer_name)
  return _internal_producer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMetadata::set_producer_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 producer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.producer_name)
}
inline std::string* MessageMetadata::mutable_producer_name() {
  std::string* _s = _internal_mutable_producer_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.producer_name)
  return _s;
}
inline const std::string& MessageMetadata::_internal_producer_name() const {
  return producer_name_.Get();
}
inline void MessageMetadata::_internal_set_producer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  producer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessageMetadata::_internal_mutable_producer_name() {
  _has_bits_[0] |= 0x00000001u;
  return producer_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessageMetadata::release_producer_name() {
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.producer_name)
  if (!_internal_has_producer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return producer_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessageMetadata::set_allocated_producer_name(std::string* producer_name) {
  if (producer_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  producer_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), producer_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.producer_name)
}

// required uint64 sequence_id = 2;
inline bool MessageMetadata::_internal_has_sequence_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MessageMetadata::has_sequence_id() const {
  return _internal_has_sequence_id();
}
inline void MessageMetadata::clear_sequence_id() {
  sequence_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::_internal_sequence_id() const {
  return sequence_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.sequence_id)
  return _internal_sequence_id();
}
inline void MessageMetadata::_internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  sequence_id_ = value;
}
inline void MessageMetadata::set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.sequence_id)
}

// required uint64 publish_time = 3;
inline bool MessageMetadata::_internal_has_publish_time() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MessageMetadata::has_publish_time() const {
  return _internal_has_publish_time();
}
inline void MessageMetadata::clear_publish_time() {
  publish_time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::_internal_publish_time() const {
  return publish_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::publish_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.publish_time)
  return _internal_publish_time();
}
inline void MessageMetadata::_internal_set_publish_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000200u;
  publish_time_ = value;
}
inline void MessageMetadata::set_publish_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_publish_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.publish_time)
}

// repeated .pulsar.proto.KeyValue properties = 4;
inline int MessageMetadata::_internal_properties_size() const {
  return properties_.size();
}
inline int MessageMetadata::properties_size() const {
  return _internal_properties_size();
}
inline void MessageMetadata::clear_properties() {
  properties_.Clear();
}
inline ::pulsar::proto::KeyValue* MessageMetadata::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
MessageMetadata::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageMetadata.properties)
  return &properties_;
}
inline const ::pulsar::proto::KeyValue& MessageMetadata::_internal_properties(int index) const {
  return properties_.Get(index);
}
inline const ::pulsar::proto::KeyValue& MessageMetadata::properties(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.properties)
  return _internal_properties(index);
}
inline ::pulsar::proto::KeyValue* MessageMetadata::_internal_add_properties() {
  return properties_.Add();
}
inline ::pulsar::proto::KeyValue* MessageMetadata::add_properties() {
  ::pulsar::proto::KeyValue* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
MessageMetadata::properties() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageMetadata.properties)
  return properties_;
}

// optional string replicated_from = 5;
inline bool MessageMetadata::_internal_has_replicated_from() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MessageMetadata::has_replicated_from() const {
  return _internal_has_replicated_from();
}
inline void MessageMetadata::clear_replicated_from() {
  replicated_from_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MessageMetadata::replicated_from() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.replicated_from)
  return _internal_replicated_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMetadata::set_replicated_from(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 replicated_from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.replicated_from)
}
inline std::string* MessageMetadata::mutable_replicated_from() {
  std::string* _s = _internal_mutable_replicated_from();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.replicated_from)
  return _s;
}
inline const std::string& MessageMetadata::_internal_replicated_from() const {
  return replicated_from_.Get();
}
inline void MessageMetadata::_internal_set_replicated_from(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  replicated_from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessageMetadata::_internal_mutable_replicated_from() {
  _has_bits_[0] |= 0x00000002u;
  return replicated_from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessageMetadata::release_replicated_from() {
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.replicated_from)
  if (!_internal_has_replicated_from()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return replicated_from_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessageMetadata::set_allocated_replicated_from(std::string* replicated_from) {
  if (replicated_from != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  replicated_from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), replicated_from,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.replicated_from)
}

// optional string partition_key = 6;
inline bool MessageMetadata::_internal_has_partition_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MessageMetadata::has_partition_key() const {
  return _internal_has_partition_key();
}
inline void MessageMetadata::clear_partition_key() {
  partition_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MessageMetadata::partition_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.partition_key)
  return _internal_partition_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMetadata::set_partition_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 partition_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.partition_key)
}
inline std::string* MessageMetadata::mutable_partition_key() {
  std::string* _s = _internal_mutable_partition_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.partition_key)
  return _s;
}
inline const std::string& MessageMetadata::_internal_partition_key() const {
  return partition_key_.Get();
}
inline void MessageMetadata::_internal_set_partition_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  partition_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessageMetadata::_internal_mutable_partition_key() {
  _has_bits_[0] |= 0x00000004u;
  return partition_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessageMetadata::release_partition_key() {
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.partition_key)
  if (!_internal_has_partition_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return partition_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessageMetadata::set_allocated_partition_key(std::string* partition_key) {
  if (partition_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  partition_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.partition_key)
}

// repeated string replicate_to = 7;
inline int MessageMetadata::_internal_replicate_to_size() const {
  return replicate_to_.size();
}
inline int MessageMetadata::replicate_to_size() const {
  return _internal_replicate_to_size();
}
inline void MessageMetadata::clear_replicate_to() {
  replicate_to_.Clear();
}
inline std::string* MessageMetadata::add_replicate_to() {
  std::string* _s = _internal_add_replicate_to();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.MessageMetadata.replicate_to)
  return _s;
}
inline const std::string& MessageMetadata::_internal_replicate_to(int index) const {
  return replicate_to_.Get(index);
}
inline const std::string& MessageMetadata::replicate_to(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.replicate_to)
  return _internal_replicate_to(index);
}
inline std::string* MessageMetadata::mutable_replicate_to(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.replicate_to)
  return replicate_to_.Mutable(index);
}
inline void MessageMetadata::set_replicate_to(int index, const std::string& value) {
  replicate_to_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::set_replicate_to(int index, std::string&& value) {
  replicate_to_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::set_replicate_to(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  replicate_to_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::set_replicate_to(int index, const char* value, size_t size) {
  replicate_to_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.replicate_to)
}
inline std::string* MessageMetadata::_internal_add_replicate_to() {
  return replicate_to_.Add();
}
inline void MessageMetadata::add_replicate_to(const std::string& value) {
  replicate_to_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(std::string&& value) {
  replicate_to_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  replicate_to_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(const char* value, size_t size) {
  replicate_to_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.MessageMetadata.replicate_to)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MessageMetadata::replicate_to() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageMetadata.replicate_to)
  return replicate_to_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MessageMetadata::mutable_replicate_to() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageMetadata.replicate_to)
  return &replicate_to_;
}

// optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
inline bool MessageMetadata::_internal_has_compression() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MessageMetadata::has_compression() const {
  return _internal_has_compression();
}
inline void MessageMetadata::clear_compression() {
  compression_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::pulsar::proto::CompressionType MessageMetadata::_internal_compression() const {
  return static_cast< ::pulsar::proto::CompressionType >(compression_);
}
inline ::pulsar::proto::CompressionType MessageMetadata::compression() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.compression)
  return _internal_compression();
}
inline void MessageMetadata::_internal_set_compression(::pulsar::proto::CompressionType value) {
  assert(::pulsar::proto::CompressionType_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  compression_ = value;
}
inline void MessageMetadata::set_compression(::pulsar::proto::CompressionType value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.compression)
}

// optional uint32 uncompressed_size = 9 [default = 0];
inline bool MessageMetadata::_internal_has_uncompressed_size() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MessageMetadata::has_uncompressed_size() const {
  return _internal_has_uncompressed_size();
}
inline void MessageMetadata::clear_uncompressed_size() {
  uncompressed_size_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MessageMetadata::_internal_uncompressed_size() const {
  return uncompressed_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MessageMetadata::uncompressed_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.uncompressed_size)
  return _internal_uncompressed_size();
}
inline void MessageMetadata::_internal_set_uncompressed_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  uncompressed_size_ = value;
}
inline void MessageMetadata::set_uncompressed_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_uncompressed_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.uncompressed_size)
}

// optional int32 num_messages_in_batch = 11 [default = 1];
inline bool MessageMetadata::_internal_has_num_messages_in_batch() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool MessageMetadata::has_num_messages_in_batch() const {
  return _internal_has_num_messages_in_batch();
}
inline void MessageMetadata::clear_num_messages_in_batch() {
  num_messages_in_batch_ = 1;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::_internal_num_messages_in_batch() const {
  return num_messages_in_batch_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::num_messages_in_batch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.num_messages_in_batch)
  return _internal_num_messages_in_batch();
}
inline void MessageMetadata::_internal_set_num_messages_in_batch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x01000000u;
  num_messages_in_batch_ = value;
}
inline void MessageMetadata::set_num_messages_in_batch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_messages_in_batch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.num_messages_in_batch)
}

// optional uint64 event_time = 12 [default = 0];
inline bool MessageMetadata::_internal_has_event_time() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool MessageMetadata::has_event_time() const {
  return _internal_has_event_time();
}
inline void MessageMetadata::clear_event_time() {
  event_time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::_internal_event_time() const {
  return event_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::event_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.event_time)
  return _internal_event_time();
}
inline void MessageMetadata::_internal_set_event_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00001000u;
  event_time_ = value;
}
inline void MessageMetadata::set_event_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_event_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.event_time)
}

// repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
inline int MessageMetadata::_internal_encryption_keys_size() const {
  return encryption_keys_.size();
}
inline int MessageMetadata::encryption_keys_size() const {
  return _internal_encryption_keys_size();
}
inline void MessageMetadata::clear_encryption_keys() {
  encryption_keys_.Clear();
}
inline ::pulsar::proto::EncryptionKeys* MessageMetadata::mutable_encryption_keys(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.encryption_keys)
  return encryption_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >*
MessageMetadata::mutable_encryption_keys() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageMetadata.encryption_keys)
  return &encryption_keys_;
}
inline const ::pulsar::proto::EncryptionKeys& MessageMetadata::_internal_encryption_keys(int index) const {
  return encryption_keys_.Get(index);
}
inline const ::pulsar::proto::EncryptionKeys& MessageMetadata::encryption_keys(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.encryption_keys)
  return _internal_encryption_keys(index);
}
inline ::pulsar::proto::EncryptionKeys* MessageMetadata::_internal_add_encryption_keys() {
  return encryption_keys_.Add();
}
inline ::pulsar::proto::EncryptionKeys* MessageMetadata::add_encryption_keys() {
  ::pulsar::proto::EncryptionKeys* _add = _internal_add_encryption_keys();
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.encryption_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >&
MessageMetadata::encryption_keys() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageMetadata.encryption_keys)
  return encryption_keys_;
}

// optional string encryption_algo = 14;
inline bool MessageMetadata::_internal_has_encryption_algo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MessageMetadata::has_encryption_algo() const {
  return _internal_has_encryption_algo();
}
inline void MessageMetadata::clear_encryption_algo() {
  encryption_algo_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MessageMetadata::encryption_algo() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.encryption_algo)
  return _internal_encryption_algo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMetadata::set_encryption_algo(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 encryption_algo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.encryption_algo)
}
inline std::string* MessageMetadata::mutable_encryption_algo() {
  std::string* _s = _internal_mutable_encryption_algo();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.encryption_algo)
  return _s;
}
inline const std::string& MessageMetadata::_internal_encryption_algo() const {
  return encryption_algo_.Get();
}
inline void MessageMetadata::_internal_set_encryption_algo(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  encryption_algo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessageMetadata::_internal_mutable_encryption_algo() {
  _has_bits_[0] |= 0x00000008u;
  return encryption_algo_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessageMetadata::release_encryption_algo() {
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.encryption_algo)
  if (!_internal_has_encryption_algo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return encryption_algo_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessageMetadata::set_allocated_encryption_algo(std::string* encryption_algo) {
  if (encryption_algo != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  encryption_algo_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_algo,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.encryption_algo)
}

// optional bytes encryption_param = 15;
inline bool MessageMetadata::_internal_has_encryption_param() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MessageMetadata::has_encryption_param() const {
  return _internal_has_encryption_param();
}
inline void MessageMetadata::clear_encryption_param() {
  encryption_param_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MessageMetadata::encryption_param() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.encryption_param)
  return _internal_encryption_param();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMetadata::set_encryption_param(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 encryption_param_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.encryption_param)
}
inline std::string* MessageMetadata::mutable_encryption_param() {
  std::string* _s = _internal_mutable_encryption_param();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.encryption_param)
  return _s;
}
inline const std::string& MessageMetadata::_internal_encryption_param() const {
  return encryption_param_.Get();
}
inline void MessageMetadata::_internal_set_encryption_param(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  encryption_param_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessageMetadata::_internal_mutable_encryption_param() {
  _has_bits_[0] |= 0x00000010u;
  return encryption_param_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessageMetadata::release_encryption_param() {
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.encryption_param)
  if (!_internal_has_encryption_param()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return encryption_param_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessageMetadata::set_allocated_encryption_param(std::string* encryption_param) {
  if (encryption_param != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  encryption_param_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_param,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.encryption_param)
}

// optional bytes schema_version = 16;
inline bool MessageMetadata::_internal_has_schema_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MessageMetadata::has_schema_version() const {
  return _internal_has_schema_version();
}
inline void MessageMetadata::clear_schema_version() {
  schema_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& MessageMetadata::schema_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.schema_version)
  return _internal_schema_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMetadata::set_schema_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 schema_version_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.schema_version)
}
inline std::string* MessageMetadata::mutable_schema_version() {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.schema_version)
  return _s;
}
inline const std::string& MessageMetadata::_internal_schema_version() const {
  return schema_version_.Get();
}
inline void MessageMetadata::_internal_set_schema_version(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessageMetadata::_internal_mutable_schema_version() {
  _has_bits_[0] |= 0x00000020u;
  return schema_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessageMetadata::release_schema_version() {
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.schema_version)
  if (!_internal_has_schema_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return schema_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessageMetadata::set_allocated_schema_version(std::string* schema_version) {
  if (schema_version != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  schema_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.schema_version)
}

// optional bool partition_key_b64_encoded = 17 [default = false];
inline bool MessageMetadata::_internal_has_partition_key_b64_encoded() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool MessageMetadata::has_partition_key_b64_encoded() const {
  return _internal_has_partition_key_b64_encoded();
}
inline void MessageMetadata::clear_partition_key_b64_encoded() {
  partition_key_b64_encoded_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool MessageMetadata::_internal_partition_key_b64_encoded() const {
  return partition_key_b64_encoded_;
}
inline bool MessageMetadata::partition_key_b64_encoded() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.partition_key_b64_encoded)
  return _internal_partition_key_b64_encoded();
}
inline void MessageMetadata::_internal_set_partition_key_b64_encoded(bool value) {
  _has_bits_[0] |= 0x00020000u;
  partition_key_b64_encoded_ = value;
}
inline void MessageMetadata::set_partition_key_b64_encoded(bool value) {
  _internal_set_partition_key_b64_encoded(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.partition_key_b64_encoded)
}

// optional bytes ordering_key = 18;
inline bool MessageMetadata::_internal_has_ordering_key() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MessageMetadata::has_ordering_key() const {
  return _internal_has_ordering_key();
}
inline void MessageMetadata::clear_ordering_key() {
  ordering_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& MessageMetadata::ordering_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.ordering_key)
  return _internal_ordering_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMetadata::set_ordering_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 ordering_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.ordering_key)
}
inline std::string* MessageMetadata::mutable_ordering_key() {
  std::string* _s = _internal_mutable_ordering_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.ordering_key)
  return _s;
}
inline const std::string& MessageMetadata::_internal_ordering_key() const {
  return ordering_key_.Get();
}
inline void MessageMetadata::_internal_set_ordering_key(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  ordering_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessageMetadata::_internal_mutable_ordering_key() {
  _has_bits_[0] |= 0x00000040u;
  return ordering_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessageMetadata::release_ordering_key() {
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.ordering_key)
  if (!_internal_has_ordering_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return ordering_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessageMetadata::set_allocated_ordering_key(std::string* ordering_key) {
  if (ordering_key != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  ordering_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ordering_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.ordering_key)
}

// optional int64 deliver_at_time = 19;
inline bool MessageMetadata::_internal_has_deliver_at_time() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool MessageMetadata::has_deliver_at_time() const {
  return _internal_has_deliver_at_time();
}
inline void MessageMetadata::clear_deliver_at_time() {
  deliver_at_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MessageMetadata::_internal_deliver_at_time() const {
  return deliver_at_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MessageMetadata::deliver_at_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.deliver_at_time)
  return _internal_deliver_at_time();
}
inline void MessageMetadata::_internal_set_deliver_at_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  deliver_at_time_ = value;
}
inline void MessageMetadata::set_deliver_at_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_deliver_at_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.deliver_at_time)
}

// optional int32 marker_type = 20;
inline bool MessageMetadata::_internal_has_marker_type() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool MessageMetadata::has_marker_type() const {
  return _internal_has_marker_type();
}
inline void MessageMetadata::clear_marker_type() {
  marker_type_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::_internal_marker_type() const {
  return marker_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::marker_type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.marker_type)
  return _internal_marker_type();
}
inline void MessageMetadata::_internal_set_marker_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00010000u;
  marker_type_ = value;
}
inline void MessageMetadata::set_marker_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_marker_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.marker_type)
}

// optional uint64 txnid_least_bits = 22;
inline bool MessageMetadata::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool MessageMetadata::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void MessageMetadata::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void MessageMetadata::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00004000u;
  txnid_least_bits_ = value;
}
inline void MessageMetadata::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 23;
inline bool MessageMetadata::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool MessageMetadata::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void MessageMetadata::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void MessageMetadata::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00008000u;
  txnid_most_bits_ = value;
}
inline void MessageMetadata::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.txnid_most_bits)
}

// optional uint64 highest_sequence_id = 24 [default = 0];
inline bool MessageMetadata::_internal_has_highest_sequence_id() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool MessageMetadata::has_highest_sequence_id() const {
  return _internal_has_highest_sequence_id();
}
inline void MessageMetadata::clear_highest_sequence_id() {
  highest_sequence_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::_internal_highest_sequence_id() const {
  return highest_sequence_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MessageMetadata::highest_sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.highest_sequence_id)
  return _internal_highest_sequence_id();
}
inline void MessageMetadata::_internal_set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00100000u;
  highest_sequence_id_ = value;
}
inline void MessageMetadata::set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_highest_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.highest_sequence_id)
}

// optional bool null_value = 25 [default = false];
inline bool MessageMetadata::_internal_has_null_value() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool MessageMetadata::has_null_value() const {
  return _internal_has_null_value();
}
inline void MessageMetadata::clear_null_value() {
  null_value_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool MessageMetadata::_internal_null_value() const {
  return null_value_;
}
inline bool MessageMetadata::null_value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.null_value)
  return _internal_null_value();
}
inline void MessageMetadata::_internal_set_null_value(bool value) {
  _has_bits_[0] |= 0x00040000u;
  null_value_ = value;
}
inline void MessageMetadata::set_null_value(bool value) {
  _internal_set_null_value(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.null_value)
}

// optional string uuid = 26;
inline bool MessageMetadata::_internal_has_uuid() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MessageMetadata::has_uuid() const {
  return _internal_has_uuid();
}
inline void MessageMetadata::clear_uuid() {
  uuid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& MessageMetadata::uuid() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMetadata::set_uuid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.uuid)
}
inline std::string* MessageMetadata::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.uuid)
  return _s;
}
inline const std::string& MessageMetadata::_internal_uuid() const {
  return uuid_.Get();
}
inline void MessageMetadata::_internal_set_uuid(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessageMetadata::_internal_mutable_uuid() {
  _has_bits_[0] |= 0x00000080u;
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessageMetadata::release_uuid() {
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.uuid)
  if (!_internal_has_uuid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return uuid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessageMetadata::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.uuid)
}

// optional int32 num_chunks_from_msg = 27;
inline bool MessageMetadata::_internal_has_num_chunks_from_msg() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool MessageMetadata::has_num_chunks_from_msg() const {
  return _internal_has_num_chunks_from_msg();
}
inline void MessageMetadata::clear_num_chunks_from_msg() {
  num_chunks_from_msg_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::_internal_num_chunks_from_msg() const {
  return num_chunks_from_msg_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::num_chunks_from_msg() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.num_chunks_from_msg)
  return _internal_num_chunks_from_msg();
}
inline void MessageMetadata::_internal_set_num_chunks_from_msg(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00200000u;
  num_chunks_from_msg_ = value;
}
inline void MessageMetadata::set_num_chunks_from_msg(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_chunks_from_msg(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.num_chunks_from_msg)
}

// optional int32 total_chunk_msg_size = 28;
inline bool MessageMetadata::_internal_has_total_chunk_msg_size() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool MessageMetadata::has_total_chunk_msg_size() const {
  return _internal_has_total_chunk_msg_size();
}
inline void MessageMetadata::clear_total_chunk_msg_size() {
  total_chunk_msg_size_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::_internal_total_chunk_msg_size() const {
  return total_chunk_msg_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::total_chunk_msg_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.total_chunk_msg_size)
  return _internal_total_chunk_msg_size();
}
inline void MessageMetadata::_internal_set_total_chunk_msg_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00400000u;
  total_chunk_msg_size_ = value;
}
inline void MessageMetadata::set_total_chunk_msg_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_total_chunk_msg_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.total_chunk_msg_size)
}

// optional int32 chunk_id = 29;
inline bool MessageMetadata::_internal_has_chunk_id() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool MessageMetadata::has_chunk_id() const {
  return _internal_has_chunk_id();
}
inline void MessageMetadata::clear_chunk_id() {
  chunk_id_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::_internal_chunk_id() const {
  return chunk_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageMetadata::chunk_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.chunk_id)
  return _internal_chunk_id();
}
inline void MessageMetadata::_internal_set_chunk_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00800000u;
  chunk_id_ = value;
}
inline void MessageMetadata::set_chunk_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_chunk_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.chunk_id)
}

// optional bool null_partition_key = 30 [default = false];
inline bool MessageMetadata::_internal_has_null_partition_key() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool MessageMetadata::has_null_partition_key() const {
  return _internal_has_null_partition_key();
}
inline void MessageMetadata::clear_null_partition_key() {
  null_partition_key_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool MessageMetadata::_internal_null_partition_key() const {
  return null_partition_key_;
}
inline bool MessageMetadata::null_partition_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.null_partition_key)
  return _internal_null_partition_key();
}
inline void MessageMetadata::_internal_set_null_partition_key(bool value) {
  _has_bits_[0] |= 0x00080000u;
  null_partition_key_ = value;
}
inline void MessageMetadata::set_null_partition_key(bool value) {
  _internal_set_null_partition_key(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.null_partition_key)
}

// -------------------------------------------------------------------

// SingleMessageMetadata

// repeated .pulsar.proto.KeyValue properties = 1;
inline int SingleMessageMetadata::_internal_properties_size() const {
  return properties_.size();
}
inline int SingleMessageMetadata::properties_size() const {
  return _internal_properties_size();
}
inline void SingleMessageMetadata::clear_properties() {
  properties_.Clear();
}
inline ::pulsar::proto::KeyValue* SingleMessageMetadata::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.SingleMessageMetadata.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
SingleMessageMetadata::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.SingleMessageMetadata.properties)
  return &properties_;
}
inline const ::pulsar::proto::KeyValue& SingleMessageMetadata::_internal_properties(int index) const {
  return properties_.Get(index);
}
inline const ::pulsar::proto::KeyValue& SingleMessageMetadata::properties(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.properties)
  return _internal_properties(index);
}
inline ::pulsar::proto::KeyValue* SingleMessageMetadata::_internal_add_properties() {
  return properties_.Add();
}
inline ::pulsar::proto::KeyValue* SingleMessageMetadata::add_properties() {
  ::pulsar::proto::KeyValue* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:pulsar.proto.SingleMessageMetadata.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
SingleMessageMetadata::properties() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.SingleMessageMetadata.properties)
  return properties_;
}

// optional string partition_key = 2;
inline bool SingleMessageMetadata::_internal_has_partition_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SingleMessageMetadata::has_partition_key() const {
  return _internal_has_partition_key();
}
inline void SingleMessageMetadata::clear_partition_key() {
  partition_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SingleMessageMetadata::partition_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.partition_key)
  return _internal_partition_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleMessageMetadata::set_partition_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 partition_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.partition_key)
}
inline std::string* SingleMessageMetadata::mutable_partition_key() {
  std::string* _s = _internal_mutable_partition_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.SingleMessageMetadata.partition_key)
  return _s;
}
inline const std::string& SingleMessageMetadata::_internal_partition_key() const {
  return partition_key_.Get();
}
inline void SingleMessageMetadata::_internal_set_partition_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  partition_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SingleMessageMetadata::_internal_mutable_partition_key() {
  _has_bits_[0] |= 0x00000001u;
  return partition_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SingleMessageMetadata::release_partition_key() {
  // @@protoc_insertion_point(field_release:pulsar.proto.SingleMessageMetadata.partition_key)
  if (!_internal_has_partition_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return partition_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SingleMessageMetadata::set_allocated_partition_key(std::string* partition_key) {
  if (partition_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  partition_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.SingleMessageMetadata.partition_key)
}

// required int32 payload_size = 3;
inline bool SingleMessageMetadata::_internal_has_payload_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SingleMessageMetadata::has_payload_size() const {
  return _internal_has_payload_size();
}
inline void SingleMessageMetadata::clear_payload_size() {
  payload_size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleMessageMetadata::_internal_payload_size() const {
  return payload_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleMessageMetadata::payload_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.payload_size)
  return _internal_payload_size();
}
inline void SingleMessageMetadata::_internal_set_payload_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  payload_size_ = value;
}
inline void SingleMessageMetadata::set_payload_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_payload_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.payload_size)
}

// optional bool compacted_out = 4 [default = false];
inline bool SingleMessageMetadata::_internal_has_compacted_out() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SingleMessageMetadata::has_compacted_out() const {
  return _internal_has_compacted_out();
}
inline void SingleMessageMetadata::clear_compacted_out() {
  compacted_out_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool SingleMessageMetadata::_internal_compacted_out() const {
  return compacted_out_;
}
inline bool SingleMessageMetadata::compacted_out() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.compacted_out)
  return _internal_compacted_out();
}
inline void SingleMessageMetadata::_internal_set_compacted_out(bool value) {
  _has_bits_[0] |= 0x00000010u;
  compacted_out_ = value;
}
inline void SingleMessageMetadata::set_compacted_out(bool value) {
  _internal_set_compacted_out(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.compacted_out)
}

// optional uint64 event_time = 5 [default = 0];
inline bool SingleMessageMetadata::_internal_has_event_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SingleMessageMetadata::has_event_time() const {
  return _internal_has_event_time();
}
inline void SingleMessageMetadata::clear_event_time() {
  event_time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SingleMessageMetadata::_internal_event_time() const {
  return event_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SingleMessageMetadata::event_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.event_time)
  return _internal_event_time();
}
inline void SingleMessageMetadata::_internal_set_event_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  event_time_ = value;
}
inline void SingleMessageMetadata::set_event_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_event_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.event_time)
}

// optional bool partition_key_b64_encoded = 6 [default = false];
inline bool SingleMessageMetadata::_internal_has_partition_key_b64_encoded() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SingleMessageMetadata::has_partition_key_b64_encoded() const {
  return _internal_has_partition_key_b64_encoded();
}
inline void SingleMessageMetadata::clear_partition_key_b64_encoded() {
  partition_key_b64_encoded_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool SingleMessageMetadata::_internal_partition_key_b64_encoded() const {
  return partition_key_b64_encoded_;
}
inline bool SingleMessageMetadata::partition_key_b64_encoded() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.partition_key_b64_encoded)
  return _internal_partition_key_b64_encoded();
}
inline void SingleMessageMetadata::_internal_set_partition_key_b64_encoded(bool value) {
  _has_bits_[0] |= 0x00000020u;
  partition_key_b64_encoded_ = value;
}
inline void SingleMessageMetadata::set_partition_key_b64_encoded(bool value) {
  _internal_set_partition_key_b64_encoded(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.partition_key_b64_encoded)
}

// optional bytes ordering_key = 7;
inline bool SingleMessageMetadata::_internal_has_ordering_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SingleMessageMetadata::has_ordering_key() const {
  return _internal_has_ordering_key();
}
inline void SingleMessageMetadata::clear_ordering_key() {
  ordering_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SingleMessageMetadata::ordering_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.ordering_key)
  return _internal_ordering_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleMessageMetadata::set_ordering_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ordering_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.ordering_key)
}
inline std::string* SingleMessageMetadata::mutable_ordering_key() {
  std::string* _s = _internal_mutable_ordering_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.SingleMessageMetadata.ordering_key)
  return _s;
}
inline const std::string& SingleMessageMetadata::_internal_ordering_key() const {
  return ordering_key_.Get();
}
inline void SingleMessageMetadata::_internal_set_ordering_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ordering_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SingleMessageMetadata::_internal_mutable_ordering_key() {
  _has_bits_[0] |= 0x00000002u;
  return ordering_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SingleMessageMetadata::release_ordering_key() {
  // @@protoc_insertion_point(field_release:pulsar.proto.SingleMessageMetadata.ordering_key)
  if (!_internal_has_ordering_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ordering_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SingleMessageMetadata::set_allocated_ordering_key(std::string* ordering_key) {
  if (ordering_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ordering_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ordering_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.SingleMessageMetadata.ordering_key)
}

// optional uint64 sequence_id = 8;
inline bool SingleMessageMetadata::_internal_has_sequence_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SingleMessageMetadata::has_sequence_id() const {
  return _internal_has_sequence_id();
}
inline void SingleMessageMetadata::clear_sequence_id() {
  sequence_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SingleMessageMetadata::_internal_sequence_id() const {
  return sequence_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SingleMessageMetadata::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.sequence_id)
  return _internal_sequence_id();
}
inline void SingleMessageMetadata::_internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  sequence_id_ = value;
}
inline void SingleMessageMetadata::set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.sequence_id)
}

// optional bool null_value = 9 [default = false];
inline bool SingleMessageMetadata::_internal_has_null_value() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SingleMessageMetadata::has_null_value() const {
  return _internal_has_null_value();
}
inline void SingleMessageMetadata::clear_null_value() {
  null_value_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool SingleMessageMetadata::_internal_null_value() const {
  return null_value_;
}
inline bool SingleMessageMetadata::null_value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.null_value)
  return _internal_null_value();
}
inline void SingleMessageMetadata::_internal_set_null_value(bool value) {
  _has_bits_[0] |= 0x00000040u;
  null_value_ = value;
}
inline void SingleMessageMetadata::set_null_value(bool value) {
  _internal_set_null_value(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.null_value)
}

// optional bool null_partition_key = 10 [default = false];
inline bool SingleMessageMetadata::_internal_has_null_partition_key() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SingleMessageMetadata::has_null_partition_key() const {
  return _internal_has_null_partition_key();
}
inline void SingleMessageMetadata::clear_null_partition_key() {
  null_partition_key_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool SingleMessageMetadata::_internal_null_partition_key() const {
  return null_partition_key_;
}
inline bool SingleMessageMetadata::null_partition_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.null_partition_key)
  return _internal_null_partition_key();
}
inline void SingleMessageMetadata::_internal_set_null_partition_key(bool value) {
  _has_bits_[0] |= 0x00000080u;
  null_partition_key_ = value;
}
inline void SingleMessageMetadata::set_null_partition_key(bool value) {
  _internal_set_null_partition_key(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.null_partition_key)
}

// -------------------------------------------------------------------

// BrokerEntryMetadata

// optional uint64 broker_timestamp = 1;
inline bool BrokerEntryMetadata::_internal_has_broker_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BrokerEntryMetadata::has_broker_timestamp() const {
  return _internal_has_broker_timestamp();
}
inline void BrokerEntryMetadata::clear_broker_timestamp() {
  broker_timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BrokerEntryMetadata::_internal_broker_timestamp() const {
  return broker_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BrokerEntryMetadata::broker_timestamp() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BrokerEntryMetadata.broker_timestamp)
  return _internal_broker_timestamp();
}
inline void BrokerEntryMetadata::_internal_set_broker_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  broker_timestamp_ = value;
}
inline void BrokerEntryMetadata::set_broker_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_broker_timestamp(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.BrokerEntryMetadata.broker_timestamp)
}

// optional uint64 index = 2;
inline bool BrokerEntryMetadata::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BrokerEntryMetadata::has_index() const {
  return _internal_has_index();
}
inline void BrokerEntryMetadata::clear_index() {
  index_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BrokerEntryMetadata::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BrokerEntryMetadata::index() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BrokerEntryMetadata.index)
  return _internal_index();
}
inline void BrokerEntryMetadata::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  index_ = value;
}
inline void BrokerEntryMetadata::set_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.BrokerEntryMetadata.index)
}

// -------------------------------------------------------------------

// CommandConnect

// required string client_version = 1;
inline bool CommandConnect::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandConnect::has_client_version() const {
  return _internal_has_client_version();
}
inline void CommandConnect::clear_client_version() {
  client_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandConnect::client_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.client_version)
  return _internal_client_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConnect::set_client_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 client_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.client_version)
}
inline std::string* CommandConnect::mutable_client_version() {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.client_version)
  return _s;
}
inline const std::string& CommandConnect::_internal_client_version() const {
  return client_version_.Get();
}
inline void CommandConnect::_internal_set_client_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConnect::_internal_mutable_client_version() {
  _has_bits_[0] |= 0x00000001u;
  return client_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConnect::release_client_version() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.client_version)
  if (!_internal_has_client_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConnect::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.client_version)
}

// optional .pulsar.proto.AuthMethod auth_method = 2;
inline bool CommandConnect::_internal_has_auth_method() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommandConnect::has_auth_method() const {
  return _internal_has_auth_method();
}
inline void CommandConnect::clear_auth_method() {
  auth_method_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::pulsar::proto::AuthMethod CommandConnect::_internal_auth_method() const {
  return static_cast< ::pulsar::proto::AuthMethod >(auth_method_);
}
inline ::pulsar::proto::AuthMethod CommandConnect::auth_method() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.auth_method)
  return _internal_auth_method();
}
inline void CommandConnect::_internal_set_auth_method(::pulsar::proto::AuthMethod value) {
  assert(::pulsar::proto::AuthMethod_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  auth_method_ = value;
}
inline void CommandConnect::set_auth_method(::pulsar::proto::AuthMethod value) {
  _internal_set_auth_method(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.auth_method)
}

// optional string auth_method_name = 5;
inline bool CommandConnect::_internal_has_auth_method_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandConnect::has_auth_method_name() const {
  return _internal_has_auth_method_name();
}
inline void CommandConnect::clear_auth_method_name() {
  auth_method_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandConnect::auth_method_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.auth_method_name)
  return _internal_auth_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConnect::set_auth_method_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 auth_method_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.auth_method_name)
}
inline std::string* CommandConnect::mutable_auth_method_name() {
  std::string* _s = _internal_mutable_auth_method_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.auth_method_name)
  return _s;
}
inline const std::string& CommandConnect::_internal_auth_method_name() const {
  return auth_method_name_.Get();
}
inline void CommandConnect::_internal_set_auth_method_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  auth_method_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConnect::_internal_mutable_auth_method_name() {
  _has_bits_[0] |= 0x00000004u;
  return auth_method_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConnect::release_auth_method_name() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.auth_method_name)
  if (!_internal_has_auth_method_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return auth_method_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConnect::set_allocated_auth_method_name(std::string* auth_method_name) {
  if (auth_method_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  auth_method_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_method_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.auth_method_name)
}

// optional bytes auth_data = 3;
inline bool CommandConnect::_internal_has_auth_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandConnect::has_auth_data() const {
  return _internal_has_auth_data();
}
inline void CommandConnect::clear_auth_data() {
  auth_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandConnect::auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.auth_data)
  return _internal_auth_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConnect::set_auth_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 auth_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.auth_data)
}
inline std::string* CommandConnect::mutable_auth_data() {
  std::string* _s = _internal_mutable_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.auth_data)
  return _s;
}
inline const std::string& CommandConnect::_internal_auth_data() const {
  return auth_data_.Get();
}
inline void CommandConnect::_internal_set_auth_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConnect::_internal_mutable_auth_data() {
  _has_bits_[0] |= 0x00000002u;
  return auth_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConnect::release_auth_data() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.auth_data)
  if (!_internal_has_auth_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return auth_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConnect::set_allocated_auth_data(std::string* auth_data) {
  if (auth_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  auth_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.auth_data)
}

// optional int32 protocol_version = 4 [default = 0];
inline bool CommandConnect::_internal_has_protocol_version() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommandConnect::has_protocol_version() const {
  return _internal_has_protocol_version();
}
inline void CommandConnect::clear_protocol_version() {
  protocol_version_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandConnect::_internal_protocol_version() const {
  return protocol_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandConnect::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.protocol_version)
  return _internal_protocol_version();
}
inline void CommandConnect::_internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  protocol_version_ = value;
}
inline void CommandConnect::set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.protocol_version)
}

// optional string proxy_to_broker_url = 6;
inline bool CommandConnect::_internal_has_proxy_to_broker_url() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandConnect::has_proxy_to_broker_url() const {
  return _internal_has_proxy_to_broker_url();
}
inline void CommandConnect::clear_proxy_to_broker_url() {
  proxy_to_broker_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandConnect::proxy_to_broker_url() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.proxy_to_broker_url)
  return _internal_proxy_to_broker_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConnect::set_proxy_to_broker_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 proxy_to_broker_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.proxy_to_broker_url)
}
inline std::string* CommandConnect::mutable_proxy_to_broker_url() {
  std::string* _s = _internal_mutable_proxy_to_broker_url();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.proxy_to_broker_url)
  return _s;
}
inline const std::string& CommandConnect::_internal_proxy_to_broker_url() const {
  return proxy_to_broker_url_.Get();
}
inline void CommandConnect::_internal_set_proxy_to_broker_url(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  proxy_to_broker_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConnect::_internal_mutable_proxy_to_broker_url() {
  _has_bits_[0] |= 0x00000008u;
  return proxy_to_broker_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConnect::release_proxy_to_broker_url() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.proxy_to_broker_url)
  if (!_internal_has_proxy_to_broker_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return proxy_to_broker_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConnect::set_allocated_proxy_to_broker_url(std::string* proxy_to_broker_url) {
  if (proxy_to_broker_url != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  proxy_to_broker_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proxy_to_broker_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.proxy_to_broker_url)
}

// optional string original_principal = 7;
inline bool CommandConnect::_internal_has_original_principal() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandConnect::has_original_principal() const {
  return _internal_has_original_principal();
}
inline void CommandConnect::clear_original_principal() {
  original_principal_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommandConnect::original_principal() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.original_principal)
  return _internal_original_principal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConnect::set_original_principal(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 original_principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.original_principal)
}
inline std::string* CommandConnect::mutable_original_principal() {
  std::string* _s = _internal_mutable_original_principal();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.original_principal)
  return _s;
}
inline const std::string& CommandConnect::_internal_original_principal() const {
  return original_principal_.Get();
}
inline void CommandConnect::_internal_set_original_principal(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  original_principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConnect::_internal_mutable_original_principal() {
  _has_bits_[0] |= 0x00000010u;
  return original_principal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConnect::release_original_principal() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.original_principal)
  if (!_internal_has_original_principal()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return original_principal_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConnect::set_allocated_original_principal(std::string* original_principal) {
  if (original_principal != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  original_principal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_principal,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.original_principal)
}

// optional string original_auth_data = 8;
inline bool CommandConnect::_internal_has_original_auth_data() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandConnect::has_original_auth_data() const {
  return _internal_has_original_auth_data();
}
inline void CommandConnect::clear_original_auth_data() {
  original_auth_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CommandConnect::original_auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.original_auth_data)
  return _internal_original_auth_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConnect::set_original_auth_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 original_auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.original_auth_data)
}
inline std::string* CommandConnect::mutable_original_auth_data() {
  std::string* _s = _internal_mutable_original_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.original_auth_data)
  return _s;
}
inline const std::string& CommandConnect::_internal_original_auth_data() const {
  return original_auth_data_.Get();
}
inline void CommandConnect::_internal_set_original_auth_data(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  original_auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConnect::_internal_mutable_original_auth_data() {
  _has_bits_[0] |= 0x00000020u;
  return original_auth_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConnect::release_original_auth_data() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.original_auth_data)
  if (!_internal_has_original_auth_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return original_auth_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConnect::set_allocated_original_auth_data(std::string* original_auth_data) {
  if (original_auth_data != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  original_auth_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_auth_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.original_auth_data)
}

// optional string original_auth_method = 9;
inline bool CommandConnect::_internal_has_original_auth_method() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandConnect::has_original_auth_method() const {
  return _internal_has_original_auth_method();
}
inline void CommandConnect::clear_original_auth_method() {
  original_auth_method_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CommandConnect::original_auth_method() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.original_auth_method)
  return _internal_original_auth_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConnect::set_original_auth_method(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 original_auth_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.original_auth_method)
}
inline std::string* CommandConnect::mutable_original_auth_method() {
  std::string* _s = _internal_mutable_original_auth_method();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.original_auth_method)
  return _s;
}
inline const std::string& CommandConnect::_internal_original_auth_method() const {
  return original_auth_method_.Get();
}
inline void CommandConnect::_internal_set_original_auth_method(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  original_auth_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConnect::_internal_mutable_original_auth_method() {
  _has_bits_[0] |= 0x00000040u;
  return original_auth_method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConnect::release_original_auth_method() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.original_auth_method)
  if (!_internal_has_original_auth_method()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return original_auth_method_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConnect::set_allocated_original_auth_method(std::string* original_auth_method) {
  if (original_auth_method != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  original_auth_method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_auth_method,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.original_auth_method)
}

// optional .pulsar.proto.FeatureFlags feature_flags = 10;
inline bool CommandConnect::_internal_has_feature_flags() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || feature_flags_ != nullptr);
  return value;
}
inline bool CommandConnect::has_feature_flags() const {
  return _internal_has_feature_flags();
}
inline void CommandConnect::clear_feature_flags() {
  if (feature_flags_ != nullptr) feature_flags_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::pulsar::proto::FeatureFlags& CommandConnect::_internal_feature_flags() const {
  const ::pulsar::proto::FeatureFlags* p = feature_flags_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::FeatureFlags&>(
      ::pulsar::proto::_FeatureFlags_default_instance_);
}
inline const ::pulsar::proto::FeatureFlags& CommandConnect::feature_flags() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.feature_flags)
  return _internal_feature_flags();
}
inline void CommandConnect::unsafe_arena_set_allocated_feature_flags(
    ::pulsar::proto::FeatureFlags* feature_flags) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feature_flags_);
  }
  feature_flags_ = feature_flags;
  if (feature_flags) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandConnect.feature_flags)
}
inline ::pulsar::proto::FeatureFlags* CommandConnect::release_feature_flags() {
  _has_bits_[0] &= ~0x00000080u;
  ::pulsar::proto::FeatureFlags* temp = feature_flags_;
  feature_flags_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::FeatureFlags* CommandConnect::unsafe_arena_release_feature_flags() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.feature_flags)
  _has_bits_[0] &= ~0x00000080u;
  ::pulsar::proto::FeatureFlags* temp = feature_flags_;
  feature_flags_ = nullptr;
  return temp;
}
inline ::pulsar::proto::FeatureFlags* CommandConnect::_internal_mutable_feature_flags() {
  _has_bits_[0] |= 0x00000080u;
  if (feature_flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::FeatureFlags>(GetArenaForAllocation());
    feature_flags_ = p;
  }
  return feature_flags_;
}
inline ::pulsar::proto::FeatureFlags* CommandConnect::mutable_feature_flags() {
  ::pulsar::proto::FeatureFlags* _msg = _internal_mutable_feature_flags();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.feature_flags)
  return _msg;
}
inline void CommandConnect::set_allocated_feature_flags(::pulsar::proto::FeatureFlags* feature_flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete feature_flags_;
  }
  if (feature_flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::FeatureFlags>::GetOwningArena(feature_flags);
    if (message_arena != submessage_arena) {
      feature_flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_flags, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  feature_flags_ = feature_flags;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.feature_flags)
}

// -------------------------------------------------------------------

// FeatureFlags

// optional bool supports_auth_refresh = 1 [default = false];
inline bool FeatureFlags::_internal_has_supports_auth_refresh() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FeatureFlags::has_supports_auth_refresh() const {
  return _internal_has_supports_auth_refresh();
}
inline void FeatureFlags::clear_supports_auth_refresh() {
  supports_auth_refresh_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool FeatureFlags::_internal_supports_auth_refresh() const {
  return supports_auth_refresh_;
}
inline bool FeatureFlags::supports_auth_refresh() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.FeatureFlags.supports_auth_refresh)
  return _internal_supports_auth_refresh();
}
inline void FeatureFlags::_internal_set_supports_auth_refresh(bool value) {
  _has_bits_[0] |= 0x00000001u;
  supports_auth_refresh_ = value;
}
inline void FeatureFlags::set_supports_auth_refresh(bool value) {
  _internal_set_supports_auth_refresh(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.FeatureFlags.supports_auth_refresh)
}

// optional bool supports_broker_entry_metadata = 2 [default = false];
inline bool FeatureFlags::_internal_has_supports_broker_entry_metadata() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FeatureFlags::has_supports_broker_entry_metadata() const {
  return _internal_has_supports_broker_entry_metadata();
}
inline void FeatureFlags::clear_supports_broker_entry_metadata() {
  supports_broker_entry_metadata_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool FeatureFlags::_internal_supports_broker_entry_metadata() const {
  return supports_broker_entry_metadata_;
}
inline bool FeatureFlags::supports_broker_entry_metadata() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.FeatureFlags.supports_broker_entry_metadata)
  return _internal_supports_broker_entry_metadata();
}
inline void FeatureFlags::_internal_set_supports_broker_entry_metadata(bool value) {
  _has_bits_[0] |= 0x00000002u;
  supports_broker_entry_metadata_ = value;
}
inline void FeatureFlags::set_supports_broker_entry_metadata(bool value) {
  _internal_set_supports_broker_entry_metadata(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.FeatureFlags.supports_broker_entry_metadata)
}

// optional bool supports_partial_producer = 3 [default = false];
inline bool FeatureFlags::_internal_has_supports_partial_producer() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FeatureFlags::has_supports_partial_producer() const {
  return _internal_has_supports_partial_producer();
}
inline void FeatureFlags::clear_supports_partial_producer() {
  supports_partial_producer_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool FeatureFlags::_internal_supports_partial_producer() const {
  return supports_partial_producer_;
}
inline bool FeatureFlags::supports_partial_producer() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.FeatureFlags.supports_partial_producer)
  return _internal_supports_partial_producer();
}
inline void FeatureFlags::_internal_set_supports_partial_producer(bool value) {
  _has_bits_[0] |= 0x00000004u;
  supports_partial_producer_ = value;
}
inline void FeatureFlags::set_supports_partial_producer(bool value) {
  _internal_set_supports_partial_producer(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.FeatureFlags.supports_partial_producer)
}

// optional bool supports_topic_watchers = 4 [default = false];
inline bool FeatureFlags::_internal_has_supports_topic_watchers() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FeatureFlags::has_supports_topic_watchers() const {
  return _internal_has_supports_topic_watchers();
}
inline void FeatureFlags::clear_supports_topic_watchers() {
  supports_topic_watchers_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool FeatureFlags::_internal_supports_topic_watchers() const {
  return supports_topic_watchers_;
}
inline bool FeatureFlags::supports_topic_watchers() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.FeatureFlags.supports_topic_watchers)
  return _internal_supports_topic_watchers();
}
inline void FeatureFlags::_internal_set_supports_topic_watchers(bool value) {
  _has_bits_[0] |= 0x00000008u;
  supports_topic_watchers_ = value;
}
inline void FeatureFlags::set_supports_topic_watchers(bool value) {
  _internal_set_supports_topic_watchers(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.FeatureFlags.supports_topic_watchers)
}

// -------------------------------------------------------------------

// CommandConnected

// required string server_version = 1;
inline bool CommandConnected::_internal_has_server_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandConnected::has_server_version() const {
  return _internal_has_server_version();
}
inline void CommandConnected::clear_server_version() {
  server_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandConnected::server_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.server_version)
  return _internal_server_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConnected::set_server_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnected.server_version)
}
inline std::string* CommandConnected::mutable_server_version() {
  std::string* _s = _internal_mutable_server_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnected.server_version)
  return _s;
}
inline const std::string& CommandConnected::_internal_server_version() const {
  return server_version_.Get();
}
inline void CommandConnected::_internal_set_server_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConnected::_internal_mutable_server_version() {
  _has_bits_[0] |= 0x00000001u;
  return server_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConnected::release_server_version() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnected.server_version)
  if (!_internal_has_server_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return server_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConnected::set_allocated_server_version(std::string* server_version) {
  if (server_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnected.server_version)
}

// optional int32 protocol_version = 2 [default = 0];
inline bool CommandConnected::_internal_has_protocol_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandConnected::has_protocol_version() const {
  return _internal_has_protocol_version();
}
inline void CommandConnected::clear_protocol_version() {
  protocol_version_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandConnected::_internal_protocol_version() const {
  return protocol_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandConnected::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.protocol_version)
  return _internal_protocol_version();
}
inline void CommandConnected::_internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  protocol_version_ = value;
}
inline void CommandConnected::set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnected.protocol_version)
}

// optional int32 max_message_size = 3;
inline bool CommandConnected::_internal_has_max_message_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandConnected::has_max_message_size() const {
  return _internal_has_max_message_size();
}
inline void CommandConnected::clear_max_message_size() {
  max_message_size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandConnected::_internal_max_message_size() const {
  return max_message_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandConnected::max_message_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.max_message_size)
  return _internal_max_message_size();
}
inline void CommandConnected::_internal_set_max_message_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  max_message_size_ = value;
}
inline void CommandConnected::set_max_message_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_message_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnected.max_message_size)
}

// optional .pulsar.proto.FeatureFlags feature_flags = 4;
inline bool CommandConnected::_internal_has_feature_flags() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || feature_flags_ != nullptr);
  return value;
}
inline bool CommandConnected::has_feature_flags() const {
  return _internal_has_feature_flags();
}
inline void CommandConnected::clear_feature_flags() {
  if (feature_flags_ != nullptr) feature_flags_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::FeatureFlags& CommandConnected::_internal_feature_flags() const {
  const ::pulsar::proto::FeatureFlags* p = feature_flags_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::FeatureFlags&>(
      ::pulsar::proto::_FeatureFlags_default_instance_);
}
inline const ::pulsar::proto::FeatureFlags& CommandConnected::feature_flags() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.feature_flags)
  return _internal_feature_flags();
}
inline void CommandConnected::unsafe_arena_set_allocated_feature_flags(
    ::pulsar::proto::FeatureFlags* feature_flags) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feature_flags_);
  }
  feature_flags_ = feature_flags;
  if (feature_flags) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandConnected.feature_flags)
}
inline ::pulsar::proto::FeatureFlags* CommandConnected::release_feature_flags() {
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::FeatureFlags* temp = feature_flags_;
  feature_flags_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::FeatureFlags* CommandConnected::unsafe_arena_release_feature_flags() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnected.feature_flags)
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::FeatureFlags* temp = feature_flags_;
  feature_flags_ = nullptr;
  return temp;
}
inline ::pulsar::proto::FeatureFlags* CommandConnected::_internal_mutable_feature_flags() {
  _has_bits_[0] |= 0x00000002u;
  if (feature_flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::FeatureFlags>(GetArenaForAllocation());
    feature_flags_ = p;
  }
  return feature_flags_;
}
inline ::pulsar::proto::FeatureFlags* CommandConnected::mutable_feature_flags() {
  ::pulsar::proto::FeatureFlags* _msg = _internal_mutable_feature_flags();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnected.feature_flags)
  return _msg;
}
inline void CommandConnected::set_allocated_feature_flags(::pulsar::proto::FeatureFlags* feature_flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete feature_flags_;
  }
  if (feature_flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::FeatureFlags>::GetOwningArena(feature_flags);
    if (message_arena != submessage_arena) {
      feature_flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_flags, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  feature_flags_ = feature_flags;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnected.feature_flags)
}

// -------------------------------------------------------------------

// CommandAuthResponse

// optional string client_version = 1;
inline bool CommandAuthResponse::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandAuthResponse::has_client_version() const {
  return _internal_has_client_version();
}
inline void CommandAuthResponse::clear_client_version() {
  client_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAuthResponse::client_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthResponse.client_version)
  return _internal_client_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandAuthResponse::set_client_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 client_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthResponse.client_version)
}
inline std::string* CommandAuthResponse::mutable_client_version() {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthResponse.client_version)
  return _s;
}
inline const std::string& CommandAuthResponse::_internal_client_version() const {
  return client_version_.Get();
}
inline void CommandAuthResponse::_internal_set_client_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandAuthResponse::_internal_mutable_client_version() {
  _has_bits_[0] |= 0x00000001u;
  return client_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandAuthResponse::release_client_version() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAuthResponse.client_version)
  if (!_internal_has_client_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return client_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandAuthResponse::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthResponse.client_version)
}

// optional .pulsar.proto.AuthData response = 2;
inline bool CommandAuthResponse::_internal_has_response() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || response_ != nullptr);
  return value;
}
inline bool CommandAuthResponse::has_response() const {
  return _internal_has_response();
}
inline void CommandAuthResponse::clear_response() {
  if (response_ != nullptr) response_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::AuthData& CommandAuthResponse::_internal_response() const {
  const ::pulsar::proto::AuthData* p = response_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::AuthData&>(
      ::pulsar::proto::_AuthData_default_instance_);
}
inline const ::pulsar::proto::AuthData& CommandAuthResponse::response() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthResponse.response)
  return _internal_response();
}
inline void CommandAuthResponse::unsafe_arena_set_allocated_response(
    ::pulsar::proto::AuthData* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  response_ = response;
  if (response) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandAuthResponse.response)
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::release_response() {
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::AuthData* temp = response_;
  response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAuthResponse.response)
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::AuthData* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::_internal_mutable_response() {
  _has_bits_[0] |= 0x00000002u;
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::AuthData>(GetArenaForAllocation());
    response_ = p;
  }
  return response_;
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::mutable_response() {
  ::pulsar::proto::AuthData* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthResponse.response)
  return _msg;
}
inline void CommandAuthResponse::set_allocated_response(::pulsar::proto::AuthData* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::AuthData>::GetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthResponse.response)
}

// optional int32 protocol_version = 3 [default = 0];
inline bool CommandAuthResponse::_internal_has_protocol_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandAuthResponse::has_protocol_version() const {
  return _internal_has_protocol_version();
}
inline void CommandAuthResponse::clear_protocol_version() {
  protocol_version_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandAuthResponse::_internal_protocol_version() const {
  return protocol_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandAuthResponse::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthResponse.protocol_version)
  return _internal_protocol_version();
}
inline void CommandAuthResponse::_internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  protocol_version_ = value;
}
inline void CommandAuthResponse::set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthResponse.protocol_version)
}

// -------------------------------------------------------------------

// CommandAuthChallenge

// optional string server_version = 1;
inline bool CommandAuthChallenge::_internal_has_server_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandAuthChallenge::has_server_version() const {
  return _internal_has_server_version();
}
inline void CommandAuthChallenge::clear_server_version() {
  server_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAuthChallenge::server_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthChallenge.server_version)
  return _internal_server_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandAuthChallenge::set_server_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthChallenge.server_version)
}
inline std::string* CommandAuthChallenge::mutable_server_version() {
  std::string* _s = _internal_mutable_server_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthChallenge.server_version)
  return _s;
}
inline const std::string& CommandAuthChallenge::_internal_server_version() const {
  return server_version_.Get();
}
inline void CommandAuthChallenge::_internal_set_server_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandAuthChallenge::_internal_mutable_server_version() {
  _has_bits_[0] |= 0x00000001u;
  return server_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandAuthChallenge::release_server_version() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAuthChallenge.server_version)
  if (!_internal_has_server_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return server_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandAuthChallenge::set_allocated_server_version(std::string* server_version) {
  if (server_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthChallenge.server_version)
}

// optional .pulsar.proto.AuthData challenge = 2;
inline bool CommandAuthChallenge::_internal_has_challenge() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || challenge_ != nullptr);
  return value;
}
inline bool CommandAuthChallenge::has_challenge() const {
  return _internal_has_challenge();
}
inline void CommandAuthChallenge::clear_challenge() {
  if (challenge_ != nullptr) challenge_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::AuthData& CommandAuthChallenge::_internal_challenge() const {
  const ::pulsar::proto::AuthData* p = challenge_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::AuthData&>(
      ::pulsar::proto::_AuthData_default_instance_);
}
inline const ::pulsar::proto::AuthData& CommandAuthChallenge::challenge() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthChallenge.challenge)
  return _internal_challenge();
}
inline void CommandAuthChallenge::unsafe_arena_set_allocated_challenge(
    ::pulsar::proto::AuthData* challenge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(challenge_);
  }
  challenge_ = challenge;
  if (challenge) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandAuthChallenge.challenge)
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::release_challenge() {
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::AuthData* temp = challenge_;
  challenge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::unsafe_arena_release_challenge() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAuthChallenge.challenge)
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::AuthData* temp = challenge_;
  challenge_ = nullptr;
  return temp;
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::_internal_mutable_challenge() {
  _has_bits_[0] |= 0x00000002u;
  if (challenge_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::AuthData>(GetArenaForAllocation());
    challenge_ = p;
  }
  return challenge_;
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::mutable_challenge() {
  ::pulsar::proto::AuthData* _msg = _internal_mutable_challenge();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthChallenge.challenge)
  return _msg;
}
inline void CommandAuthChallenge::set_allocated_challenge(::pulsar::proto::AuthData* challenge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete challenge_;
  }
  if (challenge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::AuthData>::GetOwningArena(challenge);
    if (message_arena != submessage_arena) {
      challenge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, challenge, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  challenge_ = challenge;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthChallenge.challenge)
}

// optional int32 protocol_version = 3 [default = 0];
inline bool CommandAuthChallenge::_internal_has_protocol_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandAuthChallenge::has_protocol_version() const {
  return _internal_has_protocol_version();
}
inline void CommandAuthChallenge::clear_protocol_version() {
  protocol_version_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandAuthChallenge::_internal_protocol_version() const {
  return protocol_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandAuthChallenge::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthChallenge.protocol_version)
  return _internal_protocol_version();
}
inline void CommandAuthChallenge::_internal_set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  protocol_version_ = value;
}
inline void CommandAuthChallenge::set_protocol_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthChallenge.protocol_version)
}

// -------------------------------------------------------------------

// AuthData

// optional string auth_method_name = 1;
inline bool AuthData::_internal_has_auth_method_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthData::has_auth_method_name() const {
  return _internal_has_auth_method_name();
}
inline void AuthData::clear_auth_method_name() {
  auth_method_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthData::auth_method_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.AuthData.auth_method_name)
  return _internal_auth_method_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthData::set_auth_method_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 auth_method_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.AuthData.auth_method_name)
}
inline std::string* AuthData::mutable_auth_method_name() {
  std::string* _s = _internal_mutable_auth_method_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.AuthData.auth_method_name)
  return _s;
}
inline const std::string& AuthData::_internal_auth_method_name() const {
  return auth_method_name_.Get();
}
inline void AuthData::_internal_set_auth_method_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  auth_method_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthData::_internal_mutable_auth_method_name() {
  _has_bits_[0] |= 0x00000001u;
  return auth_method_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthData::release_auth_method_name() {
  // @@protoc_insertion_point(field_release:pulsar.proto.AuthData.auth_method_name)
  if (!_internal_has_auth_method_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return auth_method_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthData::set_allocated_auth_method_name(std::string* auth_method_name) {
  if (auth_method_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  auth_method_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_method_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.AuthData.auth_method_name)
}

// optional bytes auth_data = 2;
inline bool AuthData::_internal_has_auth_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AuthData::has_auth_data() const {
  return _internal_has_auth_data();
}
inline void AuthData::clear_auth_data() {
  auth_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AuthData::auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.AuthData.auth_data)
  return _internal_auth_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthData::set_auth_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 auth_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.AuthData.auth_data)
}
inline std::string* AuthData::mutable_auth_data() {
  std::string* _s = _internal_mutable_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.AuthData.auth_data)
  return _s;
}
inline const std::string& AuthData::_internal_auth_data() const {
  return auth_data_.Get();
}
inline void AuthData::_internal_set_auth_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthData::_internal_mutable_auth_data() {
  _has_bits_[0] |= 0x00000002u;
  return auth_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthData::release_auth_data() {
  // @@protoc_insertion_point(field_release:pulsar.proto.AuthData.auth_data)
  if (!_internal_has_auth_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return auth_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthData::set_allocated_auth_data(std::string* auth_data) {
  if (auth_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  auth_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.AuthData.auth_data)
}

// -------------------------------------------------------------------

// KeySharedMeta

// required .pulsar.proto.KeySharedMode keySharedMode = 1;
inline bool KeySharedMeta::_internal_has_keysharedmode() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeySharedMeta::has_keysharedmode() const {
  return _internal_has_keysharedmode();
}
inline void KeySharedMeta::clear_keysharedmode() {
  keysharedmode_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::pulsar::proto::KeySharedMode KeySharedMeta::_internal_keysharedmode() const {
  return static_cast< ::pulsar::proto::KeySharedMode >(keysharedmode_);
}
inline ::pulsar::proto::KeySharedMode KeySharedMeta::keysharedmode() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeySharedMeta.keySharedMode)
  return _internal_keysharedmode();
}
inline void KeySharedMeta::_internal_set_keysharedmode(::pulsar::proto::KeySharedMode value) {
  assert(::pulsar::proto::KeySharedMode_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  keysharedmode_ = value;
}
inline void KeySharedMeta::set_keysharedmode(::pulsar::proto::KeySharedMode value) {
  _internal_set_keysharedmode(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.KeySharedMeta.keySharedMode)
}

// repeated .pulsar.proto.IntRange hashRanges = 3;
inline int KeySharedMeta::_internal_hashranges_size() const {
  return hashranges_.size();
}
inline int KeySharedMeta::hashranges_size() const {
  return _internal_hashranges_size();
}
inline void KeySharedMeta::clear_hashranges() {
  hashranges_.Clear();
}
inline ::pulsar::proto::IntRange* KeySharedMeta::mutable_hashranges(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeySharedMeta.hashRanges)
  return hashranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::IntRange >*
KeySharedMeta::mutable_hashranges() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.KeySharedMeta.hashRanges)
  return &hashranges_;
}
inline const ::pulsar::proto::IntRange& KeySharedMeta::_internal_hashranges(int index) const {
  return hashranges_.Get(index);
}
inline const ::pulsar::proto::IntRange& KeySharedMeta::hashranges(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeySharedMeta.hashRanges)
  return _internal_hashranges(index);
}
inline ::pulsar::proto::IntRange* KeySharedMeta::_internal_add_hashranges() {
  return hashranges_.Add();
}
inline ::pulsar::proto::IntRange* KeySharedMeta::add_hashranges() {
  ::pulsar::proto::IntRange* _add = _internal_add_hashranges();
  // @@protoc_insertion_point(field_add:pulsar.proto.KeySharedMeta.hashRanges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::IntRange >&
KeySharedMeta::hashranges() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.KeySharedMeta.hashRanges)
  return hashranges_;
}

// optional bool allowOutOfOrderDelivery = 4 [default = false];
inline bool KeySharedMeta::_internal_has_allowoutoforderdelivery() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeySharedMeta::has_allowoutoforderdelivery() const {
  return _internal_has_allowoutoforderdelivery();
}
inline void KeySharedMeta::clear_allowoutoforderdelivery() {
  allowoutoforderdelivery_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool KeySharedMeta::_internal_allowoutoforderdelivery() const {
  return allowoutoforderdelivery_;
}
inline bool KeySharedMeta::allowoutoforderdelivery() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeySharedMeta.allowOutOfOrderDelivery)
  return _internal_allowoutoforderdelivery();
}
inline void KeySharedMeta::_internal_set_allowoutoforderdelivery(bool value) {
  _has_bits_[0] |= 0x00000002u;
  allowoutoforderdelivery_ = value;
}
inline void KeySharedMeta::set_allowoutoforderdelivery(bool value) {
  _internal_set_allowoutoforderdelivery(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.KeySharedMeta.allowOutOfOrderDelivery)
}

// -------------------------------------------------------------------

// CommandSubscribe

// required string topic = 1;
inline bool CommandSubscribe::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandSubscribe::has_topic() const {
  return _internal_has_topic();
}
inline void CommandSubscribe::clear_topic() {
  topic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandSubscribe::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandSubscribe::set_topic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.topic)
}
inline std::string* CommandSubscribe::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.topic)
  return _s;
}
inline const std::string& CommandSubscribe::_internal_topic() const {
  return topic_.Get();
}
inline void CommandSubscribe::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandSubscribe::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandSubscribe::release_topic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandSubscribe::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.topic)
}

// required string subscription = 2;
inline bool CommandSubscribe::_internal_has_subscription() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandSubscribe::has_subscription() const {
  return _internal_has_subscription();
}
inline void CommandSubscribe::clear_subscription() {
  subscription_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandSubscribe::subscription() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.subscription)
  return _internal_subscription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandSubscribe::set_subscription(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 subscription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.subscription)
}
inline std::string* CommandSubscribe::mutable_subscription() {
  std::string* _s = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.subscription)
  return _s;
}
inline const std::string& CommandSubscribe::_internal_subscription() const {
  return subscription_.Get();
}
inline void CommandSubscribe::_internal_set_subscription(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  subscription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandSubscribe::_internal_mutable_subscription() {
  _has_bits_[0] |= 0x00000002u;
  return subscription_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandSubscribe::release_subscription() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.subscription)
  if (!_internal_has_subscription()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return subscription_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandSubscribe::set_allocated_subscription(std::string* subscription) {
  if (subscription != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  subscription_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.subscription)
}

// required .pulsar.proto.CommandSubscribe.SubType subType = 3;
inline bool CommandSubscribe::_internal_has_subtype() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommandSubscribe::has_subtype() const {
  return _internal_has_subtype();
}
inline void CommandSubscribe::clear_subtype() {
  subtype_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::pulsar::proto::CommandSubscribe_SubType CommandSubscribe::_internal_subtype() const {
  return static_cast< ::pulsar::proto::CommandSubscribe_SubType >(subtype_);
}
inline ::pulsar::proto::CommandSubscribe_SubType CommandSubscribe::subtype() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.subType)
  return _internal_subtype();
}
inline void CommandSubscribe::_internal_set_subtype(::pulsar::proto::CommandSubscribe_SubType value) {
  assert(::pulsar::proto::CommandSubscribe_SubType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  subtype_ = value;
}
inline void CommandSubscribe::set_subtype(::pulsar::proto::CommandSubscribe_SubType value) {
  _internal_set_subtype(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.subType)
}

// required uint64 consumer_id = 4;
inline bool CommandSubscribe::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandSubscribe::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandSubscribe::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSubscribe::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSubscribe::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.consumer_id)
  return _internal_consumer_id();
}
inline void CommandSubscribe::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  consumer_id_ = value;
}
inline void CommandSubscribe::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.consumer_id)
}

// required uint64 request_id = 5;
inline bool CommandSubscribe::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommandSubscribe::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandSubscribe::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSubscribe::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSubscribe::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.request_id)
  return _internal_request_id();
}
inline void CommandSubscribe::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  request_id_ = value;
}
inline void CommandSubscribe::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.request_id)
}

// optional string consumer_name = 6;
inline bool CommandSubscribe::_internal_has_consumer_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandSubscribe::has_consumer_name() const {
  return _internal_has_consumer_name();
}
inline void CommandSubscribe::clear_consumer_name() {
  consumer_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandSubscribe::consumer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.consumer_name)
  return _internal_consumer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandSubscribe::set_consumer_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 consumer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.consumer_name)
}
inline std::string* CommandSubscribe::mutable_consumer_name() {
  std::string* _s = _internal_mutable_consumer_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.consumer_name)
  return _s;
}
inline const std::string& CommandSubscribe::_internal_consumer_name() const {
  return consumer_name_.Get();
}
inline void CommandSubscribe::_internal_set_consumer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  consumer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandSubscribe::_internal_mutable_consumer_name() {
  _has_bits_[0] |= 0x00000004u;
  return consumer_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandSubscribe::release_consumer_name() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.consumer_name)
  if (!_internal_has_consumer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return consumer_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandSubscribe::set_allocated_consumer_name(std::string* consumer_name) {
  if (consumer_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  consumer_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), consumer_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.consumer_name)
}

// optional int32 priority_level = 7;
inline bool CommandSubscribe::_internal_has_priority_level() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommandSubscribe::has_priority_level() const {
  return _internal_has_priority_level();
}
inline void CommandSubscribe::clear_priority_level() {
  priority_level_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandSubscribe::_internal_priority_level() const {
  return priority_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandSubscribe::priority_level() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.priority_level)
  return _internal_priority_level();
}
inline void CommandSubscribe::_internal_set_priority_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  priority_level_ = value;
}
inline void CommandSubscribe::set_priority_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_priority_level(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.priority_level)
}

// optional bool durable = 8 [default = true];
inline bool CommandSubscribe::_internal_has_durable() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CommandSubscribe::has_durable() const {
  return _internal_has_durable();
}
inline void CommandSubscribe::clear_durable() {
  durable_ = true;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool CommandSubscribe::_internal_durable() const {
  return durable_;
}
inline bool CommandSubscribe::durable() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.durable)
  return _internal_durable();
}
inline void CommandSubscribe::_internal_set_durable(bool value) {
  _has_bits_[0] |= 0x00008000u;
  durable_ = value;
}
inline void CommandSubscribe::set_durable(bool value) {
  _internal_set_durable(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.durable)
}

// optional .pulsar.proto.MessageIdData start_message_id = 9;
inline bool CommandSubscribe::_internal_has_start_message_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || start_message_id_ != nullptr);
  return value;
}
inline bool CommandSubscribe::has_start_message_id() const {
  return _internal_has_start_message_id();
}
inline void CommandSubscribe::clear_start_message_id() {
  if (start_message_id_ != nullptr) start_message_id_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pulsar::proto::MessageIdData& CommandSubscribe::_internal_start_message_id() const {
  const ::pulsar::proto::MessageIdData* p = start_message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(
      ::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandSubscribe::start_message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.start_message_id)
  return _internal_start_message_id();
}
inline void CommandSubscribe::unsafe_arena_set_allocated_start_message_id(
    ::pulsar::proto::MessageIdData* start_message_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_message_id_);
  }
  start_message_id_ = start_message_id;
  if (start_message_id) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSubscribe.start_message_id)
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::release_start_message_id() {
  _has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::MessageIdData* temp = start_message_id_;
  start_message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::unsafe_arena_release_start_message_id() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.start_message_id)
  _has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::MessageIdData* temp = start_message_id_;
  start_message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::_internal_mutable_start_message_id() {
  _has_bits_[0] |= 0x00000008u;
  if (start_message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArenaForAllocation());
    start_message_id_ = p;
  }
  return start_message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::mutable_start_message_id() {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_start_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.start_message_id)
  return _msg;
}
inline void CommandSubscribe::set_allocated_start_message_id(::pulsar::proto::MessageIdData* start_message_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete start_message_id_;
  }
  if (start_message_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::MessageIdData>::GetOwningArena(start_message_id);
    if (message_arena != submessage_arena) {
      start_message_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_message_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  start_message_id_ = start_message_id;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.start_message_id)
}

// repeated .pulsar.proto.KeyValue metadata = 10;
inline int CommandSubscribe::_internal_metadata_size() const {
  return metadata_.size();
}
inline int CommandSubscribe::metadata_size() const {
  return _internal_metadata_size();
}
inline void CommandSubscribe::clear_metadata() {
  metadata_.Clear();
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.metadata)
  return metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
CommandSubscribe::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandSubscribe.metadata)
  return &metadata_;
}
inline const ::pulsar::proto::KeyValue& CommandSubscribe::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline const ::pulsar::proto::KeyValue& CommandSubscribe::metadata(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.metadata)
  return _internal_metadata(index);
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::_internal_add_metadata() {
  return metadata_.Add();
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::add_metadata() {
  ::pulsar::proto::KeyValue* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandSubscribe.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
CommandSubscribe::metadata() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandSubscribe.metadata)
  return metadata_;
}

// optional bool read_compacted = 11;
inline bool CommandSubscribe::_internal_has_read_compacted() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommandSubscribe::has_read_compacted() const {
  return _internal_has_read_compacted();
}
inline void CommandSubscribe::clear_read_compacted() {
  read_compacted_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CommandSubscribe::_internal_read_compacted() const {
  return read_compacted_;
}
inline bool CommandSubscribe::read_compacted() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.read_compacted)
  return _internal_read_compacted();
}
inline void CommandSubscribe::_internal_set_read_compacted(bool value) {
  _has_bits_[0] |= 0x00000400u;
  read_compacted_ = value;
}
inline void CommandSubscribe::set_read_compacted(bool value) {
  _internal_set_read_compacted(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.read_compacted)
}

// optional .pulsar.proto.Schema schema = 12;
inline bool CommandSubscribe::_internal_has_schema() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || schema_ != nullptr);
  return value;
}
inline bool CommandSubscribe::has_schema() const {
  return _internal_has_schema();
}
inline void CommandSubscribe::clear_schema() {
  if (schema_ != nullptr) schema_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::pulsar::proto::Schema& CommandSubscribe::_internal_schema() const {
  const ::pulsar::proto::Schema* p = schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(
      ::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandSubscribe::schema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.schema)
  return _internal_schema();
}
inline void CommandSubscribe::unsafe_arena_set_allocated_schema(
    ::pulsar::proto::Schema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_);
  }
  schema_ = schema;
  if (schema) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSubscribe.schema)
}
inline ::pulsar::proto::Schema* CommandSubscribe::release_schema() {
  _has_bits_[0] &= ~0x00000010u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::Schema* CommandSubscribe::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.schema)
  _has_bits_[0] &= ~0x00000010u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandSubscribe::_internal_mutable_schema() {
  _has_bits_[0] |= 0x00000010u;
  if (schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArenaForAllocation());
    schema_ = p;
  }
  return schema_;
}
inline ::pulsar::proto::Schema* CommandSubscribe::mutable_schema() {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.schema)
  return _msg;
}
inline void CommandSubscribe::set_allocated_schema(::pulsar::proto::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::Schema>::GetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.schema)
}

// optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
inline bool CommandSubscribe::_internal_has_initialposition() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CommandSubscribe::has_initialposition() const {
  return _internal_has_initialposition();
}
inline void CommandSubscribe::clear_initialposition() {
  initialposition_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::pulsar::proto::CommandSubscribe_InitialPosition CommandSubscribe::_internal_initialposition() const {
  return static_cast< ::pulsar::proto::CommandSubscribe_InitialPosition >(initialposition_);
}
inline ::pulsar::proto::CommandSubscribe_InitialPosition CommandSubscribe::initialposition() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.initialPosition)
  return _internal_initialposition();
}
inline void CommandSubscribe::_internal_set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value) {
  assert(::pulsar::proto::CommandSubscribe_InitialPosition_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  initialposition_ = value;
}
inline void CommandSubscribe::set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value) {
  _internal_set_initialposition(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.initialPosition)
}

// optional bool replicate_subscription_state = 14;
inline bool CommandSubscribe::_internal_has_replicate_subscription_state() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CommandSubscribe::has_replicate_subscription_state() const {
  return _internal_has_replicate_subscription_state();
}
inline void CommandSubscribe::clear_replicate_subscription_state() {
  replicate_subscription_state_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool CommandSubscribe::_internal_replicate_subscription_state() const {
  return replicate_subscription_state_;
}
inline bool CommandSubscribe::replicate_subscription_state() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.replicate_subscription_state)
  return _internal_replicate_subscription_state();
}
inline void CommandSubscribe::_internal_set_replicate_subscription_state(bool value) {
  _has_bits_[0] |= 0x00000800u;
  replicate_subscription_state_ = value;
}
inline void CommandSubscribe::set_replicate_subscription_state(bool value) {
  _internal_set_replicate_subscription_state(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.replicate_subscription_state)
}

// optional bool force_topic_creation = 15 [default = true];
inline bool CommandSubscribe::_internal_has_force_topic_creation() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CommandSubscribe::has_force_topic_creation() const {
  return _internal_has_force_topic_creation();
}
inline void CommandSubscribe::clear_force_topic_creation() {
  force_topic_creation_ = true;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool CommandSubscribe::_internal_force_topic_creation() const {
  return force_topic_creation_;
}
inline bool CommandSubscribe::force_topic_creation() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.force_topic_creation)
  return _internal_force_topic_creation();
}
inline void CommandSubscribe::_internal_set_force_topic_creation(bool value) {
  _has_bits_[0] |= 0x00010000u;
  force_topic_creation_ = value;
}
inline void CommandSubscribe::set_force_topic_creation(bool value) {
  _internal_set_force_topic_creation(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.force_topic_creation)
}

// optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
inline bool CommandSubscribe::_internal_has_start_message_rollback_duration_sec() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CommandSubscribe::has_start_message_rollback_duration_sec() const {
  return _internal_has_start_message_rollback_duration_sec();
}
inline void CommandSubscribe::clear_start_message_rollback_duration_sec() {
  start_message_rollback_duration_sec_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSubscribe::_internal_start_message_rollback_duration_sec() const {
  return start_message_rollback_duration_sec_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSubscribe::start_message_rollback_duration_sec() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.start_message_rollback_duration_sec)
  return _internal_start_message_rollback_duration_sec();
}
inline void CommandSubscribe::_internal_set_start_message_rollback_duration_sec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00002000u;
  start_message_rollback_duration_sec_ = value;
}
inline void CommandSubscribe::set_start_message_rollback_duration_sec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_message_rollback_duration_sec(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.start_message_rollback_duration_sec)
}

// optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
inline bool CommandSubscribe::_internal_has_keysharedmeta() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || keysharedmeta_ != nullptr);
  return value;
}
inline bool CommandSubscribe::has_keysharedmeta() const {
  return _internal_has_keysharedmeta();
}
inline void CommandSubscribe::clear_keysharedmeta() {
  if (keysharedmeta_ != nullptr) keysharedmeta_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::pulsar::proto::KeySharedMeta& CommandSubscribe::_internal_keysharedmeta() const {
  const ::pulsar::proto::KeySharedMeta* p = keysharedmeta_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::KeySharedMeta&>(
      ::pulsar::proto::_KeySharedMeta_default_instance_);
}
inline const ::pulsar::proto::KeySharedMeta& CommandSubscribe::keysharedmeta() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.keySharedMeta)
  return _internal_keysharedmeta();
}
inline void CommandSubscribe::unsafe_arena_set_allocated_keysharedmeta(
    ::pulsar::proto::KeySharedMeta* keysharedmeta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(keysharedmeta_);
  }
  keysharedmeta_ = keysharedmeta;
  if (keysharedmeta) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSubscribe.keySharedMeta)
}
inline ::pulsar::proto::KeySharedMeta* CommandSubscribe::release_keysharedmeta() {
  _has_bits_[0] &= ~0x00000020u;
  ::pulsar::proto::KeySharedMeta* temp = keysharedmeta_;
  keysharedmeta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::KeySharedMeta* CommandSubscribe::unsafe_arena_release_keysharedmeta() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.keySharedMeta)
  _has_bits_[0] &= ~0x00000020u;
  ::pulsar::proto::KeySharedMeta* temp = keysharedmeta_;
  keysharedmeta_ = nullptr;
  return temp;
}
inline ::pulsar::proto::KeySharedMeta* CommandSubscribe::_internal_mutable_keysharedmeta() {
  _has_bits_[0] |= 0x00000020u;
  if (keysharedmeta_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::KeySharedMeta>(GetArenaForAllocation());
    keysharedmeta_ = p;
  }
  return keysharedmeta_;
}
inline ::pulsar::proto::KeySharedMeta* CommandSubscribe::mutable_keysharedmeta() {
  ::pulsar::proto::KeySharedMeta* _msg = _internal_mutable_keysharedmeta();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.keySharedMeta)
  return _msg;
}
inline void CommandSubscribe::set_allocated_keysharedmeta(::pulsar::proto::KeySharedMeta* keysharedmeta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete keysharedmeta_;
  }
  if (keysharedmeta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::KeySharedMeta>::GetOwningArena(keysharedmeta);
    if (message_arena != submessage_arena) {
      keysharedmeta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keysharedmeta, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  keysharedmeta_ = keysharedmeta;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.keySharedMeta)
}

// repeated .pulsar.proto.KeyValue subscription_properties = 18;
inline int CommandSubscribe::_internal_subscription_properties_size() const {
  return subscription_properties_.size();
}
inline int CommandSubscribe::subscription_properties_size() const {
  return _internal_subscription_properties_size();
}
inline void CommandSubscribe::clear_subscription_properties() {
  subscription_properties_.Clear();
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::mutable_subscription_properties(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.subscription_properties)
  return subscription_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
CommandSubscribe::mutable_subscription_properties() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandSubscribe.subscription_properties)
  return &subscription_properties_;
}
inline const ::pulsar::proto::KeyValue& CommandSubscribe::_internal_subscription_properties(int index) const {
  return subscription_properties_.Get(index);
}
inline const ::pulsar::proto::KeyValue& CommandSubscribe::subscription_properties(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.subscription_properties)
  return _internal_subscription_properties(index);
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::_internal_add_subscription_properties() {
  return subscription_properties_.Add();
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::add_subscription_properties() {
  ::pulsar::proto::KeyValue* _add = _internal_add_subscription_properties();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandSubscribe.subscription_properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
CommandSubscribe::subscription_properties() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandSubscribe.subscription_properties)
  return subscription_properties_;
}

// optional uint64 consumer_epoch = 19;
inline bool CommandSubscribe::_internal_has_consumer_epoch() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CommandSubscribe::has_consumer_epoch() const {
  return _internal_has_consumer_epoch();
}
inline void CommandSubscribe::clear_consumer_epoch() {
  consumer_epoch_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSubscribe::_internal_consumer_epoch() const {
  return consumer_epoch_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSubscribe::consumer_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.consumer_epoch)
  return _internal_consumer_epoch();
}
inline void CommandSubscribe::_internal_set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00004000u;
  consumer_epoch_ = value;
}
inline void CommandSubscribe::set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.consumer_epoch)
}

// -------------------------------------------------------------------

// CommandPartitionedTopicMetadata

// required string topic = 1;
inline bool CommandPartitionedTopicMetadata::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadata::has_topic() const {
  return _internal_has_topic();
}
inline void CommandPartitionedTopicMetadata::clear_topic() {
  topic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandPartitionedTopicMetadata::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandPartitionedTopicMetadata::set_topic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.topic)
}
inline std::string* CommandPartitionedTopicMetadata::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.topic)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadata::_internal_topic() const {
  return topic_.Get();
}
inline void CommandPartitionedTopicMetadata::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadata::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadata::release_topic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadata.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandPartitionedTopicMetadata::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.topic)
}

// required uint64 request_id = 2;
inline bool CommandPartitionedTopicMetadata::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadata::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandPartitionedTopicMetadata::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandPartitionedTopicMetadata::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandPartitionedTopicMetadata::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.request_id)
  return _internal_request_id();
}
inline void CommandPartitionedTopicMetadata::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  request_id_ = value;
}
inline void CommandPartitionedTopicMetadata::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.request_id)
}

// optional string original_principal = 3;
inline bool CommandPartitionedTopicMetadata::_internal_has_original_principal() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadata::has_original_principal() const {
  return _internal_has_original_principal();
}
inline void CommandPartitionedTopicMetadata::clear_original_principal() {
  original_principal_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandPartitionedTopicMetadata::original_principal() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
  return _internal_original_principal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandPartitionedTopicMetadata::set_original_principal(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 original_principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
}
inline std::string* CommandPartitionedTopicMetadata::mutable_original_principal() {
  std::string* _s = _internal_mutable_original_principal();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadata::_internal_original_principal() const {
  return original_principal_.Get();
}
inline void CommandPartitionedTopicMetadata::_internal_set_original_principal(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  original_principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadata::_internal_mutable_original_principal() {
  _has_bits_[0] |= 0x00000002u;
  return original_principal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadata::release_original_principal() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
  if (!_internal_has_original_principal()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return original_principal_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandPartitionedTopicMetadata::set_allocated_original_principal(std::string* original_principal) {
  if (original_principal != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  original_principal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_principal,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
}

// optional string original_auth_data = 4;
inline bool CommandPartitionedTopicMetadata::_internal_has_original_auth_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadata::has_original_auth_data() const {
  return _internal_has_original_auth_data();
}
inline void CommandPartitionedTopicMetadata::clear_original_auth_data() {
  original_auth_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandPartitionedTopicMetadata::original_auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
  return _internal_original_auth_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandPartitionedTopicMetadata::set_original_auth_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 original_auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
}
inline std::string* CommandPartitionedTopicMetadata::mutable_original_auth_data() {
  std::string* _s = _internal_mutable_original_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadata::_internal_original_auth_data() const {
  return original_auth_data_.Get();
}
inline void CommandPartitionedTopicMetadata::_internal_set_original_auth_data(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  original_auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadata::_internal_mutable_original_auth_data() {
  _has_bits_[0] |= 0x00000004u;
  return original_auth_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadata::release_original_auth_data() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
  if (!_internal_has_original_auth_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return original_auth_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandPartitionedTopicMetadata::set_allocated_original_auth_data(std::string* original_auth_data) {
  if (original_auth_data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  original_auth_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_auth_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
}

// optional string original_auth_method = 5;
inline bool CommandPartitionedTopicMetadata::_internal_has_original_auth_method() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadata::has_original_auth_method() const {
  return _internal_has_original_auth_method();
}
inline void CommandPartitionedTopicMetadata::clear_original_auth_method() {
  original_auth_method_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandPartitionedTopicMetadata::original_auth_method() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
  return _internal_original_auth_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandPartitionedTopicMetadata::set_original_auth_method(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 original_auth_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
}
inline std::string* CommandPartitionedTopicMetadata::mutable_original_auth_method() {
  std::string* _s = _internal_mutable_original_auth_method();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadata::_internal_original_auth_method() const {
  return original_auth_method_.Get();
}
inline void CommandPartitionedTopicMetadata::_internal_set_original_auth_method(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  original_auth_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadata::_internal_mutable_original_auth_method() {
  _has_bits_[0] |= 0x00000008u;
  return original_auth_method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadata::release_original_auth_method() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
  if (!_internal_has_original_auth_method()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return original_auth_method_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandPartitionedTopicMetadata::set_allocated_original_auth_method(std::string* original_auth_method) {
  if (original_auth_method != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  original_auth_method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_auth_method,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
}

// -------------------------------------------------------------------

// CommandPartitionedTopicMetadataResponse

// optional uint32 partitions = 1;
inline bool CommandPartitionedTopicMetadataResponse::_internal_has_partitions() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadataResponse::has_partitions() const {
  return _internal_has_partitions();
}
inline void CommandPartitionedTopicMetadataResponse::clear_partitions() {
  partitions_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandPartitionedTopicMetadataResponse::_internal_partitions() const {
  return partitions_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandPartitionedTopicMetadataResponse::partitions() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.partitions)
  return _internal_partitions();
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_partitions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  partitions_ = value;
}
inline void CommandPartitionedTopicMetadataResponse::set_partitions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_partitions(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.partitions)
}

// required uint64 request_id = 2;
inline bool CommandPartitionedTopicMetadataResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadataResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandPartitionedTopicMetadataResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandPartitionedTopicMetadataResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandPartitionedTopicMetadataResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.request_id)
  return _internal_request_id();
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandPartitionedTopicMetadataResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.request_id)
}

// optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
inline bool CommandPartitionedTopicMetadataResponse::_internal_has_response() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadataResponse::has_response() const {
  return _internal_has_response();
}
inline void CommandPartitionedTopicMetadataResponse::clear_response() {
  response_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::_internal_response() const {
  return static_cast< ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType >(response_);
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::response() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.response)
  return _internal_response();
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value) {
  assert(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  response_ = value;
}
inline void CommandPartitionedTopicMetadataResponse::set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.response)
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandPartitionedTopicMetadataResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadataResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandPartitionedTopicMetadataResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandPartitionedTopicMetadataResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandPartitionedTopicMetadataResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.error)
  return _internal_error();
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
}
inline void CommandPartitionedTopicMetadataResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.error)
}

// optional string message = 5;
inline bool CommandPartitionedTopicMetadataResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandPartitionedTopicMetadataResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandPartitionedTopicMetadataResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandPartitionedTopicMetadataResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandPartitionedTopicMetadataResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
}
inline std::string* CommandPartitionedTopicMetadataResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadataResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadataResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandPartitionedTopicMetadataResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandPartitionedTopicMetadataResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
}

// -------------------------------------------------------------------

// CommandLookupTopic

// required string topic = 1;
inline bool CommandLookupTopic::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandLookupTopic::has_topic() const {
  return _internal_has_topic();
}
inline void CommandLookupTopic::clear_topic() {
  topic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandLookupTopic::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandLookupTopic::set_topic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.topic)
}
inline std::string* CommandLookupTopic::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.topic)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_topic() const {
  return topic_.Get();
}
inline void CommandLookupTopic::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::release_topic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandLookupTopic::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.topic)
}

// required uint64 request_id = 2;
inline bool CommandLookupTopic::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandLookupTopic::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandLookupTopic::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandLookupTopic::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandLookupTopic::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.request_id)
  return _internal_request_id();
}
inline void CommandLookupTopic::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  request_id_ = value;
}
inline void CommandLookupTopic::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.request_id)
}

// optional bool authoritative = 3 [default = false];
inline bool CommandLookupTopic::_internal_has_authoritative() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandLookupTopic::has_authoritative() const {
  return _internal_has_authoritative();
}
inline void CommandLookupTopic::clear_authoritative() {
  authoritative_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CommandLookupTopic::_internal_authoritative() const {
  return authoritative_;
}
inline bool CommandLookupTopic::authoritative() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.authoritative)
  return _internal_authoritative();
}
inline void CommandLookupTopic::_internal_set_authoritative(bool value) {
  _has_bits_[0] |= 0x00000040u;
  authoritative_ = value;
}
inline void CommandLookupTopic::set_authoritative(bool value) {
  _internal_set_authoritative(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.authoritative)
}

// optional string original_principal = 4;
inline bool CommandLookupTopic::_internal_has_original_principal() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandLookupTopic::has_original_principal() const {
  return _internal_has_original_principal();
}
inline void CommandLookupTopic::clear_original_principal() {
  original_principal_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandLookupTopic::original_principal() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.original_principal)
  return _internal_original_principal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandLookupTopic::set_original_principal(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 original_principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.original_principal)
}
inline std::string* CommandLookupTopic::mutable_original_principal() {
  std::string* _s = _internal_mutable_original_principal();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.original_principal)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_original_principal() const {
  return original_principal_.Get();
}
inline void CommandLookupTopic::_internal_set_original_principal(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  original_principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::_internal_mutable_original_principal() {
  _has_bits_[0] |= 0x00000002u;
  return original_principal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::release_original_principal() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.original_principal)
  if (!_internal_has_original_principal()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return original_principal_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandLookupTopic::set_allocated_original_principal(std::string* original_principal) {
  if (original_principal != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  original_principal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_principal,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.original_principal)
}

// optional string original_auth_data = 5;
inline bool CommandLookupTopic::_internal_has_original_auth_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandLookupTopic::has_original_auth_data() const {
  return _internal_has_original_auth_data();
}
inline void CommandLookupTopic::clear_original_auth_data() {
  original_auth_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandLookupTopic::original_auth_data() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.original_auth_data)
  return _internal_original_auth_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandLookupTopic::set_original_auth_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 original_auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.original_auth_data)
}
inline std::string* CommandLookupTopic::mutable_original_auth_data() {
  std::string* _s = _internal_mutable_original_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.original_auth_data)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_original_auth_data() const {
  return original_auth_data_.Get();
}
inline void CommandLookupTopic::_internal_set_original_auth_data(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  original_auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::_internal_mutable_original_auth_data() {
  _has_bits_[0] |= 0x00000004u;
  return original_auth_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::release_original_auth_data() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.original_auth_data)
  if (!_internal_has_original_auth_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return original_auth_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandLookupTopic::set_allocated_original_auth_data(std::string* original_auth_data) {
  if (original_auth_data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  original_auth_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_auth_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.original_auth_data)
}

// optional string original_auth_method = 6;
inline bool CommandLookupTopic::_internal_has_original_auth_method() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandLookupTopic::has_original_auth_method() const {
  return _internal_has_original_auth_method();
}
inline void CommandLookupTopic::clear_original_auth_method() {
  original_auth_method_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandLookupTopic::original_auth_method() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.original_auth_method)
  return _internal_original_auth_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandLookupTopic::set_original_auth_method(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 original_auth_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.original_auth_method)
}
inline std::string* CommandLookupTopic::mutable_original_auth_method() {
  std::string* _s = _internal_mutable_original_auth_method();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.original_auth_method)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_original_auth_method() const {
  return original_auth_method_.Get();
}
inline void CommandLookupTopic::_internal_set_original_auth_method(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  original_auth_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::_internal_mutable_original_auth_method() {
  _has_bits_[0] |= 0x00000008u;
  return original_auth_method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::release_original_auth_method() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.original_auth_method)
  if (!_internal_has_original_auth_method()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return original_auth_method_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandLookupTopic::set_allocated_original_auth_method(std::string* original_auth_method) {
  if (original_auth_method != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  original_auth_method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_auth_method,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.original_auth_method)
}

// optional string advertised_listener_name = 7;
inline bool CommandLookupTopic::_internal_has_advertised_listener_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandLookupTopic::has_advertised_listener_name() const {
  return _internal_has_advertised_listener_name();
}
inline void CommandLookupTopic::clear_advertised_listener_name() {
  advertised_listener_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommandLookupTopic::advertised_listener_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.advertised_listener_name)
  return _internal_advertised_listener_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandLookupTopic::set_advertised_listener_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 advertised_listener_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.advertised_listener_name)
}
inline std::string* CommandLookupTopic::mutable_advertised_listener_name() {
  std::string* _s = _internal_mutable_advertised_listener_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.advertised_listener_name)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_advertised_listener_name() const {
  return advertised_listener_name_.Get();
}
inline void CommandLookupTopic::_internal_set_advertised_listener_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  advertised_listener_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::_internal_mutable_advertised_listener_name() {
  _has_bits_[0] |= 0x00000010u;
  return advertised_listener_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandLookupTopic::release_advertised_listener_name() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.advertised_listener_name)
  if (!_internal_has_advertised_listener_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return advertised_listener_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandLookupTopic::set_allocated_advertised_listener_name(std::string* advertised_listener_name) {
  if (advertised_listener_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  advertised_listener_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), advertised_listener_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.advertised_listener_name)
}

// -------------------------------------------------------------------

// CommandLookupTopicResponse

// optional string brokerServiceUrl = 1;
inline bool CommandLookupTopicResponse::_internal_has_brokerserviceurl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandLookupTopicResponse::has_brokerserviceurl() const {
  return _internal_has_brokerserviceurl();
}
inline void CommandLookupTopicResponse::clear_brokerserviceurl() {
  brokerserviceurl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandLookupTopicResponse::brokerserviceurl() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
  return _internal_brokerserviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandLookupTopicResponse::set_brokerserviceurl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 brokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
}
inline std::string* CommandLookupTopicResponse::mutable_brokerserviceurl() {
  std::string* _s = _internal_mutable_brokerserviceurl();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
  return _s;
}
inline const std::string& CommandLookupTopicResponse::_internal_brokerserviceurl() const {
  return brokerserviceurl_.Get();
}
inline void CommandLookupTopicResponse::_internal_set_brokerserviceurl(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  brokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandLookupTopicResponse::_internal_mutable_brokerserviceurl() {
  _has_bits_[0] |= 0x00000001u;
  return brokerserviceurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandLookupTopicResponse::release_brokerserviceurl() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
  if (!_internal_has_brokerserviceurl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return brokerserviceurl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandLookupTopicResponse::set_allocated_brokerserviceurl(std::string* brokerserviceurl) {
  if (brokerserviceurl != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  brokerserviceurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brokerserviceurl,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
}

// optional string brokerServiceUrlTls = 2;
inline bool CommandLookupTopicResponse::_internal_has_brokerserviceurltls() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandLookupTopicResponse::has_brokerserviceurltls() const {
  return _internal_has_brokerserviceurltls();
}
inline void CommandLookupTopicResponse::clear_brokerserviceurltls() {
  brokerserviceurltls_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandLookupTopicResponse::brokerserviceurltls() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
  return _internal_brokerserviceurltls();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandLookupTopicResponse::set_brokerserviceurltls(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 brokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
}
inline std::string* CommandLookupTopicResponse::mutable_brokerserviceurltls() {
  std::string* _s = _internal_mutable_brokerserviceurltls();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
  return _s;
}
inline const std::string& CommandLookupTopicResponse::_internal_brokerserviceurltls() const {
  return brokerserviceurltls_.Get();
}
inline void CommandLookupTopicResponse::_internal_set_brokerserviceurltls(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  brokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandLookupTopicResponse::_internal_mutable_brokerserviceurltls() {
  _has_bits_[0] |= 0x00000002u;
  return brokerserviceurltls_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandLookupTopicResponse::release_brokerserviceurltls() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
  if (!_internal_has_brokerserviceurltls()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return brokerserviceurltls_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandLookupTopicResponse::set_allocated_brokerserviceurltls(std::string* brokerserviceurltls) {
  if (brokerserviceurltls != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  brokerserviceurltls_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brokerserviceurltls,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
}

// optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
inline bool CommandLookupTopicResponse::_internal_has_response() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandLookupTopicResponse::has_response() const {
  return _internal_has_response();
}
inline void CommandLookupTopicResponse::clear_response() {
  response_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::_internal_response() const {
  return static_cast< ::pulsar::proto::CommandLookupTopicResponse_LookupType >(response_);
}
inline ::pulsar::proto::CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::response() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.response)
  return _internal_response();
}
inline void CommandLookupTopicResponse::_internal_set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value) {
  assert(::pulsar::proto::CommandLookupTopicResponse_LookupType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  response_ = value;
}
inline void CommandLookupTopicResponse::set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.response)
}

// required uint64 request_id = 4;
inline bool CommandLookupTopicResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandLookupTopicResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandLookupTopicResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandLookupTopicResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandLookupTopicResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.request_id)
  return _internal_request_id();
}
inline void CommandLookupTopicResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  request_id_ = value;
}
inline void CommandLookupTopicResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.request_id)
}

// optional bool authoritative = 5 [default = false];
inline bool CommandLookupTopicResponse::_internal_has_authoritative() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandLookupTopicResponse::has_authoritative() const {
  return _internal_has_authoritative();
}
inline void CommandLookupTopicResponse::clear_authoritative() {
  authoritative_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CommandLookupTopicResponse::_internal_authoritative() const {
  return authoritative_;
}
inline bool CommandLookupTopicResponse::authoritative() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.authoritative)
  return _internal_authoritative();
}
inline void CommandLookupTopicResponse::_internal_set_authoritative(bool value) {
  _has_bits_[0] |= 0x00000040u;
  authoritative_ = value;
}
inline void CommandLookupTopicResponse::set_authoritative(bool value) {
  _internal_set_authoritative(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.authoritative)
}

// optional .pulsar.proto.ServerError error = 6;
inline bool CommandLookupTopicResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandLookupTopicResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandLookupTopicResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::pulsar::proto::ServerError CommandLookupTopicResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandLookupTopicResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.error)
  return _internal_error();
}
inline void CommandLookupTopicResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  error_ = value;
}
inline void CommandLookupTopicResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.error)
}

// optional string message = 7;
inline bool CommandLookupTopicResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandLookupTopicResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandLookupTopicResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandLookupTopicResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandLookupTopicResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.message)
}
inline std::string* CommandLookupTopicResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopicResponse.message)
  return _s;
}
inline const std::string& CommandLookupTopicResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandLookupTopicResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandLookupTopicResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000004u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandLookupTopicResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopicResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandLookupTopicResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopicResponse.message)
}

// optional bool proxy_through_service_url = 8 [default = false];
inline bool CommandLookupTopicResponse::_internal_has_proxy_through_service_url() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommandLookupTopicResponse::has_proxy_through_service_url() const {
  return _internal_has_proxy_through_service_url();
}
inline void CommandLookupTopicResponse::clear_proxy_through_service_url() {
  proxy_through_service_url_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CommandLookupTopicResponse::_internal_proxy_through_service_url() const {
  return proxy_through_service_url_;
}
inline bool CommandLookupTopicResponse::proxy_through_service_url() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.proxy_through_service_url)
  return _internal_proxy_through_service_url();
}
inline void CommandLookupTopicResponse::_internal_set_proxy_through_service_url(bool value) {
  _has_bits_[0] |= 0x00000080u;
  proxy_through_service_url_ = value;
}
inline void CommandLookupTopicResponse::set_proxy_through_service_url(bool value) {
  _internal_set_proxy_through_service_url(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.proxy_through_service_url)
}

// -------------------------------------------------------------------

// CommandProducer

// required string topic = 1;
inline bool CommandProducer::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandProducer::has_topic() const {
  return _internal_has_topic();
}
inline void CommandProducer::clear_topic() {
  topic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandProducer::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandProducer::set_topic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.topic)
}
inline std::string* CommandProducer::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.topic)
  return _s;
}
inline const std::string& CommandProducer::_internal_topic() const {
  return topic_.Get();
}
inline void CommandProducer::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandProducer::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandProducer::release_topic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducer.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandProducer::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.topic)
}

// required uint64 producer_id = 2;
inline bool CommandProducer::_internal_has_producer_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandProducer::has_producer_id() const {
  return _internal_has_producer_id();
}
inline void CommandProducer::clear_producer_id() {
  producer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducer::_internal_producer_id() const {
  return producer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducer::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.producer_id)
  return _internal_producer_id();
}
inline void CommandProducer::_internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  producer_id_ = value;
}
inline void CommandProducer::set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.producer_id)
}

// required uint64 request_id = 3;
inline bool CommandProducer::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandProducer::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandProducer::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducer::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducer::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.request_id)
  return _internal_request_id();
}
inline void CommandProducer::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  request_id_ = value;
}
inline void CommandProducer::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.request_id)
}

// optional string producer_name = 4;
inline bool CommandProducer::_internal_has_producer_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandProducer::has_producer_name() const {
  return _internal_has_producer_name();
}
inline void CommandProducer::clear_producer_name() {
  producer_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandProducer::producer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.producer_name)
  return _internal_producer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandProducer::set_producer_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 producer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.producer_name)
}
inline std::string* CommandProducer::mutable_producer_name() {
  std::string* _s = _internal_mutable_producer_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.producer_name)
  return _s;
}
inline const std::string& CommandProducer::_internal_producer_name() const {
  return producer_name_.Get();
}
inline void CommandProducer::_internal_set_producer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  producer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandProducer::_internal_mutable_producer_name() {
  _has_bits_[0] |= 0x00000002u;
  return producer_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandProducer::release_producer_name() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducer.producer_name)
  if (!_internal_has_producer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return producer_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandProducer::set_allocated_producer_name(std::string* producer_name) {
  if (producer_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  producer_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), producer_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.producer_name)
}

// optional bool encrypted = 5 [default = false];
inline bool CommandProducer::_internal_has_encrypted() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommandProducer::has_encrypted() const {
  return _internal_has_encrypted();
}
inline void CommandProducer::clear_encrypted() {
  encrypted_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CommandProducer::_internal_encrypted() const {
  return encrypted_;
}
inline bool CommandProducer::encrypted() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.encrypted)
  return _internal_encrypted();
}
inline void CommandProducer::_internal_set_encrypted(bool value) {
  _has_bits_[0] |= 0x00000080u;
  encrypted_ = value;
}
inline void CommandProducer::set_encrypted(bool value) {
  _internal_set_encrypted(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.encrypted)
}

// repeated .pulsar.proto.KeyValue metadata = 6;
inline int CommandProducer::_internal_metadata_size() const {
  return metadata_.size();
}
inline int CommandProducer::metadata_size() const {
  return _internal_metadata_size();
}
inline void CommandProducer::clear_metadata() {
  metadata_.Clear();
}
inline ::pulsar::proto::KeyValue* CommandProducer::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.metadata)
  return metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >*
CommandProducer::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandProducer.metadata)
  return &metadata_;
}
inline const ::pulsar::proto::KeyValue& CommandProducer::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline const ::pulsar::proto::KeyValue& CommandProducer::metadata(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.metadata)
  return _internal_metadata(index);
}
inline ::pulsar::proto::KeyValue* CommandProducer::_internal_add_metadata() {
  return metadata_.Add();
}
inline ::pulsar::proto::KeyValue* CommandProducer::add_metadata() {
  ::pulsar::proto::KeyValue* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandProducer.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyValue >&
CommandProducer::metadata() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandProducer.metadata)
  return metadata_;
}

// optional .pulsar.proto.Schema schema = 7;
inline bool CommandProducer::_internal_has_schema() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || schema_ != nullptr);
  return value;
}
inline bool CommandProducer::has_schema() const {
  return _internal_has_schema();
}
inline void CommandProducer::clear_schema() {
  if (schema_ != nullptr) schema_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pulsar::proto::Schema& CommandProducer::_internal_schema() const {
  const ::pulsar::proto::Schema* p = schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(
      ::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandProducer::schema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.schema)
  return _internal_schema();
}
inline void CommandProducer::unsafe_arena_set_allocated_schema(
    ::pulsar::proto::Schema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_);
  }
  schema_ = schema;
  if (schema) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandProducer.schema)
}
inline ::pulsar::proto::Schema* CommandProducer::release_schema() {
  _has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::Schema* CommandProducer::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducer.schema)
  _has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandProducer::_internal_mutable_schema() {
  _has_bits_[0] |= 0x00000008u;
  if (schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArenaForAllocation());
    schema_ = p;
  }
  return schema_;
}
inline ::pulsar::proto::Schema* CommandProducer::mutable_schema() {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.schema)
  return _msg;
}
inline void CommandProducer::set_allocated_schema(::pulsar::proto::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::Schema>::GetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.schema)
}

// optional uint64 epoch = 8 [default = 0];
inline bool CommandProducer::_internal_has_epoch() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandProducer::has_epoch() const {
  return _internal_has_epoch();
}
inline void CommandProducer::clear_epoch() {
  epoch_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducer::_internal_epoch() const {
  return epoch_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducer::epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.epoch)
  return _internal_epoch();
}
inline void CommandProducer::_internal_set_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  epoch_ = value;
}
inline void CommandProducer::set_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.epoch)
}

// optional bool user_provided_producer_name = 9 [default = true];
inline bool CommandProducer::_internal_has_user_provided_producer_name() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CommandProducer::has_user_provided_producer_name() const {
  return _internal_has_user_provided_producer_name();
}
inline void CommandProducer::clear_user_provided_producer_name() {
  user_provided_producer_name_ = true;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool CommandProducer::_internal_user_provided_producer_name() const {
  return user_provided_producer_name_;
}
inline bool CommandProducer::user_provided_producer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.user_provided_producer_name)
  return _internal_user_provided_producer_name();
}
inline void CommandProducer::_internal_set_user_provided_producer_name(bool value) {
  _has_bits_[0] |= 0x00000800u;
  user_provided_producer_name_ = value;
}
inline void CommandProducer::set_user_provided_producer_name(bool value) {
  _internal_set_user_provided_producer_name(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.user_provided_producer_name)
}

// optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
inline bool CommandProducer::_internal_has_producer_access_mode() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommandProducer::has_producer_access_mode() const {
  return _internal_has_producer_access_mode();
}
inline void CommandProducer::clear_producer_access_mode() {
  producer_access_mode_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::pulsar::proto::ProducerAccessMode CommandProducer::_internal_producer_access_mode() const {
  return static_cast< ::pulsar::proto::ProducerAccessMode >(producer_access_mode_);
}
inline ::pulsar::proto::ProducerAccessMode CommandProducer::producer_access_mode() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.producer_access_mode)
  return _internal_producer_access_mode();
}
inline void CommandProducer::_internal_set_producer_access_mode(::pulsar::proto::ProducerAccessMode value) {
  assert(::pulsar::proto::ProducerAccessMode_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  producer_access_mode_ = value;
}
inline void CommandProducer::set_producer_access_mode(::pulsar::proto::ProducerAccessMode value) {
  _internal_set_producer_access_mode(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.producer_access_mode)
}

// optional uint64 topic_epoch = 11;
inline bool CommandProducer::_internal_has_topic_epoch() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommandProducer::has_topic_epoch() const {
  return _internal_has_topic_epoch();
}
inline void CommandProducer::clear_topic_epoch() {
  topic_epoch_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducer::_internal_topic_epoch() const {
  return topic_epoch_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducer::topic_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.topic_epoch)
  return _internal_topic_epoch();
}
inline void CommandProducer::_internal_set_topic_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000400u;
  topic_epoch_ = value;
}
inline void CommandProducer::set_topic_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_topic_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.topic_epoch)
}

// optional bool txn_enabled = 12 [default = false];
inline bool CommandProducer::_internal_has_txn_enabled() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommandProducer::has_txn_enabled() const {
  return _internal_has_txn_enabled();
}
inline void CommandProducer::clear_txn_enabled() {
  txn_enabled_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool CommandProducer::_internal_txn_enabled() const {
  return txn_enabled_;
}
inline bool CommandProducer::txn_enabled() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.txn_enabled)
  return _internal_txn_enabled();
}
inline void CommandProducer::_internal_set_txn_enabled(bool value) {
  _has_bits_[0] |= 0x00000100u;
  txn_enabled_ = value;
}
inline void CommandProducer::set_txn_enabled(bool value) {
  _internal_set_txn_enabled(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.txn_enabled)
}

// optional string initial_subscription_name = 13;
inline bool CommandProducer::_internal_has_initial_subscription_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandProducer::has_initial_subscription_name() const {
  return _internal_has_initial_subscription_name();
}
inline void CommandProducer::clear_initial_subscription_name() {
  initial_subscription_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandProducer::initial_subscription_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.initial_subscription_name)
  return _internal_initial_subscription_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandProducer::set_initial_subscription_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 initial_subscription_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.initial_subscription_name)
}
inline std::string* CommandProducer::mutable_initial_subscription_name() {
  std::string* _s = _internal_mutable_initial_subscription_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.initial_subscription_name)
  return _s;
}
inline const std::string& CommandProducer::_internal_initial_subscription_name() const {
  return initial_subscription_name_.Get();
}
inline void CommandProducer::_internal_set_initial_subscription_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  initial_subscription_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandProducer::_internal_mutable_initial_subscription_name() {
  _has_bits_[0] |= 0x00000004u;
  return initial_subscription_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandProducer::release_initial_subscription_name() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducer.initial_subscription_name)
  if (!_internal_has_initial_subscription_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return initial_subscription_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandProducer::set_allocated_initial_subscription_name(std::string* initial_subscription_name) {
  if (initial_subscription_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  initial_subscription_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initial_subscription_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.initial_subscription_name)
}

// -------------------------------------------------------------------

// CommandSend

// required uint64 producer_id = 1;
inline bool CommandSend::_internal_has_producer_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandSend::has_producer_id() const {
  return _internal_has_producer_id();
}
inline void CommandSend::clear_producer_id() {
  producer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::_internal_producer_id() const {
  return producer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.producer_id)
  return _internal_producer_id();
}
inline void CommandSend::_internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  producer_id_ = value;
}
inline void CommandSend::set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.producer_id)
}

// required uint64 sequence_id = 2;
inline bool CommandSend::_internal_has_sequence_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandSend::has_sequence_id() const {
  return _internal_has_sequence_id();
}
inline void CommandSend::clear_sequence_id() {
  sequence_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::_internal_sequence_id() const {
  return sequence_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.sequence_id)
  return _internal_sequence_id();
}
inline void CommandSend::_internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  sequence_id_ = value;
}
inline void CommandSend::set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.sequence_id)
}

// optional int32 num_messages = 3 [default = 1];
inline bool CommandSend::_internal_has_num_messages() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommandSend::has_num_messages() const {
  return _internal_has_num_messages();
}
inline void CommandSend::clear_num_messages() {
  num_messages_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandSend::_internal_num_messages() const {
  return num_messages_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandSend::num_messages() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.num_messages)
  return _internal_num_messages();
}
inline void CommandSend::_internal_set_num_messages(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  num_messages_ = value;
}
inline void CommandSend::set_num_messages(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_messages(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.num_messages)
}

// optional uint64 txnid_least_bits = 4 [default = 0];
inline bool CommandSend::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandSend::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandSend::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandSend::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_least_bits_ = value;
}
inline void CommandSend::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 5 [default = 0];
inline bool CommandSend::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandSend::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandSend::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandSend::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  txnid_most_bits_ = value;
}
inline void CommandSend::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.txnid_most_bits)
}

// optional uint64 highest_sequence_id = 6 [default = 0];
inline bool CommandSend::_internal_has_highest_sequence_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandSend::has_highest_sequence_id() const {
  return _internal_has_highest_sequence_id();
}
inline void CommandSend::clear_highest_sequence_id() {
  highest_sequence_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::_internal_highest_sequence_id() const {
  return highest_sequence_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSend::highest_sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.highest_sequence_id)
  return _internal_highest_sequence_id();
}
inline void CommandSend::_internal_set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  highest_sequence_id_ = value;
}
inline void CommandSend::set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_highest_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.highest_sequence_id)
}

// optional bool is_chunk = 7 [default = false];
inline bool CommandSend::_internal_has_is_chunk() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandSend::has_is_chunk() const {
  return _internal_has_is_chunk();
}
inline void CommandSend::clear_is_chunk() {
  is_chunk_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CommandSend::_internal_is_chunk() const {
  return is_chunk_;
}
inline bool CommandSend::is_chunk() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.is_chunk)
  return _internal_is_chunk();
}
inline void CommandSend::_internal_set_is_chunk(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_chunk_ = value;
}
inline void CommandSend::set_is_chunk(bool value) {
  _internal_set_is_chunk(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.is_chunk)
}

// optional bool marker = 8 [default = false];
inline bool CommandSend::_internal_has_marker() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommandSend::has_marker() const {
  return _internal_has_marker();
}
inline void CommandSend::clear_marker() {
  marker_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CommandSend::_internal_marker() const {
  return marker_;
}
inline bool CommandSend::marker() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.marker)
  return _internal_marker();
}
inline void CommandSend::_internal_set_marker(bool value) {
  _has_bits_[0] |= 0x00000080u;
  marker_ = value;
}
inline void CommandSend::set_marker(bool value) {
  _internal_set_marker(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.marker)
}

// optional .pulsar.proto.MessageIdData message_id = 9;
inline bool CommandSend::_internal_has_message_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || message_id_ != nullptr);
  return value;
}
inline bool CommandSend::has_message_id() const {
  return _internal_has_message_id();
}
inline void CommandSend::clear_message_id() {
  if (message_id_ != nullptr) message_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandSend::_internal_message_id() const {
  const ::pulsar::proto::MessageIdData* p = message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(
      ::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandSend::message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.message_id)
  return _internal_message_id();
}
inline void CommandSend::unsafe_arena_set_allocated_message_id(
    ::pulsar::proto::MessageIdData* message_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_id_);
  }
  message_id_ = message_id;
  if (message_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSend.message_id)
}
inline ::pulsar::proto::MessageIdData* CommandSend::release_message_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSend::unsafe_arena_release_message_id() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSend.message_id)
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSend::_internal_mutable_message_id() {
  _has_bits_[0] |= 0x00000001u;
  if (message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArenaForAllocation());
    message_id_ = p;
  }
  return message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSend::mutable_message_id() {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSend.message_id)
  return _msg;
}
inline void CommandSend::set_allocated_message_id(::pulsar::proto::MessageIdData* message_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_id_;
  }
  if (message_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::MessageIdData>::GetOwningArena(message_id);
    if (message_arena != submessage_arena) {
      message_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_id_ = message_id;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSend.message_id)
}

// -------------------------------------------------------------------

// CommandSendReceipt

// required uint64 producer_id = 1;
inline bool CommandSendReceipt::_internal_has_producer_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandSendReceipt::has_producer_id() const {
  return _internal_has_producer_id();
}
inline void CommandSendReceipt::clear_producer_id() {
  producer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendReceipt::_internal_producer_id() const {
  return producer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendReceipt::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.producer_id)
  return _internal_producer_id();
}
inline void CommandSendReceipt::_internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  producer_id_ = value;
}
inline void CommandSendReceipt::set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendReceipt.producer_id)
}

// required uint64 sequence_id = 2;
inline bool CommandSendReceipt::_internal_has_sequence_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandSendReceipt::has_sequence_id() const {
  return _internal_has_sequence_id();
}
inline void CommandSendReceipt::clear_sequence_id() {
  sequence_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendReceipt::_internal_sequence_id() const {
  return sequence_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendReceipt::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.sequence_id)
  return _internal_sequence_id();
}
inline void CommandSendReceipt::_internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  sequence_id_ = value;
}
inline void CommandSendReceipt::set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendReceipt.sequence_id)
}

// optional .pulsar.proto.MessageIdData message_id = 3;
inline bool CommandSendReceipt::_internal_has_message_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || message_id_ != nullptr);
  return value;
}
inline bool CommandSendReceipt::has_message_id() const {
  return _internal_has_message_id();
}
inline void CommandSendReceipt::clear_message_id() {
  if (message_id_ != nullptr) message_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandSendReceipt::_internal_message_id() const {
  const ::pulsar::proto::MessageIdData* p = message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(
      ::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandSendReceipt::message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.message_id)
  return _internal_message_id();
}
inline void CommandSendReceipt::unsafe_arena_set_allocated_message_id(
    ::pulsar::proto::MessageIdData* message_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_id_);
  }
  message_id_ = message_id;
  if (message_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSendReceipt.message_id)
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::release_message_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::unsafe_arena_release_message_id() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSendReceipt.message_id)
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::_internal_mutable_message_id() {
  _has_bits_[0] |= 0x00000001u;
  if (message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArenaForAllocation());
    message_id_ = p;
  }
  return message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::mutable_message_id() {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSendReceipt.message_id)
  return _msg;
}
inline void CommandSendReceipt::set_allocated_message_id(::pulsar::proto::MessageIdData* message_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_id_;
  }
  if (message_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::MessageIdData>::GetOwningArena(message_id);
    if (message_arena != submessage_arena) {
      message_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_id_ = message_id;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSendReceipt.message_id)
}

// optional uint64 highest_sequence_id = 4 [default = 0];
inline bool CommandSendReceipt::_internal_has_highest_sequence_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandSendReceipt::has_highest_sequence_id() const {
  return _internal_has_highest_sequence_id();
}
inline void CommandSendReceipt::clear_highest_sequence_id() {
  highest_sequence_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendReceipt::_internal_highest_sequence_id() const {
  return highest_sequence_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendReceipt::highest_sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.highest_sequence_id)
  return _internal_highest_sequence_id();
}
inline void CommandSendReceipt::_internal_set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  highest_sequence_id_ = value;
}
inline void CommandSendReceipt::set_highest_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_highest_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendReceipt.highest_sequence_id)
}

// -------------------------------------------------------------------

// CommandSendError

// required uint64 producer_id = 1;
inline bool CommandSendError::_internal_has_producer_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandSendError::has_producer_id() const {
  return _internal_has_producer_id();
}
inline void CommandSendError::clear_producer_id() {
  producer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendError::_internal_producer_id() const {
  return producer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendError::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.producer_id)
  return _internal_producer_id();
}
inline void CommandSendError::_internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  producer_id_ = value;
}
inline void CommandSendError::set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.producer_id)
}

// required uint64 sequence_id = 2;
inline bool CommandSendError::_internal_has_sequence_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandSendError::has_sequence_id() const {
  return _internal_has_sequence_id();
}
inline void CommandSendError::clear_sequence_id() {
  sequence_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendError::_internal_sequence_id() const {
  return sequence_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSendError::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.sequence_id)
  return _internal_sequence_id();
}
inline void CommandSendError::_internal_set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  sequence_id_ = value;
}
inline void CommandSendError::set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.sequence_id)
}

// required .pulsar.proto.ServerError error = 3;
inline bool CommandSendError::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandSendError::has_error() const {
  return _internal_has_error();
}
inline void CommandSendError::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::ServerError CommandSendError::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandSendError::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.error)
  return _internal_error();
}
inline void CommandSendError::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  error_ = value;
}
inline void CommandSendError::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.error)
}

// required string message = 4;
inline bool CommandSendError::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandSendError::has_message() const {
  return _internal_has_message();
}
inline void CommandSendError::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandSendError::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandSendError::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.message)
}
inline std::string* CommandSendError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSendError.message)
  return _s;
}
inline const std::string& CommandSendError::_internal_message() const {
  return message_.Get();
}
inline void CommandSendError::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandSendError::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandSendError::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSendError.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandSendError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSendError.message)
}

// -------------------------------------------------------------------

// CommandMessage

// required uint64 consumer_id = 1;
inline bool CommandMessage::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandMessage::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandMessage::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandMessage::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandMessage::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.consumer_id)
  return _internal_consumer_id();
}
inline void CommandMessage::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  consumer_id_ = value;
}
inline void CommandMessage::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.consumer_id)
}

// required .pulsar.proto.MessageIdData message_id = 2;
inline bool CommandMessage::_internal_has_message_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || message_id_ != nullptr);
  return value;
}
inline bool CommandMessage::has_message_id() const {
  return _internal_has_message_id();
}
inline void CommandMessage::clear_message_id() {
  if (message_id_ != nullptr) message_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandMessage::_internal_message_id() const {
  const ::pulsar::proto::MessageIdData* p = message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(
      ::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandMessage::message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.message_id)
  return _internal_message_id();
}
inline void CommandMessage::unsafe_arena_set_allocated_message_id(
    ::pulsar::proto::MessageIdData* message_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_id_);
  }
  message_id_ = message_id;
  if (message_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandMessage.message_id)
}
inline ::pulsar::proto::MessageIdData* CommandMessage::release_message_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandMessage::unsafe_arena_release_message_id() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandMessage.message_id)
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandMessage::_internal_mutable_message_id() {
  _has_bits_[0] |= 0x00000001u;
  if (message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArenaForAllocation());
    message_id_ = p;
  }
  return message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandMessage::mutable_message_id() {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandMessage.message_id)
  return _msg;
}
inline void CommandMessage::set_allocated_message_id(::pulsar::proto::MessageIdData* message_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_id_;
  }
  if (message_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::MessageIdData>::GetOwningArena(message_id);
    if (message_arena != submessage_arena) {
      message_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_id_ = message_id;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandMessage.message_id)
}

// optional uint32 redelivery_count = 3 [default = 0];
inline bool CommandMessage::_internal_has_redelivery_count() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandMessage::has_redelivery_count() const {
  return _internal_has_redelivery_count();
}
inline void CommandMessage::clear_redelivery_count() {
  redelivery_count_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandMessage::_internal_redelivery_count() const {
  return redelivery_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandMessage::redelivery_count() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.redelivery_count)
  return _internal_redelivery_count();
}
inline void CommandMessage::_internal_set_redelivery_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  redelivery_count_ = value;
}
inline void CommandMessage::set_redelivery_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_redelivery_count(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.redelivery_count)
}

// repeated int64 ack_set = 4;
inline int CommandMessage::_internal_ack_set_size() const {
  return ack_set_.size();
}
inline int CommandMessage::ack_set_size() const {
  return _internal_ack_set_size();
}
inline void CommandMessage::clear_ack_set() {
  ack_set_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CommandMessage::_internal_ack_set(int index) const {
  return ack_set_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CommandMessage::ack_set(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.ack_set)
  return _internal_ack_set(index);
}
inline void CommandMessage::set_ack_set(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  ack_set_.Set(index, value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.ack_set)
}
inline void CommandMessage::_internal_add_ack_set(::PROTOBUF_NAMESPACE_ID::int64 value) {
  ack_set_.Add(value);
}
inline void CommandMessage::add_ack_set(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_ack_set(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandMessage.ack_set)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
CommandMessage::_internal_ack_set() const {
  return ack_set_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
CommandMessage::ack_set() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandMessage.ack_set)
  return _internal_ack_set();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
CommandMessage::_internal_mutable_ack_set() {
  return &ack_set_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
CommandMessage::mutable_ack_set() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandMessage.ack_set)
  return _internal_mutable_ack_set();
}

// optional uint64 consumer_epoch = 5;
inline bool CommandMessage::_internal_has_consumer_epoch() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandMessage::has_consumer_epoch() const {
  return _internal_has_consumer_epoch();
}
inline void CommandMessage::clear_consumer_epoch() {
  consumer_epoch_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandMessage::_internal_consumer_epoch() const {
  return consumer_epoch_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandMessage::consumer_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.consumer_epoch)
  return _internal_consumer_epoch();
}
inline void CommandMessage::_internal_set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  consumer_epoch_ = value;
}
inline void CommandMessage::set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.consumer_epoch)
}

// -------------------------------------------------------------------

// CommandAck

// required uint64 consumer_id = 1;
inline bool CommandAck::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandAck::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandAck::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAck::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAck::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.consumer_id)
  return _internal_consumer_id();
}
inline void CommandAck::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  consumer_id_ = value;
}
inline void CommandAck::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.consumer_id)
}

// required .pulsar.proto.CommandAck.AckType ack_type = 2;
inline bool CommandAck::_internal_has_ack_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandAck::has_ack_type() const {
  return _internal_has_ack_type();
}
inline void CommandAck::clear_ack_type() {
  ack_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::pulsar::proto::CommandAck_AckType CommandAck::_internal_ack_type() const {
  return static_cast< ::pulsar::proto::CommandAck_AckType >(ack_type_);
}
inline ::pulsar::proto::CommandAck_AckType CommandAck::ack_type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.ack_type)
  return _internal_ack_type();
}
inline void CommandAck::_internal_set_ack_type(::pulsar::proto::CommandAck_AckType value) {
  assert(::pulsar::proto::CommandAck_AckType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  ack_type_ = value;
}
inline void CommandAck::set_ack_type(::pulsar::proto::CommandAck_AckType value) {
  _internal_set_ack_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.ack_type)
}

// repeated .pulsar.proto.MessageIdData message_id = 3;
inline int CommandAck::_internal_message_id_size() const {
  return message_id_.size();
}
inline int CommandAck::message_id_size() const {
  return _internal_message_id_size();
}
inline void CommandAck::clear_message_id() {
  message_id_.Clear();
}
inline ::pulsar::proto::MessageIdData* CommandAck::mutable_message_id(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAck.message_id)
  return message_id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
CommandAck::mutable_message_id() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAck.message_id)
  return &message_id_;
}
inline const ::pulsar::proto::MessageIdData& CommandAck::_internal_message_id(int index) const {
  return message_id_.Get(index);
}
inline const ::pulsar::proto::MessageIdData& CommandAck::message_id(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.message_id)
  return _internal_message_id(index);
}
inline ::pulsar::proto::MessageIdData* CommandAck::_internal_add_message_id() {
  return message_id_.Add();
}
inline ::pulsar::proto::MessageIdData* CommandAck::add_message_id() {
  ::pulsar::proto::MessageIdData* _add = _internal_add_message_id();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAck.message_id)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
CommandAck::message_id() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAck.message_id)
  return message_id_;
}

// optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
inline bool CommandAck::_internal_has_validation_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandAck::has_validation_error() const {
  return _internal_has_validation_error();
}
inline void CommandAck::clear_validation_error() {
  validation_error_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::pulsar::proto::CommandAck_ValidationError CommandAck::_internal_validation_error() const {
  return static_cast< ::pulsar::proto::CommandAck_ValidationError >(validation_error_);
}
inline ::pulsar::proto::CommandAck_ValidationError CommandAck::validation_error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.validation_error)
  return _internal_validation_error();
}
inline void CommandAck::_internal_set_validation_error(::pulsar::proto::CommandAck_ValidationError value) {
  assert(::pulsar::proto::CommandAck_ValidationError_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  validation_error_ = value;
}
inline void CommandAck::set_validation_error(::pulsar::proto::CommandAck_ValidationError value) {
  _internal_set_validation_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.validation_error)
}

// repeated .pulsar.proto.KeyLongValue properties = 5;
inline int CommandAck::_internal_properties_size() const {
  return properties_.size();
}
inline int CommandAck::properties_size() const {
  return _internal_properties_size();
}
inline void CommandAck::clear_properties() {
  properties_.Clear();
}
inline ::pulsar::proto::KeyLongValue* CommandAck::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAck.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyLongValue >*
CommandAck::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAck.properties)
  return &properties_;
}
inline const ::pulsar::proto::KeyLongValue& CommandAck::_internal_properties(int index) const {
  return properties_.Get(index);
}
inline const ::pulsar::proto::KeyLongValue& CommandAck::properties(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.properties)
  return _internal_properties(index);
}
inline ::pulsar::proto::KeyLongValue* CommandAck::_internal_add_properties() {
  return properties_.Add();
}
inline ::pulsar::proto::KeyLongValue* CommandAck::add_properties() {
  ::pulsar::proto::KeyLongValue* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAck.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::KeyLongValue >&
CommandAck::properties() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAck.properties)
  return properties_;
}

// optional uint64 txnid_least_bits = 6 [default = 0];
inline bool CommandAck::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandAck::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandAck::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAck::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAck::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAck::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_least_bits_ = value;
}
inline void CommandAck::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 7 [default = 0];
inline bool CommandAck::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandAck::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandAck::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAck::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAck::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAck::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  txnid_most_bits_ = value;
}
inline void CommandAck::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.txnid_most_bits)
}

// optional uint64 request_id = 8;
inline bool CommandAck::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandAck::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandAck::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAck::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAck::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.request_id)
  return _internal_request_id();
}
inline void CommandAck::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  request_id_ = value;
}
inline void CommandAck::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.request_id)
}

// -------------------------------------------------------------------

// CommandAckResponse

// required uint64 consumer_id = 1;
inline bool CommandAckResponse::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandAckResponse::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandAckResponse::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAckResponse::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAckResponse::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.consumer_id)
  return _internal_consumer_id();
}
inline void CommandAckResponse::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  consumer_id_ = value;
}
inline void CommandAckResponse::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.consumer_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAckResponse::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandAckResponse::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandAckResponse::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAckResponse::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAckResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAckResponse::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_least_bits_ = value;
}
inline void CommandAckResponse::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAckResponse::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandAckResponse::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandAckResponse::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAckResponse::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAckResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAckResponse::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_most_bits_ = value;
}
inline void CommandAckResponse::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.txnid_most_bits)
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandAckResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandAckResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandAckResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::pulsar::proto::ServerError CommandAckResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandAckResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.error)
  return _internal_error();
}
inline void CommandAckResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  error_ = value;
}
inline void CommandAckResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.error)
}

// optional string message = 5;
inline bool CommandAckResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandAckResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandAckResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAckResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandAckResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.message)
}
inline std::string* CommandAckResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAckResponse.message)
  return _s;
}
inline const std::string& CommandAckResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandAckResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandAckResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandAckResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAckResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandAckResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAckResponse.message)
}

// optional uint64 request_id = 6;
inline bool CommandAckResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandAckResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandAckResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAckResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAckResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.request_id)
  return _internal_request_id();
}
inline void CommandAckResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  request_id_ = value;
}
inline void CommandAckResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.request_id)
}

// -------------------------------------------------------------------

// CommandActiveConsumerChange

// required uint64 consumer_id = 1;
inline bool CommandActiveConsumerChange::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandActiveConsumerChange::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandActiveConsumerChange::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandActiveConsumerChange::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandActiveConsumerChange::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandActiveConsumerChange.consumer_id)
  return _internal_consumer_id();
}
inline void CommandActiveConsumerChange::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  consumer_id_ = value;
}
inline void CommandActiveConsumerChange::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandActiveConsumerChange.consumer_id)
}

// optional bool is_active = 2 [default = false];
inline bool CommandActiveConsumerChange::_internal_has_is_active() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandActiveConsumerChange::has_is_active() const {
  return _internal_has_is_active();
}
inline void CommandActiveConsumerChange::clear_is_active() {
  is_active_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CommandActiveConsumerChange::_internal_is_active() const {
  return is_active_;
}
inline bool CommandActiveConsumerChange::is_active() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandActiveConsumerChange.is_active)
  return _internal_is_active();
}
inline void CommandActiveConsumerChange::_internal_set_is_active(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_active_ = value;
}
inline void CommandActiveConsumerChange::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandActiveConsumerChange.is_active)
}

// -------------------------------------------------------------------

// CommandFlow

// required uint64 consumer_id = 1;
inline bool CommandFlow::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandFlow::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandFlow::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandFlow::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandFlow::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandFlow.consumer_id)
  return _internal_consumer_id();
}
inline void CommandFlow::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  consumer_id_ = value;
}
inline void CommandFlow::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandFlow.consumer_id)
}

// required uint32 messagePermits = 2;
inline bool CommandFlow::_internal_has_messagepermits() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandFlow::has_messagepermits() const {
  return _internal_has_messagepermits();
}
inline void CommandFlow::clear_messagepermits() {
  messagepermits_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandFlow::_internal_messagepermits() const {
  return messagepermits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandFlow::messagepermits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandFlow.messagePermits)
  return _internal_messagepermits();
}
inline void CommandFlow::_internal_set_messagepermits(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  messagepermits_ = value;
}
inline void CommandFlow::set_messagepermits(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_messagepermits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandFlow.messagePermits)
}

// -------------------------------------------------------------------

// CommandUnsubscribe

// required uint64 consumer_id = 1;
inline bool CommandUnsubscribe::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandUnsubscribe::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandUnsubscribe::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandUnsubscribe::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandUnsubscribe::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandUnsubscribe.consumer_id)
  return _internal_consumer_id();
}
inline void CommandUnsubscribe::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  consumer_id_ = value;
}
inline void CommandUnsubscribe::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandUnsubscribe.consumer_id)
}

// required uint64 request_id = 2;
inline bool CommandUnsubscribe::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandUnsubscribe::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandUnsubscribe::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandUnsubscribe::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandUnsubscribe::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandUnsubscribe.request_id)
  return _internal_request_id();
}
inline void CommandUnsubscribe::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandUnsubscribe::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandUnsubscribe.request_id)
}

// -------------------------------------------------------------------

// CommandSeek

// required uint64 consumer_id = 1;
inline bool CommandSeek::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandSeek::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandSeek::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSeek::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSeek::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.consumer_id)
  return _internal_consumer_id();
}
inline void CommandSeek::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  consumer_id_ = value;
}
inline void CommandSeek::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSeek.consumer_id)
}

// required uint64 request_id = 2;
inline bool CommandSeek::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandSeek::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandSeek::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSeek::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSeek::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.request_id)
  return _internal_request_id();
}
inline void CommandSeek::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  request_id_ = value;
}
inline void CommandSeek::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSeek.request_id)
}

// optional .pulsar.proto.MessageIdData message_id = 3;
inline bool CommandSeek::_internal_has_message_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || message_id_ != nullptr);
  return value;
}
inline bool CommandSeek::has_message_id() const {
  return _internal_has_message_id();
}
inline void CommandSeek::clear_message_id() {
  if (message_id_ != nullptr) message_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandSeek::_internal_message_id() const {
  const ::pulsar::proto::MessageIdData* p = message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(
      ::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandSeek::message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.message_id)
  return _internal_message_id();
}
inline void CommandSeek::unsafe_arena_set_allocated_message_id(
    ::pulsar::proto::MessageIdData* message_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_id_);
  }
  message_id_ = message_id;
  if (message_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSeek.message_id)
}
inline ::pulsar::proto::MessageIdData* CommandSeek::release_message_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSeek::unsafe_arena_release_message_id() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSeek.message_id)
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = message_id_;
  message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSeek::_internal_mutable_message_id() {
  _has_bits_[0] |= 0x00000001u;
  if (message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArenaForAllocation());
    message_id_ = p;
  }
  return message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSeek::mutable_message_id() {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSeek.message_id)
  return _msg;
}
inline void CommandSeek::set_allocated_message_id(::pulsar::proto::MessageIdData* message_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_id_;
  }
  if (message_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::MessageIdData>::GetOwningArena(message_id);
    if (message_arena != submessage_arena) {
      message_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_id_ = message_id;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSeek.message_id)
}

// optional uint64 message_publish_time = 4;
inline bool CommandSeek::_internal_has_message_publish_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandSeek::has_message_publish_time() const {
  return _internal_has_message_publish_time();
}
inline void CommandSeek::clear_message_publish_time() {
  message_publish_time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSeek::_internal_message_publish_time() const {
  return message_publish_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSeek::message_publish_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.message_publish_time)
  return _internal_message_publish_time();
}
inline void CommandSeek::_internal_set_message_publish_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  message_publish_time_ = value;
}
inline void CommandSeek::set_message_publish_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_message_publish_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSeek.message_publish_time)
}

// -------------------------------------------------------------------

// CommandReachedEndOfTopic

// required uint64 consumer_id = 1;
inline bool CommandReachedEndOfTopic::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandReachedEndOfTopic::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandReachedEndOfTopic::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandReachedEndOfTopic::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandReachedEndOfTopic::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandReachedEndOfTopic.consumer_id)
  return _internal_consumer_id();
}
inline void CommandReachedEndOfTopic::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  consumer_id_ = value;
}
inline void CommandReachedEndOfTopic::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandReachedEndOfTopic.consumer_id)
}

// -------------------------------------------------------------------

// CommandTopicMigrated

// required uint64 resource_id = 1;
inline bool CommandTopicMigrated::_internal_has_resource_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandTopicMigrated::has_resource_id() const {
  return _internal_has_resource_id();
}
inline void CommandTopicMigrated::clear_resource_id() {
  resource_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandTopicMigrated::_internal_resource_id() const {
  return resource_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandTopicMigrated::resource_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTopicMigrated.resource_id)
  return _internal_resource_id();
}
inline void CommandTopicMigrated::_internal_set_resource_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  resource_id_ = value;
}
inline void CommandTopicMigrated::set_resource_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_resource_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTopicMigrated.resource_id)
}

// required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
inline bool CommandTopicMigrated::_internal_has_resource_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandTopicMigrated::has_resource_type() const {
  return _internal_has_resource_type();
}
inline void CommandTopicMigrated::clear_resource_type() {
  resource_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::CommandTopicMigrated_ResourceType CommandTopicMigrated::_internal_resource_type() const {
  return static_cast< ::pulsar::proto::CommandTopicMigrated_ResourceType >(resource_type_);
}
inline ::pulsar::proto::CommandTopicMigrated_ResourceType CommandTopicMigrated::resource_type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTopicMigrated.resource_type)
  return _internal_resource_type();
}
inline void CommandTopicMigrated::_internal_set_resource_type(::pulsar::proto::CommandTopicMigrated_ResourceType value) {
  assert(::pulsar::proto::CommandTopicMigrated_ResourceType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  resource_type_ = value;
}
inline void CommandTopicMigrated::set_resource_type(::pulsar::proto::CommandTopicMigrated_ResourceType value) {
  _internal_set_resource_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTopicMigrated.resource_type)
}

// optional string brokerServiceUrl = 3;
inline bool CommandTopicMigrated::_internal_has_brokerserviceurl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandTopicMigrated::has_brokerserviceurl() const {
  return _internal_has_brokerserviceurl();
}
inline void CommandTopicMigrated::clear_brokerserviceurl() {
  brokerserviceurl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandTopicMigrated::brokerserviceurl() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
  return _internal_brokerserviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandTopicMigrated::set_brokerserviceurl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 brokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
}
inline std::string* CommandTopicMigrated::mutable_brokerserviceurl() {
  std::string* _s = _internal_mutable_brokerserviceurl();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
  return _s;
}
inline const std::string& CommandTopicMigrated::_internal_brokerserviceurl() const {
  return brokerserviceurl_.Get();
}
inline void CommandTopicMigrated::_internal_set_brokerserviceurl(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  brokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandTopicMigrated::_internal_mutable_brokerserviceurl() {
  _has_bits_[0] |= 0x00000001u;
  return brokerserviceurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandTopicMigrated::release_brokerserviceurl() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
  if (!_internal_has_brokerserviceurl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return brokerserviceurl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandTopicMigrated::set_allocated_brokerserviceurl(std::string* brokerserviceurl) {
  if (brokerserviceurl != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  brokerserviceurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brokerserviceurl,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
}

// optional string brokerServiceUrlTls = 4;
inline bool CommandTopicMigrated::_internal_has_brokerserviceurltls() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandTopicMigrated::has_brokerserviceurltls() const {
  return _internal_has_brokerserviceurltls();
}
inline void CommandTopicMigrated::clear_brokerserviceurltls() {
  brokerserviceurltls_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandTopicMigrated::brokerserviceurltls() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
  return _internal_brokerserviceurltls();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandTopicMigrated::set_brokerserviceurltls(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 brokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
}
inline std::string* CommandTopicMigrated::mutable_brokerserviceurltls() {
  std::string* _s = _internal_mutable_brokerserviceurltls();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
  return _s;
}
inline const std::string& CommandTopicMigrated::_internal_brokerserviceurltls() const {
  return brokerserviceurltls_.Get();
}
inline void CommandTopicMigrated::_internal_set_brokerserviceurltls(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  brokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandTopicMigrated::_internal_mutable_brokerserviceurltls() {
  _has_bits_[0] |= 0x00000002u;
  return brokerserviceurltls_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandTopicMigrated::release_brokerserviceurltls() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
  if (!_internal_has_brokerserviceurltls()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return brokerserviceurltls_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandTopicMigrated::set_allocated_brokerserviceurltls(std::string* brokerserviceurltls) {
  if (brokerserviceurltls != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  brokerserviceurltls_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brokerserviceurltls,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
}

// -------------------------------------------------------------------

// CommandCloseProducer

// required uint64 producer_id = 1;
inline bool CommandCloseProducer::_internal_has_producer_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandCloseProducer::has_producer_id() const {
  return _internal_has_producer_id();
}
inline void CommandCloseProducer::clear_producer_id() {
  producer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandCloseProducer::_internal_producer_id() const {
  return producer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandCloseProducer::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.producer_id)
  return _internal_producer_id();
}
inline void CommandCloseProducer::_internal_set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  producer_id_ = value;
}
inline void CommandCloseProducer::set_producer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.producer_id)
}

// required uint64 request_id = 2;
inline bool CommandCloseProducer::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandCloseProducer::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandCloseProducer::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandCloseProducer::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandCloseProducer::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.request_id)
  return _internal_request_id();
}
inline void CommandCloseProducer::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  request_id_ = value;
}
inline void CommandCloseProducer::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.request_id)
}

// optional string assignedBrokerServiceUrl = 3;
inline bool CommandCloseProducer::_internal_has_assignedbrokerserviceurl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandCloseProducer::has_assignedbrokerserviceurl() const {
  return _internal_has_assignedbrokerserviceurl();
}
inline void CommandCloseProducer::clear_assignedbrokerserviceurl() {
  assignedbrokerserviceurl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandCloseProducer::assignedbrokerserviceurl() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
  return _internal_assignedbrokerserviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandCloseProducer::set_assignedbrokerserviceurl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 assignedbrokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
}
inline std::string* CommandCloseProducer::mutable_assignedbrokerserviceurl() {
  std::string* _s = _internal_mutable_assignedbrokerserviceurl();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
  return _s;
}
inline const std::string& CommandCloseProducer::_internal_assignedbrokerserviceurl() const {
  return assignedbrokerserviceurl_.Get();
}
inline void CommandCloseProducer::_internal_set_assignedbrokerserviceurl(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  assignedbrokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandCloseProducer::_internal_mutable_assignedbrokerserviceurl() {
  _has_bits_[0] |= 0x00000001u;
  return assignedbrokerserviceurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandCloseProducer::release_assignedbrokerserviceurl() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
  if (!_internal_has_assignedbrokerserviceurl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return assignedbrokerserviceurl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandCloseProducer::set_allocated_assignedbrokerserviceurl(std::string* assignedbrokerserviceurl) {
  if (assignedbrokerserviceurl != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  assignedbrokerserviceurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assignedbrokerserviceurl,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
}

// optional string assignedBrokerServiceUrlTls = 4;
inline bool CommandCloseProducer::_internal_has_assignedbrokerserviceurltls() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandCloseProducer::has_assignedbrokerserviceurltls() const {
  return _internal_has_assignedbrokerserviceurltls();
}
inline void CommandCloseProducer::clear_assignedbrokerserviceurltls() {
  assignedbrokerserviceurltls_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandCloseProducer::assignedbrokerserviceurltls() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
  return _internal_assignedbrokerserviceurltls();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandCloseProducer::set_assignedbrokerserviceurltls(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 assignedbrokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
}
inline std::string* CommandCloseProducer::mutable_assignedbrokerserviceurltls() {
  std::string* _s = _internal_mutable_assignedbrokerserviceurltls();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
  return _s;
}
inline const std::string& CommandCloseProducer::_internal_assignedbrokerserviceurltls() const {
  return assignedbrokerserviceurltls_.Get();
}
inline void CommandCloseProducer::_internal_set_assignedbrokerserviceurltls(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  assignedbrokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandCloseProducer::_internal_mutable_assignedbrokerserviceurltls() {
  _has_bits_[0] |= 0x00000002u;
  return assignedbrokerserviceurltls_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandCloseProducer::release_assignedbrokerserviceurltls() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
  if (!_internal_has_assignedbrokerserviceurltls()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return assignedbrokerserviceurltls_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandCloseProducer::set_allocated_assignedbrokerserviceurltls(std::string* assignedbrokerserviceurltls) {
  if (assignedbrokerserviceurltls != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  assignedbrokerserviceurltls_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assignedbrokerserviceurltls,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
}

// -------------------------------------------------------------------

// CommandCloseConsumer

// required uint64 consumer_id = 1;
inline bool CommandCloseConsumer::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandCloseConsumer::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandCloseConsumer::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandCloseConsumer::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandCloseConsumer::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.consumer_id)
  return _internal_consumer_id();
}
inline void CommandCloseConsumer::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  consumer_id_ = value;
}
inline void CommandCloseConsumer::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.consumer_id)
}

// required uint64 request_id = 2;
inline bool CommandCloseConsumer::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandCloseConsumer::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandCloseConsumer::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandCloseConsumer::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandCloseConsumer::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.request_id)
  return _internal_request_id();
}
inline void CommandCloseConsumer::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  request_id_ = value;
}
inline void CommandCloseConsumer::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.request_id)
}

// optional string assignedBrokerServiceUrl = 3;
inline bool CommandCloseConsumer::_internal_has_assignedbrokerserviceurl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandCloseConsumer::has_assignedbrokerserviceurl() const {
  return _internal_has_assignedbrokerserviceurl();
}
inline void CommandCloseConsumer::clear_assignedbrokerserviceurl() {
  assignedbrokerserviceurl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandCloseConsumer::assignedbrokerserviceurl() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
  return _internal_assignedbrokerserviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandCloseConsumer::set_assignedbrokerserviceurl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 assignedbrokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
}
inline std::string* CommandCloseConsumer::mutable_assignedbrokerserviceurl() {
  std::string* _s = _internal_mutable_assignedbrokerserviceurl();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
  return _s;
}
inline const std::string& CommandCloseConsumer::_internal_assignedbrokerserviceurl() const {
  return assignedbrokerserviceurl_.Get();
}
inline void CommandCloseConsumer::_internal_set_assignedbrokerserviceurl(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  assignedbrokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandCloseConsumer::_internal_mutable_assignedbrokerserviceurl() {
  _has_bits_[0] |= 0x00000001u;
  return assignedbrokerserviceurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandCloseConsumer::release_assignedbrokerserviceurl() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
  if (!_internal_has_assignedbrokerserviceurl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return assignedbrokerserviceurl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandCloseConsumer::set_allocated_assignedbrokerserviceurl(std::string* assignedbrokerserviceurl) {
  if (assignedbrokerserviceurl != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  assignedbrokerserviceurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assignedbrokerserviceurl,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
}

// optional string assignedBrokerServiceUrlTls = 4;
inline bool CommandCloseConsumer::_internal_has_assignedbrokerserviceurltls() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandCloseConsumer::has_assignedbrokerserviceurltls() const {
  return _internal_has_assignedbrokerserviceurltls();
}
inline void CommandCloseConsumer::clear_assignedbrokerserviceurltls() {
  assignedbrokerserviceurltls_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandCloseConsumer::assignedbrokerserviceurltls() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
  return _internal_assignedbrokerserviceurltls();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandCloseConsumer::set_assignedbrokerserviceurltls(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 assignedbrokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
}
inline std::string* CommandCloseConsumer::mutable_assignedbrokerserviceurltls() {
  std::string* _s = _internal_mutable_assignedbrokerserviceurltls();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
  return _s;
}
inline const std::string& CommandCloseConsumer::_internal_assignedbrokerserviceurltls() const {
  return assignedbrokerserviceurltls_.Get();
}
inline void CommandCloseConsumer::_internal_set_assignedbrokerserviceurltls(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  assignedbrokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandCloseConsumer::_internal_mutable_assignedbrokerserviceurltls() {
  _has_bits_[0] |= 0x00000002u;
  return assignedbrokerserviceurltls_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandCloseConsumer::release_assignedbrokerserviceurltls() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
  if (!_internal_has_assignedbrokerserviceurltls()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return assignedbrokerserviceurltls_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandCloseConsumer::set_allocated_assignedbrokerserviceurltls(std::string* assignedbrokerserviceurltls) {
  if (assignedbrokerserviceurltls != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  assignedbrokerserviceurltls_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assignedbrokerserviceurltls,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
}

// -------------------------------------------------------------------

// CommandRedeliverUnacknowledgedMessages

// required uint64 consumer_id = 1;
inline bool CommandRedeliverUnacknowledgedMessages::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandRedeliverUnacknowledgedMessages::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandRedeliverUnacknowledgedMessages::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandRedeliverUnacknowledgedMessages::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandRedeliverUnacknowledgedMessages::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_id)
  return _internal_consumer_id();
}
inline void CommandRedeliverUnacknowledgedMessages::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  consumer_id_ = value;
}
inline void CommandRedeliverUnacknowledgedMessages::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_id)
}

// repeated .pulsar.proto.MessageIdData message_ids = 2;
inline int CommandRedeliverUnacknowledgedMessages::_internal_message_ids_size() const {
  return message_ids_.size();
}
inline int CommandRedeliverUnacknowledgedMessages::message_ids_size() const {
  return _internal_message_ids_size();
}
inline void CommandRedeliverUnacknowledgedMessages::clear_message_ids() {
  message_ids_.Clear();
}
inline ::pulsar::proto::MessageIdData* CommandRedeliverUnacknowledgedMessages::mutable_message_ids(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return message_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
CommandRedeliverUnacknowledgedMessages::mutable_message_ids() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return &message_ids_;
}
inline const ::pulsar::proto::MessageIdData& CommandRedeliverUnacknowledgedMessages::_internal_message_ids(int index) const {
  return message_ids_.Get(index);
}
inline const ::pulsar::proto::MessageIdData& CommandRedeliverUnacknowledgedMessages::message_ids(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return _internal_message_ids(index);
}
inline ::pulsar::proto::MessageIdData* CommandRedeliverUnacknowledgedMessages::_internal_add_message_ids() {
  return message_ids_.Add();
}
inline ::pulsar::proto::MessageIdData* CommandRedeliverUnacknowledgedMessages::add_message_ids() {
  ::pulsar::proto::MessageIdData* _add = _internal_add_message_ids();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
CommandRedeliverUnacknowledgedMessages::message_ids() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return message_ids_;
}

// optional uint64 consumer_epoch = 3;
inline bool CommandRedeliverUnacknowledgedMessages::_internal_has_consumer_epoch() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandRedeliverUnacknowledgedMessages::has_consumer_epoch() const {
  return _internal_has_consumer_epoch();
}
inline void CommandRedeliverUnacknowledgedMessages::clear_consumer_epoch() {
  consumer_epoch_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandRedeliverUnacknowledgedMessages::_internal_consumer_epoch() const {
  return consumer_epoch_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandRedeliverUnacknowledgedMessages::consumer_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_epoch)
  return _internal_consumer_epoch();
}
inline void CommandRedeliverUnacknowledgedMessages::_internal_set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  consumer_epoch_ = value;
}
inline void CommandRedeliverUnacknowledgedMessages::set_consumer_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_epoch)
}

// -------------------------------------------------------------------

// CommandSuccess

// required uint64 request_id = 1;
inline bool CommandSuccess::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandSuccess::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandSuccess::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSuccess::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandSuccess::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSuccess.request_id)
  return _internal_request_id();
}
inline void CommandSuccess::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandSuccess::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSuccess.request_id)
}

// optional .pulsar.proto.Schema schema = 2;
inline bool CommandSuccess::_internal_has_schema() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || schema_ != nullptr);
  return value;
}
inline bool CommandSuccess::has_schema() const {
  return _internal_has_schema();
}
inline void CommandSuccess::clear_schema() {
  if (schema_ != nullptr) schema_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::Schema& CommandSuccess::_internal_schema() const {
  const ::pulsar::proto::Schema* p = schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(
      ::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandSuccess::schema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSuccess.schema)
  return _internal_schema();
}
inline void CommandSuccess::unsafe_arena_set_allocated_schema(
    ::pulsar::proto::Schema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_);
  }
  schema_ = schema;
  if (schema) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSuccess.schema)
}
inline ::pulsar::proto::Schema* CommandSuccess::release_schema() {
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::Schema* CommandSuccess::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSuccess.schema)
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandSuccess::_internal_mutable_schema() {
  _has_bits_[0] |= 0x00000001u;
  if (schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArenaForAllocation());
    schema_ = p;
  }
  return schema_;
}
inline ::pulsar::proto::Schema* CommandSuccess::mutable_schema() {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSuccess.schema)
  return _msg;
}
inline void CommandSuccess::set_allocated_schema(::pulsar::proto::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::Schema>::GetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSuccess.schema)
}

// -------------------------------------------------------------------

// CommandProducerSuccess

// required uint64 request_id = 1;
inline bool CommandProducerSuccess::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandProducerSuccess::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandProducerSuccess::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducerSuccess::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducerSuccess::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.request_id)
  return _internal_request_id();
}
inline void CommandProducerSuccess::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  request_id_ = value;
}
inline void CommandProducerSuccess::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.request_id)
}

// required string producer_name = 2;
inline bool CommandProducerSuccess::_internal_has_producer_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandProducerSuccess::has_producer_name() const {
  return _internal_has_producer_name();
}
inline void CommandProducerSuccess::clear_producer_name() {
  producer_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandProducerSuccess::producer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.producer_name)
  return _internal_producer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandProducerSuccess::set_producer_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 producer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.producer_name)
}
inline std::string* CommandProducerSuccess::mutable_producer_name() {
  std::string* _s = _internal_mutable_producer_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducerSuccess.producer_name)
  return _s;
}
inline const std::string& CommandProducerSuccess::_internal_producer_name() const {
  return producer_name_.Get();
}
inline void CommandProducerSuccess::_internal_set_producer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  producer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandProducerSuccess::_internal_mutable_producer_name() {
  _has_bits_[0] |= 0x00000001u;
  return producer_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandProducerSuccess::release_producer_name() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducerSuccess.producer_name)
  if (!_internal_has_producer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return producer_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandProducerSuccess::set_allocated_producer_name(std::string* producer_name) {
  if (producer_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  producer_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), producer_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducerSuccess.producer_name)
}

// optional int64 last_sequence_id = 3 [default = -1];
inline bool CommandProducerSuccess::_internal_has_last_sequence_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandProducerSuccess::has_last_sequence_id() const {
  return _internal_has_last_sequence_id();
}
inline void CommandProducerSuccess::clear_last_sequence_id() {
  last_sequence_id_ = int64_t{-1};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CommandProducerSuccess::_internal_last_sequence_id() const {
  return last_sequence_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CommandProducerSuccess::last_sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.last_sequence_id)
  return _internal_last_sequence_id();
}
inline void CommandProducerSuccess::_internal_set_last_sequence_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  last_sequence_id_ = value;
}
inline void CommandProducerSuccess::set_last_sequence_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_last_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.last_sequence_id)
}

// optional bytes schema_version = 4;
inline bool CommandProducerSuccess::_internal_has_schema_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandProducerSuccess::has_schema_version() const {
  return _internal_has_schema_version();
}
inline void CommandProducerSuccess::clear_schema_version() {
  schema_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandProducerSuccess::schema_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.schema_version)
  return _internal_schema_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandProducerSuccess::set_schema_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 schema_version_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.schema_version)
}
inline std::string* CommandProducerSuccess::mutable_schema_version() {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducerSuccess.schema_version)
  return _s;
}
inline const std::string& CommandProducerSuccess::_internal_schema_version() const {
  return schema_version_.Get();
}
inline void CommandProducerSuccess::_internal_set_schema_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandProducerSuccess::_internal_mutable_schema_version() {
  _has_bits_[0] |= 0x00000002u;
  return schema_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandProducerSuccess::release_schema_version() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducerSuccess.schema_version)
  if (!_internal_has_schema_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return schema_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandProducerSuccess::set_allocated_schema_version(std::string* schema_version) {
  if (schema_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducerSuccess.schema_version)
}

// optional uint64 topic_epoch = 5;
inline bool CommandProducerSuccess::_internal_has_topic_epoch() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandProducerSuccess::has_topic_epoch() const {
  return _internal_has_topic_epoch();
}
inline void CommandProducerSuccess::clear_topic_epoch() {
  topic_epoch_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducerSuccess::_internal_topic_epoch() const {
  return topic_epoch_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandProducerSuccess::topic_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.topic_epoch)
  return _internal_topic_epoch();
}
inline void CommandProducerSuccess::_internal_set_topic_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  topic_epoch_ = value;
}
inline void CommandProducerSuccess::set_topic_epoch(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_topic_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.topic_epoch)
}

// optional bool producer_ready = 6 [default = true];
inline bool CommandProducerSuccess::_internal_has_producer_ready() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandProducerSuccess::has_producer_ready() const {
  return _internal_has_producer_ready();
}
inline void CommandProducerSuccess::clear_producer_ready() {
  producer_ready_ = true;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CommandProducerSuccess::_internal_producer_ready() const {
  return producer_ready_;
}
inline bool CommandProducerSuccess::producer_ready() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.producer_ready)
  return _internal_producer_ready();
}
inline void CommandProducerSuccess::_internal_set_producer_ready(bool value) {
  _has_bits_[0] |= 0x00000010u;
  producer_ready_ = value;
}
inline void CommandProducerSuccess::set_producer_ready(bool value) {
  _internal_set_producer_ready(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.producer_ready)
}

// -------------------------------------------------------------------

// CommandError

// required uint64 request_id = 1;
inline bool CommandError::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandError::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandError::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandError::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandError::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandError.request_id)
  return _internal_request_id();
}
inline void CommandError::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandError::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandError.request_id)
}

// required .pulsar.proto.ServerError error = 2;
inline bool CommandError::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandError::has_error() const {
  return _internal_has_error();
}
inline void CommandError::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::pulsar::proto::ServerError CommandError::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandError::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandError.error)
  return _internal_error();
}
inline void CommandError::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  error_ = value;
}
inline void CommandError::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandError.error)
}

// required string message = 3;
inline bool CommandError::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandError::has_message() const {
  return _internal_has_message();
}
inline void CommandError::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandError::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandError.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandError::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandError.message)
}
inline std::string* CommandError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandError.message)
  return _s;
}
inline const std::string& CommandError::_internal_message() const {
  return message_.Get();
}
inline void CommandError::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandError::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandError::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandError.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandError.message)
}

// -------------------------------------------------------------------

// CommandPing

// -------------------------------------------------------------------

// CommandPong

// -------------------------------------------------------------------

// CommandConsumerStats

// required uint64 request_id = 1;
inline bool CommandConsumerStats::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandConsumerStats::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandConsumerStats::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStats::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStats::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStats.request_id)
  return _internal_request_id();
}
inline void CommandConsumerStats::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_ = value;
}
inline void CommandConsumerStats::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStats.request_id)
}

// required uint64 consumer_id = 4;
inline bool CommandConsumerStats::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandConsumerStats::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandConsumerStats::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStats::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStats::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStats.consumer_id)
  return _internal_consumer_id();
}
inline void CommandConsumerStats::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  consumer_id_ = value;
}
inline void CommandConsumerStats::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStats.consumer_id)
}

// -------------------------------------------------------------------

// CommandConsumerStatsResponse

// required uint64 request_id = 1;
inline bool CommandConsumerStatsResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandConsumerStatsResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStatsResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStatsResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.request_id)
  return _internal_request_id();
}
inline void CommandConsumerStatsResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  request_id_ = value;
}
inline void CommandConsumerStatsResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.request_id)
}

// optional .pulsar.proto.ServerError error_code = 2;
inline bool CommandConsumerStatsResponse::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void CommandConsumerStatsResponse::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::pulsar::proto::ServerError CommandConsumerStatsResponse::_internal_error_code() const {
  return static_cast< ::pulsar::proto::ServerError >(error_code_);
}
inline ::pulsar::proto::ServerError CommandConsumerStatsResponse::error_code() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.error_code)
  return _internal_error_code();
}
inline void CommandConsumerStatsResponse::_internal_set_error_code(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  error_code_ = value;
}
inline void CommandConsumerStatsResponse::set_error_code(::pulsar::proto::ServerError value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.error_code)
}

// optional string error_message = 3;
inline bool CommandConsumerStatsResponse::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void CommandConsumerStatsResponse::clear_error_message() {
  error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandConsumerStatsResponse::error_message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConsumerStatsResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.error_message)
}
inline std::string* CommandConsumerStatsResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.error_message)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000001u;
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConsumerStatsResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.error_message)
}

// optional double msgRateOut = 4;
inline bool CommandConsumerStatsResponse::_internal_has_msgrateout() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_msgrateout() const {
  return _internal_has_msgrateout();
}
inline void CommandConsumerStatsResponse::clear_msgrateout() {
  msgrateout_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double CommandConsumerStatsResponse::_internal_msgrateout() const {
  return msgrateout_;
}
inline double CommandConsumerStatsResponse::msgrateout() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgRateOut)
  return _internal_msgrateout();
}
inline void CommandConsumerStatsResponse::_internal_set_msgrateout(double value) {
  _has_bits_[0] |= 0x00000040u;
  msgrateout_ = value;
}
inline void CommandConsumerStatsResponse::set_msgrateout(double value) {
  _internal_set_msgrateout(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgRateOut)
}

// optional double msgThroughputOut = 5;
inline bool CommandConsumerStatsResponse::_internal_has_msgthroughputout() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_msgthroughputout() const {
  return _internal_has_msgthroughputout();
}
inline void CommandConsumerStatsResponse::clear_msgthroughputout() {
  msgthroughputout_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double CommandConsumerStatsResponse::_internal_msgthroughputout() const {
  return msgthroughputout_;
}
inline double CommandConsumerStatsResponse::msgthroughputout() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgThroughputOut)
  return _internal_msgthroughputout();
}
inline void CommandConsumerStatsResponse::_internal_set_msgthroughputout(double value) {
  _has_bits_[0] |= 0x00000080u;
  msgthroughputout_ = value;
}
inline void CommandConsumerStatsResponse::set_msgthroughputout(double value) {
  _internal_set_msgthroughputout(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgThroughputOut)
}

// optional double msgRateRedeliver = 6;
inline bool CommandConsumerStatsResponse::_internal_has_msgrateredeliver() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_msgrateredeliver() const {
  return _internal_has_msgrateredeliver();
}
inline void CommandConsumerStatsResponse::clear_msgrateredeliver() {
  msgrateredeliver_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double CommandConsumerStatsResponse::_internal_msgrateredeliver() const {
  return msgrateredeliver_;
}
inline double CommandConsumerStatsResponse::msgrateredeliver() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgRateRedeliver)
  return _internal_msgrateredeliver();
}
inline void CommandConsumerStatsResponse::_internal_set_msgrateredeliver(double value) {
  _has_bits_[0] |= 0x00000100u;
  msgrateredeliver_ = value;
}
inline void CommandConsumerStatsResponse::set_msgrateredeliver(double value) {
  _internal_set_msgrateredeliver(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgRateRedeliver)
}

// optional string consumerName = 7;
inline bool CommandConsumerStatsResponse::_internal_has_consumername() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_consumername() const {
  return _internal_has_consumername();
}
inline void CommandConsumerStatsResponse::clear_consumername() {
  consumername_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandConsumerStatsResponse::consumername() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.consumerName)
  return _internal_consumername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConsumerStatsResponse::set_consumername(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 consumername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.consumerName)
}
inline std::string* CommandConsumerStatsResponse::mutable_consumername() {
  std::string* _s = _internal_mutable_consumername();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.consumerName)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_consumername() const {
  return consumername_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_consumername(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  consumername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_consumername() {
  _has_bits_[0] |= 0x00000002u;
  return consumername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::release_consumername() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.consumerName)
  if (!_internal_has_consumername()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return consumername_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConsumerStatsResponse::set_allocated_consumername(std::string* consumername) {
  if (consumername != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  consumername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), consumername,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.consumerName)
}

// optional uint64 availablePermits = 8;
inline bool CommandConsumerStatsResponse::_internal_has_availablepermits() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_availablepermits() const {
  return _internal_has_availablepermits();
}
inline void CommandConsumerStatsResponse::clear_availablepermits() {
  availablepermits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStatsResponse::_internal_availablepermits() const {
  return availablepermits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStatsResponse::availablepermits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.availablePermits)
  return _internal_availablepermits();
}
inline void CommandConsumerStatsResponse::_internal_set_availablepermits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000800u;
  availablepermits_ = value;
}
inline void CommandConsumerStatsResponse::set_availablepermits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_availablepermits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.availablePermits)
}

// optional uint64 unackedMessages = 9;
inline bool CommandConsumerStatsResponse::_internal_has_unackedmessages() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_unackedmessages() const {
  return _internal_has_unackedmessages();
}
inline void CommandConsumerStatsResponse::clear_unackedmessages() {
  unackedmessages_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStatsResponse::_internal_unackedmessages() const {
  return unackedmessages_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStatsResponse::unackedmessages() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.unackedMessages)
  return _internal_unackedmessages();
}
inline void CommandConsumerStatsResponse::_internal_set_unackedmessages(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00001000u;
  unackedmessages_ = value;
}
inline void CommandConsumerStatsResponse::set_unackedmessages(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_unackedmessages(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.unackedMessages)
}

// optional bool blockedConsumerOnUnackedMsgs = 10;
inline bool CommandConsumerStatsResponse::_internal_has_blockedconsumeronunackedmsgs() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_blockedconsumeronunackedmsgs() const {
  return _internal_has_blockedconsumeronunackedmsgs();
}
inline void CommandConsumerStatsResponse::clear_blockedconsumeronunackedmsgs() {
  blockedconsumeronunackedmsgs_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CommandConsumerStatsResponse::_internal_blockedconsumeronunackedmsgs() const {
  return blockedconsumeronunackedmsgs_;
}
inline bool CommandConsumerStatsResponse::blockedconsumeronunackedmsgs() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.blockedConsumerOnUnackedMsgs)
  return _internal_blockedconsumeronunackedmsgs();
}
inline void CommandConsumerStatsResponse::_internal_set_blockedconsumeronunackedmsgs(bool value) {
  _has_bits_[0] |= 0x00000400u;
  blockedconsumeronunackedmsgs_ = value;
}
inline void CommandConsumerStatsResponse::set_blockedconsumeronunackedmsgs(bool value) {
  _internal_set_blockedconsumeronunackedmsgs(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.blockedConsumerOnUnackedMsgs)
}

// optional string address = 11;
inline bool CommandConsumerStatsResponse::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_address() const {
  return _internal_has_address();
}
inline void CommandConsumerStatsResponse::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandConsumerStatsResponse::address() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConsumerStatsResponse::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.address)
}
inline std::string* CommandConsumerStatsResponse::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.address)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_address() const {
  return address_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000004u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::release_address() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConsumerStatsResponse::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.address)
}

// optional string connectedSince = 12;
inline bool CommandConsumerStatsResponse::_internal_has_connectedsince() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_connectedsince() const {
  return _internal_has_connectedsince();
}
inline void CommandConsumerStatsResponse::clear_connectedsince() {
  connectedsince_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandConsumerStatsResponse::connectedsince() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
  return _internal_connectedsince();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConsumerStatsResponse::set_connectedsince(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 connectedsince_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
}
inline std::string* CommandConsumerStatsResponse::mutable_connectedsince() {
  std::string* _s = _internal_mutable_connectedsince();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_connectedsince() const {
  return connectedsince_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_connectedsince(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  connectedsince_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_connectedsince() {
  _has_bits_[0] |= 0x00000008u;
  return connectedsince_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::release_connectedsince() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
  if (!_internal_has_connectedsince()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return connectedsince_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConsumerStatsResponse::set_allocated_connectedsince(std::string* connectedsince) {
  if (connectedsince != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  connectedsince_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), connectedsince,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
}

// optional string type = 13;
inline bool CommandConsumerStatsResponse::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_type() const {
  return _internal_has_type();
}
inline void CommandConsumerStatsResponse::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommandConsumerStatsResponse::type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandConsumerStatsResponse::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.type)
}
inline std::string* CommandConsumerStatsResponse::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.type)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_type() const {
  return type_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000010u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandConsumerStatsResponse::release_type() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandConsumerStatsResponse::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.type)
}

// optional double msgRateExpired = 14;
inline bool CommandConsumerStatsResponse::_internal_has_msgrateexpired() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_msgrateexpired() const {
  return _internal_has_msgrateexpired();
}
inline void CommandConsumerStatsResponse::clear_msgrateexpired() {
  msgrateexpired_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline double CommandConsumerStatsResponse::_internal_msgrateexpired() const {
  return msgrateexpired_;
}
inline double CommandConsumerStatsResponse::msgrateexpired() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgRateExpired)
  return _internal_msgrateexpired();
}
inline void CommandConsumerStatsResponse::_internal_set_msgrateexpired(double value) {
  _has_bits_[0] |= 0x00002000u;
  msgrateexpired_ = value;
}
inline void CommandConsumerStatsResponse::set_msgrateexpired(double value) {
  _internal_set_msgrateexpired(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgRateExpired)
}

// optional uint64 msgBacklog = 15;
inline bool CommandConsumerStatsResponse::_internal_has_msgbacklog() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_msgbacklog() const {
  return _internal_has_msgbacklog();
}
inline void CommandConsumerStatsResponse::clear_msgbacklog() {
  msgbacklog_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStatsResponse::_internal_msgbacklog() const {
  return msgbacklog_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandConsumerStatsResponse::msgbacklog() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgBacklog)
  return _internal_msgbacklog();
}
inline void CommandConsumerStatsResponse::_internal_set_msgbacklog(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00004000u;
  msgbacklog_ = value;
}
inline void CommandConsumerStatsResponse::set_msgbacklog(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_msgbacklog(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgBacklog)
}

// optional double messageAckRate = 16;
inline bool CommandConsumerStatsResponse::_internal_has_messageackrate() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CommandConsumerStatsResponse::has_messageackrate() const {
  return _internal_has_messageackrate();
}
inline void CommandConsumerStatsResponse::clear_messageackrate() {
  messageackrate_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline double CommandConsumerStatsResponse::_internal_messageackrate() const {
  return messageackrate_;
}
inline double CommandConsumerStatsResponse::messageackrate() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.messageAckRate)
  return _internal_messageackrate();
}
inline void CommandConsumerStatsResponse::_internal_set_messageackrate(double value) {
  _has_bits_[0] |= 0x00008000u;
  messageackrate_ = value;
}
inline void CommandConsumerStatsResponse::set_messageackrate(double value) {
  _internal_set_messageackrate(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.messageAckRate)
}

// -------------------------------------------------------------------

// CommandGetLastMessageId

// required uint64 consumer_id = 1;
inline bool CommandGetLastMessageId::_internal_has_consumer_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandGetLastMessageId::has_consumer_id() const {
  return _internal_has_consumer_id();
}
inline void CommandGetLastMessageId::clear_consumer_id() {
  consumer_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetLastMessageId::_internal_consumer_id() const {
  return consumer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetLastMessageId::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageId.consumer_id)
  return _internal_consumer_id();
}
inline void CommandGetLastMessageId::_internal_set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  consumer_id_ = value;
}
inline void CommandGetLastMessageId::set_consumer_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetLastMessageId.consumer_id)
}

// required uint64 request_id = 2;
inline bool CommandGetLastMessageId::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandGetLastMessageId::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandGetLastMessageId::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetLastMessageId::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetLastMessageId::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageId.request_id)
  return _internal_request_id();
}
inline void CommandGetLastMessageId::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandGetLastMessageId::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetLastMessageId.request_id)
}

// -------------------------------------------------------------------

// CommandGetLastMessageIdResponse

// required .pulsar.proto.MessageIdData last_message_id = 1;
inline bool CommandGetLastMessageIdResponse::_internal_has_last_message_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || last_message_id_ != nullptr);
  return value;
}
inline bool CommandGetLastMessageIdResponse::has_last_message_id() const {
  return _internal_has_last_message_id();
}
inline void CommandGetLastMessageIdResponse::clear_last_message_id() {
  if (last_message_id_ != nullptr) last_message_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::_internal_last_message_id() const {
  const ::pulsar::proto::MessageIdData* p = last_message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(
      ::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::last_message_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
  return _internal_last_message_id();
}
inline void CommandGetLastMessageIdResponse::unsafe_arena_set_allocated_last_message_id(
    ::pulsar::proto::MessageIdData* last_message_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_message_id_);
  }
  last_message_id_ = last_message_id;
  if (last_message_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::release_last_message_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = last_message_id_;
  last_message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::unsafe_arena_release_last_message_id() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = last_message_id_;
  last_message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::_internal_mutable_last_message_id() {
  _has_bits_[0] |= 0x00000001u;
  if (last_message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArenaForAllocation());
    last_message_id_ = p;
  }
  return last_message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::mutable_last_message_id() {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_last_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
  return _msg;
}
inline void CommandGetLastMessageIdResponse::set_allocated_last_message_id(::pulsar::proto::MessageIdData* last_message_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete last_message_id_;
  }
  if (last_message_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::MessageIdData>::GetOwningArena(last_message_id);
    if (message_arena != submessage_arena) {
      last_message_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_message_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  last_message_id_ = last_message_id;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
}

// required uint64 request_id = 2;
inline bool CommandGetLastMessageIdResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandGetLastMessageIdResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandGetLastMessageIdResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetLastMessageIdResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetLastMessageIdResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageIdResponse.request_id)
  return _internal_request_id();
}
inline void CommandGetLastMessageIdResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  request_id_ = value;
}
inline void CommandGetLastMessageIdResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetLastMessageIdResponse.request_id)
}

// optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
inline bool CommandGetLastMessageIdResponse::_internal_has_consumer_mark_delete_position() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || consumer_mark_delete_position_ != nullptr);
  return value;
}
inline bool CommandGetLastMessageIdResponse::has_consumer_mark_delete_position() const {
  return _internal_has_consumer_mark_delete_position();
}
inline void CommandGetLastMessageIdResponse::clear_consumer_mark_delete_position() {
  if (consumer_mark_delete_position_ != nullptr) consumer_mark_delete_position_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::_internal_consumer_mark_delete_position() const {
  const ::pulsar::proto::MessageIdData* p = consumer_mark_delete_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(
      ::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::consumer_mark_delete_position() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)
  return _internal_consumer_mark_delete_position();
}
inline void CommandGetLastMessageIdResponse::unsafe_arena_set_allocated_consumer_mark_delete_position(
    ::pulsar::proto::MessageIdData* consumer_mark_delete_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consumer_mark_delete_position_);
  }
  consumer_mark_delete_position_ = consumer_mark_delete_position;
  if (consumer_mark_delete_position) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::release_consumer_mark_delete_position() {
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::MessageIdData* temp = consumer_mark_delete_position_;
  consumer_mark_delete_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::unsafe_arena_release_consumer_mark_delete_position() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::MessageIdData* temp = consumer_mark_delete_position_;
  consumer_mark_delete_position_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::_internal_mutable_consumer_mark_delete_position() {
  _has_bits_[0] |= 0x00000002u;
  if (consumer_mark_delete_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArenaForAllocation());
    consumer_mark_delete_position_ = p;
  }
  return consumer_mark_delete_position_;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::mutable_consumer_mark_delete_position() {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_consumer_mark_delete_position();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)
  return _msg;
}
inline void CommandGetLastMessageIdResponse::set_allocated_consumer_mark_delete_position(::pulsar::proto::MessageIdData* consumer_mark_delete_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete consumer_mark_delete_position_;
  }
  if (consumer_mark_delete_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::MessageIdData>::GetOwningArena(consumer_mark_delete_position);
    if (message_arena != submessage_arena) {
      consumer_mark_delete_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consumer_mark_delete_position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  consumer_mark_delete_position_ = consumer_mark_delete_position;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)
}

// -------------------------------------------------------------------

// CommandGetTopicsOfNamespace

// required uint64 request_id = 1;
inline bool CommandGetTopicsOfNamespace::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandGetTopicsOfNamespace::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandGetTopicsOfNamespace::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetTopicsOfNamespace::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetTopicsOfNamespace::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.request_id)
  return _internal_request_id();
}
inline void CommandGetTopicsOfNamespace::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  request_id_ = value;
}
inline void CommandGetTopicsOfNamespace::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.request_id)
}

// required string namespace = 2;
inline bool CommandGetTopicsOfNamespace::_internal_has_namespace_() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandGetTopicsOfNamespace::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void CommandGetTopicsOfNamespace::clear_namespace_() {
  namespace__.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetTopicsOfNamespace::namespace_() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetTopicsOfNamespace::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
}
inline std::string* CommandGetTopicsOfNamespace::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespace::_internal_namespace_() const {
  return namespace__.Get();
}
inline void CommandGetTopicsOfNamespace::_internal_set_namespace_(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetTopicsOfNamespace::_internal_mutable_namespace_() {
  _has_bits_[0] |= 0x00000001u;
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetTopicsOfNamespace::release_namespace_() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace__.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetTopicsOfNamespace::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
}

// optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
inline bool CommandGetTopicsOfNamespace::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandGetTopicsOfNamespace::has_mode() const {
  return _internal_has_mode();
}
inline void CommandGetTopicsOfNamespace::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::_internal_mode() const {
  return static_cast< ::pulsar::proto::CommandGetTopicsOfNamespace_Mode >(mode_);
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::mode() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.mode)
  return _internal_mode();
}
inline void CommandGetTopicsOfNamespace::_internal_set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value) {
  assert(::pulsar::proto::CommandGetTopicsOfNamespace_Mode_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  mode_ = value;
}
inline void CommandGetTopicsOfNamespace::set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.mode)
}

// optional string topics_pattern = 4;
inline bool CommandGetTopicsOfNamespace::_internal_has_topics_pattern() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandGetTopicsOfNamespace::has_topics_pattern() const {
  return _internal_has_topics_pattern();
}
inline void CommandGetTopicsOfNamespace::clear_topics_pattern() {
  topics_pattern_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetTopicsOfNamespace::topics_pattern() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
  return _internal_topics_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetTopicsOfNamespace::set_topics_pattern(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 topics_pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
}
inline std::string* CommandGetTopicsOfNamespace::mutable_topics_pattern() {
  std::string* _s = _internal_mutable_topics_pattern();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespace::_internal_topics_pattern() const {
  return topics_pattern_.Get();
}
inline void CommandGetTopicsOfNamespace::_internal_set_topics_pattern(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  topics_pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetTopicsOfNamespace::_internal_mutable_topics_pattern() {
  _has_bits_[0] |= 0x00000002u;
  return topics_pattern_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetTopicsOfNamespace::release_topics_pattern() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
  if (!_internal_has_topics_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return topics_pattern_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetTopicsOfNamespace::set_allocated_topics_pattern(std::string* topics_pattern) {
  if (topics_pattern != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  topics_pattern_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topics_pattern,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
}

// optional string topics_hash = 5;
inline bool CommandGetTopicsOfNamespace::_internal_has_topics_hash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandGetTopicsOfNamespace::has_topics_hash() const {
  return _internal_has_topics_hash();
}
inline void CommandGetTopicsOfNamespace::clear_topics_hash() {
  topics_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandGetTopicsOfNamespace::topics_hash() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
  return _internal_topics_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetTopicsOfNamespace::set_topics_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
}
inline std::string* CommandGetTopicsOfNamespace::mutable_topics_hash() {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespace::_internal_topics_hash() const {
  return topics_hash_.Get();
}
inline void CommandGetTopicsOfNamespace::_internal_set_topics_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetTopicsOfNamespace::_internal_mutable_topics_hash() {
  _has_bits_[0] |= 0x00000004u;
  return topics_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetTopicsOfNamespace::release_topics_hash() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
  if (!_internal_has_topics_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return topics_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetTopicsOfNamespace::set_allocated_topics_hash(std::string* topics_hash) {
  if (topics_hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  topics_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topics_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
}

// -------------------------------------------------------------------

// CommandGetTopicsOfNamespaceResponse

// required uint64 request_id = 1;
inline bool CommandGetTopicsOfNamespaceResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandGetTopicsOfNamespaceResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandGetTopicsOfNamespaceResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetTopicsOfNamespaceResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetTopicsOfNamespaceResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.request_id)
  return _internal_request_id();
}
inline void CommandGetTopicsOfNamespaceResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandGetTopicsOfNamespaceResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.request_id)
}

// repeated string topics = 2;
inline int CommandGetTopicsOfNamespaceResponse::_internal_topics_size() const {
  return topics_.size();
}
inline int CommandGetTopicsOfNamespaceResponse::topics_size() const {
  return _internal_topics_size();
}
inline void CommandGetTopicsOfNamespaceResponse::clear_topics() {
  topics_.Clear();
}
inline std::string* CommandGetTopicsOfNamespaceResponse::add_topics() {
  std::string* _s = _internal_add_topics();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespaceResponse::_internal_topics(int index) const {
  return topics_.Get(index);
}
inline const std::string& CommandGetTopicsOfNamespaceResponse::topics(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return _internal_topics(index);
}
inline std::string* CommandGetTopicsOfNamespaceResponse::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return topics_.Mutable(index);
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, const std::string& value) {
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, std::string&& value) {
  topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, const char* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline std::string* CommandGetTopicsOfNamespaceResponse::_internal_add_topics() {
  return topics_.Add();
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(const std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(std::string&& value) {
  topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(const char* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CommandGetTopicsOfNamespaceResponse::topics() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CommandGetTopicsOfNamespaceResponse::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return &topics_;
}

// optional bool filtered = 3 [default = false];
inline bool CommandGetTopicsOfNamespaceResponse::_internal_has_filtered() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandGetTopicsOfNamespaceResponse::has_filtered() const {
  return _internal_has_filtered();
}
inline void CommandGetTopicsOfNamespaceResponse::clear_filtered() {
  filtered_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CommandGetTopicsOfNamespaceResponse::_internal_filtered() const {
  return filtered_;
}
inline bool CommandGetTopicsOfNamespaceResponse::filtered() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.filtered)
  return _internal_filtered();
}
inline void CommandGetTopicsOfNamespaceResponse::_internal_set_filtered(bool value) {
  _has_bits_[0] |= 0x00000004u;
  filtered_ = value;
}
inline void CommandGetTopicsOfNamespaceResponse::set_filtered(bool value) {
  _internal_set_filtered(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.filtered)
}

// optional string topics_hash = 4;
inline bool CommandGetTopicsOfNamespaceResponse::_internal_has_topics_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandGetTopicsOfNamespaceResponse::has_topics_hash() const {
  return _internal_has_topics_hash();
}
inline void CommandGetTopicsOfNamespaceResponse::clear_topics_hash() {
  topics_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetTopicsOfNamespaceResponse::topics_hash() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
  return _internal_topics_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetTopicsOfNamespaceResponse::set_topics_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
}
inline std::string* CommandGetTopicsOfNamespaceResponse::mutable_topics_hash() {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespaceResponse::_internal_topics_hash() const {
  return topics_hash_.Get();
}
inline void CommandGetTopicsOfNamespaceResponse::_internal_set_topics_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetTopicsOfNamespaceResponse::_internal_mutable_topics_hash() {
  _has_bits_[0] |= 0x00000001u;
  return topics_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetTopicsOfNamespaceResponse::release_topics_hash() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
  if (!_internal_has_topics_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topics_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetTopicsOfNamespaceResponse::set_allocated_topics_hash(std::string* topics_hash) {
  if (topics_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topics_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topics_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
}

// optional bool changed = 5 [default = true];
inline bool CommandGetTopicsOfNamespaceResponse::_internal_has_changed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandGetTopicsOfNamespaceResponse::has_changed() const {
  return _internal_has_changed();
}
inline void CommandGetTopicsOfNamespaceResponse::clear_changed() {
  changed_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CommandGetTopicsOfNamespaceResponse::_internal_changed() const {
  return changed_;
}
inline bool CommandGetTopicsOfNamespaceResponse::changed() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.changed)
  return _internal_changed();
}
inline void CommandGetTopicsOfNamespaceResponse::_internal_set_changed(bool value) {
  _has_bits_[0] |= 0x00000008u;
  changed_ = value;
}
inline void CommandGetTopicsOfNamespaceResponse::set_changed(bool value) {
  _internal_set_changed(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.changed)
}

// -------------------------------------------------------------------

// CommandWatchTopicList

// required uint64 request_id = 1;
inline bool CommandWatchTopicList::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandWatchTopicList::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandWatchTopicList::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicList::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicList::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.request_id)
  return _internal_request_id();
}
inline void CommandWatchTopicList::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  request_id_ = value;
}
inline void CommandWatchTopicList::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.request_id)
}

// required uint64 watcher_id = 2;
inline bool CommandWatchTopicList::_internal_has_watcher_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandWatchTopicList::has_watcher_id() const {
  return _internal_has_watcher_id();
}
inline void CommandWatchTopicList::clear_watcher_id() {
  watcher_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicList::_internal_watcher_id() const {
  return watcher_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicList::watcher_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.watcher_id)
  return _internal_watcher_id();
}
inline void CommandWatchTopicList::_internal_set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  watcher_id_ = value;
}
inline void CommandWatchTopicList::set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_watcher_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.watcher_id)
}

// required string namespace = 3;
inline bool CommandWatchTopicList::_internal_has_namespace_() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandWatchTopicList::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void CommandWatchTopicList::clear_namespace_() {
  namespace__.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandWatchTopicList::namespace_() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandWatchTopicList::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.namespace)
}
inline std::string* CommandWatchTopicList::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicList.namespace)
  return _s;
}
inline const std::string& CommandWatchTopicList::_internal_namespace_() const {
  return namespace__.Get();
}
inline void CommandWatchTopicList::_internal_set_namespace_(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicList::_internal_mutable_namespace_() {
  _has_bits_[0] |= 0x00000001u;
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicList::release_namespace_() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicList.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace__.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandWatchTopicList::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicList.namespace)
}

// required string topics_pattern = 4;
inline bool CommandWatchTopicList::_internal_has_topics_pattern() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandWatchTopicList::has_topics_pattern() const {
  return _internal_has_topics_pattern();
}
inline void CommandWatchTopicList::clear_topics_pattern() {
  topics_pattern_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandWatchTopicList::topics_pattern() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.topics_pattern)
  return _internal_topics_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandWatchTopicList::set_topics_pattern(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 topics_pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.topics_pattern)
}
inline std::string* CommandWatchTopicList::mutable_topics_pattern() {
  std::string* _s = _internal_mutable_topics_pattern();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicList.topics_pattern)
  return _s;
}
inline const std::string& CommandWatchTopicList::_internal_topics_pattern() const {
  return topics_pattern_.Get();
}
inline void CommandWatchTopicList::_internal_set_topics_pattern(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  topics_pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicList::_internal_mutable_topics_pattern() {
  _has_bits_[0] |= 0x00000002u;
  return topics_pattern_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicList::release_topics_pattern() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicList.topics_pattern)
  if (!_internal_has_topics_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return topics_pattern_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandWatchTopicList::set_allocated_topics_pattern(std::string* topics_pattern) {
  if (topics_pattern != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  topics_pattern_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topics_pattern,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicList.topics_pattern)
}

// optional string topics_hash = 5;
inline bool CommandWatchTopicList::_internal_has_topics_hash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandWatchTopicList::has_topics_hash() const {
  return _internal_has_topics_hash();
}
inline void CommandWatchTopicList::clear_topics_hash() {
  topics_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandWatchTopicList::topics_hash() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.topics_hash)
  return _internal_topics_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandWatchTopicList::set_topics_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.topics_hash)
}
inline std::string* CommandWatchTopicList::mutable_topics_hash() {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicList.topics_hash)
  return _s;
}
inline const std::string& CommandWatchTopicList::_internal_topics_hash() const {
  return topics_hash_.Get();
}
inline void CommandWatchTopicList::_internal_set_topics_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicList::_internal_mutable_topics_hash() {
  _has_bits_[0] |= 0x00000004u;
  return topics_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicList::release_topics_hash() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicList.topics_hash)
  if (!_internal_has_topics_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return topics_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandWatchTopicList::set_allocated_topics_hash(std::string* topics_hash) {
  if (topics_hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  topics_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topics_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicList.topics_hash)
}

// -------------------------------------------------------------------

// CommandWatchTopicListSuccess

// required uint64 request_id = 1;
inline bool CommandWatchTopicListSuccess::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandWatchTopicListSuccess::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandWatchTopicListSuccess::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicListSuccess::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicListSuccess::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListSuccess.request_id)
  return _internal_request_id();
}
inline void CommandWatchTopicListSuccess::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandWatchTopicListSuccess::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.request_id)
}

// required uint64 watcher_id = 2;
inline bool CommandWatchTopicListSuccess::_internal_has_watcher_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandWatchTopicListSuccess::has_watcher_id() const {
  return _internal_has_watcher_id();
}
inline void CommandWatchTopicListSuccess::clear_watcher_id() {
  watcher_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicListSuccess::_internal_watcher_id() const {
  return watcher_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicListSuccess::watcher_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListSuccess.watcher_id)
  return _internal_watcher_id();
}
inline void CommandWatchTopicListSuccess::_internal_set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  watcher_id_ = value;
}
inline void CommandWatchTopicListSuccess::set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_watcher_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.watcher_id)
}

// repeated string topic = 3;
inline int CommandWatchTopicListSuccess::_internal_topic_size() const {
  return topic_.size();
}
inline int CommandWatchTopicListSuccess::topic_size() const {
  return _internal_topic_size();
}
inline void CommandWatchTopicListSuccess::clear_topic() {
  topic_.Clear();
}
inline std::string* CommandWatchTopicListSuccess::add_topic() {
  std::string* _s = _internal_add_topic();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandWatchTopicListSuccess.topic)
  return _s;
}
inline const std::string& CommandWatchTopicListSuccess::_internal_topic(int index) const {
  return topic_.Get(index);
}
inline const std::string& CommandWatchTopicListSuccess::topic(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListSuccess.topic)
  return _internal_topic(index);
}
inline std::string* CommandWatchTopicListSuccess::mutable_topic(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicListSuccess.topic)
  return topic_.Mutable(index);
}
inline void CommandWatchTopicListSuccess::set_topic(int index, const std::string& value) {
  topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::set_topic(int index, std::string&& value) {
  topic_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::set_topic(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topic_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::set_topic(int index, const char* value, size_t size) {
  topic_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline std::string* CommandWatchTopicListSuccess::_internal_add_topic() {
  return topic_.Add();
}
inline void CommandWatchTopicListSuccess::add_topic(const std::string& value) {
  topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::add_topic(std::string&& value) {
  topic_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::add_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topic_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::add_topic(const char* value, size_t size) {
  topic_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CommandWatchTopicListSuccess::topic() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandWatchTopicListSuccess.topic)
  return topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CommandWatchTopicListSuccess::mutable_topic() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandWatchTopicListSuccess.topic)
  return &topic_;
}

// required string topics_hash = 4;
inline bool CommandWatchTopicListSuccess::_internal_has_topics_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandWatchTopicListSuccess::has_topics_hash() const {
  return _internal_has_topics_hash();
}
inline void CommandWatchTopicListSuccess::clear_topics_hash() {
  topics_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandWatchTopicListSuccess::topics_hash() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
  return _internal_topics_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandWatchTopicListSuccess::set_topics_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
}
inline std::string* CommandWatchTopicListSuccess::mutable_topics_hash() {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
  return _s;
}
inline const std::string& CommandWatchTopicListSuccess::_internal_topics_hash() const {
  return topics_hash_.Get();
}
inline void CommandWatchTopicListSuccess::_internal_set_topics_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicListSuccess::_internal_mutable_topics_hash() {
  _has_bits_[0] |= 0x00000001u;
  return topics_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicListSuccess::release_topics_hash() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
  if (!_internal_has_topics_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topics_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandWatchTopicListSuccess::set_allocated_topics_hash(std::string* topics_hash) {
  if (topics_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topics_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topics_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
}

// -------------------------------------------------------------------

// CommandWatchTopicUpdate

// required uint64 watcher_id = 1;
inline bool CommandWatchTopicUpdate::_internal_has_watcher_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandWatchTopicUpdate::has_watcher_id() const {
  return _internal_has_watcher_id();
}
inline void CommandWatchTopicUpdate::clear_watcher_id() {
  watcher_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicUpdate::_internal_watcher_id() const {
  return watcher_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicUpdate::watcher_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicUpdate.watcher_id)
  return _internal_watcher_id();
}
inline void CommandWatchTopicUpdate::_internal_set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  watcher_id_ = value;
}
inline void CommandWatchTopicUpdate::set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_watcher_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.watcher_id)
}

// repeated string new_topics = 2;
inline int CommandWatchTopicUpdate::_internal_new_topics_size() const {
  return new_topics_.size();
}
inline int CommandWatchTopicUpdate::new_topics_size() const {
  return _internal_new_topics_size();
}
inline void CommandWatchTopicUpdate::clear_new_topics() {
  new_topics_.Clear();
}
inline std::string* CommandWatchTopicUpdate::add_new_topics() {
  std::string* _s = _internal_add_new_topics();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  return _s;
}
inline const std::string& CommandWatchTopicUpdate::_internal_new_topics(int index) const {
  return new_topics_.Get(index);
}
inline const std::string& CommandWatchTopicUpdate::new_topics(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  return _internal_new_topics(index);
}
inline std::string* CommandWatchTopicUpdate::mutable_new_topics(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  return new_topics_.Mutable(index);
}
inline void CommandWatchTopicUpdate::set_new_topics(int index, const std::string& value) {
  new_topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::set_new_topics(int index, std::string&& value) {
  new_topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::set_new_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::set_new_topics(int index, const char* value, size_t size) {
  new_topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline std::string* CommandWatchTopicUpdate::_internal_add_new_topics() {
  return new_topics_.Add();
}
inline void CommandWatchTopicUpdate::add_new_topics(const std::string& value) {
  new_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::add_new_topics(std::string&& value) {
  new_topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::add_new_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::add_new_topics(const char* value, size_t size) {
  new_topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CommandWatchTopicUpdate::new_topics() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  return new_topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CommandWatchTopicUpdate::mutable_new_topics() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  return &new_topics_;
}

// repeated string deleted_topics = 3;
inline int CommandWatchTopicUpdate::_internal_deleted_topics_size() const {
  return deleted_topics_.size();
}
inline int CommandWatchTopicUpdate::deleted_topics_size() const {
  return _internal_deleted_topics_size();
}
inline void CommandWatchTopicUpdate::clear_deleted_topics() {
  deleted_topics_.Clear();
}
inline std::string* CommandWatchTopicUpdate::add_deleted_topics() {
  std::string* _s = _internal_add_deleted_topics();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  return _s;
}
inline const std::string& CommandWatchTopicUpdate::_internal_deleted_topics(int index) const {
  return deleted_topics_.Get(index);
}
inline const std::string& CommandWatchTopicUpdate::deleted_topics(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  return _internal_deleted_topics(index);
}
inline std::string* CommandWatchTopicUpdate::mutable_deleted_topics(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  return deleted_topics_.Mutable(index);
}
inline void CommandWatchTopicUpdate::set_deleted_topics(int index, const std::string& value) {
  deleted_topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::set_deleted_topics(int index, std::string&& value) {
  deleted_topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::set_deleted_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  deleted_topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::set_deleted_topics(int index, const char* value, size_t size) {
  deleted_topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline std::string* CommandWatchTopicUpdate::_internal_add_deleted_topics() {
  return deleted_topics_.Add();
}
inline void CommandWatchTopicUpdate::add_deleted_topics(const std::string& value) {
  deleted_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::add_deleted_topics(std::string&& value) {
  deleted_topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::add_deleted_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  deleted_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::add_deleted_topics(const char* value, size_t size) {
  deleted_topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CommandWatchTopicUpdate::deleted_topics() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  return deleted_topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CommandWatchTopicUpdate::mutable_deleted_topics() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  return &deleted_topics_;
}

// required string topics_hash = 4;
inline bool CommandWatchTopicUpdate::_internal_has_topics_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandWatchTopicUpdate::has_topics_hash() const {
  return _internal_has_topics_hash();
}
inline void CommandWatchTopicUpdate::clear_topics_hash() {
  topics_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandWatchTopicUpdate::topics_hash() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
  return _internal_topics_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandWatchTopicUpdate::set_topics_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
}
inline std::string* CommandWatchTopicUpdate::mutable_topics_hash() {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
  return _s;
}
inline const std::string& CommandWatchTopicUpdate::_internal_topics_hash() const {
  return topics_hash_.Get();
}
inline void CommandWatchTopicUpdate::_internal_set_topics_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicUpdate::_internal_mutable_topics_hash() {
  _has_bits_[0] |= 0x00000001u;
  return topics_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandWatchTopicUpdate::release_topics_hash() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
  if (!_internal_has_topics_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topics_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandWatchTopicUpdate::set_allocated_topics_hash(std::string* topics_hash) {
  if (topics_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topics_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topics_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
}

// -------------------------------------------------------------------

// CommandWatchTopicListClose

// required uint64 request_id = 1;
inline bool CommandWatchTopicListClose::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandWatchTopicListClose::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandWatchTopicListClose::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicListClose::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicListClose::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListClose.request_id)
  return _internal_request_id();
}
inline void CommandWatchTopicListClose::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_ = value;
}
inline void CommandWatchTopicListClose::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListClose.request_id)
}

// required uint64 watcher_id = 2;
inline bool CommandWatchTopicListClose::_internal_has_watcher_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandWatchTopicListClose::has_watcher_id() const {
  return _internal_has_watcher_id();
}
inline void CommandWatchTopicListClose::clear_watcher_id() {
  watcher_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicListClose::_internal_watcher_id() const {
  return watcher_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandWatchTopicListClose::watcher_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListClose.watcher_id)
  return _internal_watcher_id();
}
inline void CommandWatchTopicListClose::_internal_set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  watcher_id_ = value;
}
inline void CommandWatchTopicListClose::set_watcher_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_watcher_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListClose.watcher_id)
}

// -------------------------------------------------------------------

// CommandGetSchema

// required uint64 request_id = 1;
inline bool CommandGetSchema::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandGetSchema::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandGetSchema::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetSchema::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetSchema::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchema.request_id)
  return _internal_request_id();
}
inline void CommandGetSchema::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  request_id_ = value;
}
inline void CommandGetSchema::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchema.request_id)
}

// required string topic = 2;
inline bool CommandGetSchema::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandGetSchema::has_topic() const {
  return _internal_has_topic();
}
inline void CommandGetSchema::clear_topic() {
  topic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetSchema::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchema.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetSchema::set_topic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchema.topic)
}
inline std::string* CommandGetSchema::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchema.topic)
  return _s;
}
inline const std::string& CommandGetSchema::_internal_topic() const {
  return topic_.Get();
}
inline void CommandGetSchema::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetSchema::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetSchema::release_topic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchema.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetSchema::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchema.topic)
}

// optional bytes schema_version = 3;
inline bool CommandGetSchema::_internal_has_schema_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandGetSchema::has_schema_version() const {
  return _internal_has_schema_version();
}
inline void CommandGetSchema::clear_schema_version() {
  schema_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetSchema::schema_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchema.schema_version)
  return _internal_schema_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetSchema::set_schema_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 schema_version_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchema.schema_version)
}
inline std::string* CommandGetSchema::mutable_schema_version() {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchema.schema_version)
  return _s;
}
inline const std::string& CommandGetSchema::_internal_schema_version() const {
  return schema_version_.Get();
}
inline void CommandGetSchema::_internal_set_schema_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetSchema::_internal_mutable_schema_version() {
  _has_bits_[0] |= 0x00000002u;
  return schema_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetSchema::release_schema_version() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchema.schema_version)
  if (!_internal_has_schema_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return schema_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetSchema::set_allocated_schema_version(std::string* schema_version) {
  if (schema_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchema.schema_version)
}

// -------------------------------------------------------------------

// CommandGetSchemaResponse

// required uint64 request_id = 1;
inline bool CommandGetSchemaResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandGetSchemaResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandGetSchemaResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetSchemaResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetSchemaResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.request_id)
  return _internal_request_id();
}
inline void CommandGetSchemaResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  request_id_ = value;
}
inline void CommandGetSchemaResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.request_id)
}

// optional .pulsar.proto.ServerError error_code = 2;
inline bool CommandGetSchemaResponse::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandGetSchemaResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void CommandGetSchemaResponse::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandGetSchemaResponse::_internal_error_code() const {
  return static_cast< ::pulsar::proto::ServerError >(error_code_);
}
inline ::pulsar::proto::ServerError CommandGetSchemaResponse::error_code() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.error_code)
  return _internal_error_code();
}
inline void CommandGetSchemaResponse::_internal_set_error_code(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_code_ = value;
}
inline void CommandGetSchemaResponse::set_error_code(::pulsar::proto::ServerError value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.error_code)
}

// optional string error_message = 3;
inline bool CommandGetSchemaResponse::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandGetSchemaResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void CommandGetSchemaResponse::clear_error_message() {
  error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetSchemaResponse::error_message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetSchemaResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.error_message)
}
inline std::string* CommandGetSchemaResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchemaResponse.error_message)
  return _s;
}
inline const std::string& CommandGetSchemaResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void CommandGetSchemaResponse::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetSchemaResponse::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000001u;
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetSchemaResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchemaResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetSchemaResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchemaResponse.error_message)
}

// optional .pulsar.proto.Schema schema = 4;
inline bool CommandGetSchemaResponse::_internal_has_schema() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || schema_ != nullptr);
  return value;
}
inline bool CommandGetSchemaResponse::has_schema() const {
  return _internal_has_schema();
}
inline void CommandGetSchemaResponse::clear_schema() {
  if (schema_ != nullptr) schema_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pulsar::proto::Schema& CommandGetSchemaResponse::_internal_schema() const {
  const ::pulsar::proto::Schema* p = schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(
      ::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandGetSchemaResponse::schema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.schema)
  return _internal_schema();
}
inline void CommandGetSchemaResponse::unsafe_arena_set_allocated_schema(
    ::pulsar::proto::Schema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_);
  }
  schema_ = schema;
  if (schema) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandGetSchemaResponse.schema)
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::release_schema() {
  _has_bits_[0] &= ~0x00000004u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchemaResponse.schema)
  _has_bits_[0] &= ~0x00000004u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::_internal_mutable_schema() {
  _has_bits_[0] |= 0x00000004u;
  if (schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArenaForAllocation());
    schema_ = p;
  }
  return schema_;
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::mutable_schema() {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchemaResponse.schema)
  return _msg;
}
inline void CommandGetSchemaResponse::set_allocated_schema(::pulsar::proto::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::Schema>::GetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchemaResponse.schema)
}

// optional bytes schema_version = 5;
inline bool CommandGetSchemaResponse::_internal_has_schema_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandGetSchemaResponse::has_schema_version() const {
  return _internal_has_schema_version();
}
inline void CommandGetSchemaResponse::clear_schema_version() {
  schema_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetSchemaResponse::schema_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.schema_version)
  return _internal_schema_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetSchemaResponse::set_schema_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 schema_version_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.schema_version)
}
inline std::string* CommandGetSchemaResponse::mutable_schema_version() {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchemaResponse.schema_version)
  return _s;
}
inline const std::string& CommandGetSchemaResponse::_internal_schema_version() const {
  return schema_version_.Get();
}
inline void CommandGetSchemaResponse::_internal_set_schema_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetSchemaResponse::_internal_mutable_schema_version() {
  _has_bits_[0] |= 0x00000002u;
  return schema_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetSchemaResponse::release_schema_version() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchemaResponse.schema_version)
  if (!_internal_has_schema_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return schema_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetSchemaResponse::set_allocated_schema_version(std::string* schema_version) {
  if (schema_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchemaResponse.schema_version)
}

// -------------------------------------------------------------------

// CommandGetOrCreateSchema

// required uint64 request_id = 1;
inline bool CommandGetOrCreateSchema::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandGetOrCreateSchema::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandGetOrCreateSchema::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetOrCreateSchema::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetOrCreateSchema::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchema.request_id)
  return _internal_request_id();
}
inline void CommandGetOrCreateSchema::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  request_id_ = value;
}
inline void CommandGetOrCreateSchema::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchema.request_id)
}

// required string topic = 2;
inline bool CommandGetOrCreateSchema::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandGetOrCreateSchema::has_topic() const {
  return _internal_has_topic();
}
inline void CommandGetOrCreateSchema::clear_topic() {
  topic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetOrCreateSchema::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchema.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetOrCreateSchema::set_topic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchema.topic)
}
inline std::string* CommandGetOrCreateSchema::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetOrCreateSchema.topic)
  return _s;
}
inline const std::string& CommandGetOrCreateSchema::_internal_topic() const {
  return topic_.Get();
}
inline void CommandGetOrCreateSchema::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetOrCreateSchema::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetOrCreateSchema::release_topic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetOrCreateSchema.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetOrCreateSchema::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetOrCreateSchema.topic)
}

// required .pulsar.proto.Schema schema = 3;
inline bool CommandGetOrCreateSchema::_internal_has_schema() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || schema_ != nullptr);
  return value;
}
inline bool CommandGetOrCreateSchema::has_schema() const {
  return _internal_has_schema();
}
inline void CommandGetOrCreateSchema::clear_schema() {
  if (schema_ != nullptr) schema_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::Schema& CommandGetOrCreateSchema::_internal_schema() const {
  const ::pulsar::proto::Schema* p = schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(
      ::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandGetOrCreateSchema::schema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchema.schema)
  return _internal_schema();
}
inline void CommandGetOrCreateSchema::unsafe_arena_set_allocated_schema(
    ::pulsar::proto::Schema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_);
  }
  schema_ = schema;
  if (schema) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandGetOrCreateSchema.schema)
}
inline ::pulsar::proto::Schema* CommandGetOrCreateSchema::release_schema() {
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::Schema* CommandGetOrCreateSchema::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetOrCreateSchema.schema)
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::Schema* temp = schema_;
  schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandGetOrCreateSchema::_internal_mutable_schema() {
  _has_bits_[0] |= 0x00000002u;
  if (schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArenaForAllocation());
    schema_ = p;
  }
  return schema_;
}
inline ::pulsar::proto::Schema* CommandGetOrCreateSchema::mutable_schema() {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetOrCreateSchema.schema)
  return _msg;
}
inline void CommandGetOrCreateSchema::set_allocated_schema(::pulsar::proto::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::Schema>::GetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetOrCreateSchema.schema)
}

// -------------------------------------------------------------------

// CommandGetOrCreateSchemaResponse

// required uint64 request_id = 1;
inline bool CommandGetOrCreateSchemaResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandGetOrCreateSchemaResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandGetOrCreateSchemaResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetOrCreateSchemaResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandGetOrCreateSchemaResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchemaResponse.request_id)
  return _internal_request_id();
}
inline void CommandGetOrCreateSchemaResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  request_id_ = value;
}
inline void CommandGetOrCreateSchemaResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchemaResponse.request_id)
}

// optional .pulsar.proto.ServerError error_code = 2;
inline bool CommandGetOrCreateSchemaResponse::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandGetOrCreateSchemaResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void CommandGetOrCreateSchemaResponse::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::ServerError CommandGetOrCreateSchemaResponse::_internal_error_code() const {
  return static_cast< ::pulsar::proto::ServerError >(error_code_);
}
inline ::pulsar::proto::ServerError CommandGetOrCreateSchemaResponse::error_code() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchemaResponse.error_code)
  return _internal_error_code();
}
inline void CommandGetOrCreateSchemaResponse::_internal_set_error_code(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  error_code_ = value;
}
inline void CommandGetOrCreateSchemaResponse::set_error_code(::pulsar::proto::ServerError value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchemaResponse.error_code)
}

// optional string error_message = 3;
inline bool CommandGetOrCreateSchemaResponse::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandGetOrCreateSchemaResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void CommandGetOrCreateSchemaResponse::clear_error_message() {
  error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetOrCreateSchemaResponse::error_message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetOrCreateSchemaResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
}
inline std::string* CommandGetOrCreateSchemaResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
  return _s;
}
inline const std::string& CommandGetOrCreateSchemaResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void CommandGetOrCreateSchemaResponse::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetOrCreateSchemaResponse::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000001u;
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetOrCreateSchemaResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetOrCreateSchemaResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
}

// optional bytes schema_version = 4;
inline bool CommandGetOrCreateSchemaResponse::_internal_has_schema_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandGetOrCreateSchemaResponse::has_schema_version() const {
  return _internal_has_schema_version();
}
inline void CommandGetOrCreateSchemaResponse::clear_schema_version() {
  schema_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetOrCreateSchemaResponse::schema_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
  return _internal_schema_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandGetOrCreateSchemaResponse::set_schema_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 schema_version_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
}
inline std::string* CommandGetOrCreateSchemaResponse::mutable_schema_version() {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
  return _s;
}
inline const std::string& CommandGetOrCreateSchemaResponse::_internal_schema_version() const {
  return schema_version_.Get();
}
inline void CommandGetOrCreateSchemaResponse::_internal_set_schema_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandGetOrCreateSchemaResponse::_internal_mutable_schema_version() {
  _has_bits_[0] |= 0x00000002u;
  return schema_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandGetOrCreateSchemaResponse::release_schema_version() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
  if (!_internal_has_schema_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return schema_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandGetOrCreateSchemaResponse::set_allocated_schema_version(std::string* schema_version) {
  if (schema_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
}

// -------------------------------------------------------------------

// CommandTcClientConnectRequest

// required uint64 request_id = 1;
inline bool CommandTcClientConnectRequest::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandTcClientConnectRequest::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandTcClientConnectRequest::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandTcClientConnectRequest::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandTcClientConnectRequest::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectRequest.request_id)
  return _internal_request_id();
}
inline void CommandTcClientConnectRequest::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_ = value;
}
inline void CommandTcClientConnectRequest::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectRequest.request_id)
}

// required uint64 tc_id = 2 [default = 0];
inline bool CommandTcClientConnectRequest::_internal_has_tc_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandTcClientConnectRequest::has_tc_id() const {
  return _internal_has_tc_id();
}
inline void CommandTcClientConnectRequest::clear_tc_id() {
  tc_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandTcClientConnectRequest::_internal_tc_id() const {
  return tc_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandTcClientConnectRequest::tc_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectRequest.tc_id)
  return _internal_tc_id();
}
inline void CommandTcClientConnectRequest::_internal_set_tc_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  tc_id_ = value;
}
inline void CommandTcClientConnectRequest::set_tc_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tc_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectRequest.tc_id)
}

// -------------------------------------------------------------------

// CommandTcClientConnectResponse

// required uint64 request_id = 1;
inline bool CommandTcClientConnectResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandTcClientConnectResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandTcClientConnectResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandTcClientConnectResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandTcClientConnectResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectResponse.request_id)
  return _internal_request_id();
}
inline void CommandTcClientConnectResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandTcClientConnectResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectResponse.request_id)
}

// optional .pulsar.proto.ServerError error = 2;
inline bool CommandTcClientConnectResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandTcClientConnectResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandTcClientConnectResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::pulsar::proto::ServerError CommandTcClientConnectResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandTcClientConnectResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectResponse.error)
  return _internal_error();
}
inline void CommandTcClientConnectResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  error_ = value;
}
inline void CommandTcClientConnectResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectResponse.error)
}

// optional string message = 3;
inline bool CommandTcClientConnectResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandTcClientConnectResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandTcClientConnectResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandTcClientConnectResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandTcClientConnectResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectResponse.message)
}
inline std::string* CommandTcClientConnectResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandTcClientConnectResponse.message)
  return _s;
}
inline const std::string& CommandTcClientConnectResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandTcClientConnectResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandTcClientConnectResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandTcClientConnectResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandTcClientConnectResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandTcClientConnectResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandTcClientConnectResponse.message)
}

// -------------------------------------------------------------------

// CommandNewTxn

// required uint64 request_id = 1;
inline bool CommandNewTxn::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandNewTxn::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandNewTxn::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxn::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxn::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxn.request_id)
  return _internal_request_id();
}
inline void CommandNewTxn::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_ = value;
}
inline void CommandNewTxn::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxn.request_id)
}

// optional uint64 txn_ttl_seconds = 2 [default = 0];
inline bool CommandNewTxn::_internal_has_txn_ttl_seconds() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandNewTxn::has_txn_ttl_seconds() const {
  return _internal_has_txn_ttl_seconds();
}
inline void CommandNewTxn::clear_txn_ttl_seconds() {
  txn_ttl_seconds_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxn::_internal_txn_ttl_seconds() const {
  return txn_ttl_seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxn::txn_ttl_seconds() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxn.txn_ttl_seconds)
  return _internal_txn_ttl_seconds();
}
inline void CommandNewTxn::_internal_set_txn_ttl_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  txn_ttl_seconds_ = value;
}
inline void CommandNewTxn::set_txn_ttl_seconds(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txn_ttl_seconds(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxn.txn_ttl_seconds)
}

// optional uint64 tc_id = 3 [default = 0];
inline bool CommandNewTxn::_internal_has_tc_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandNewTxn::has_tc_id() const {
  return _internal_has_tc_id();
}
inline void CommandNewTxn::clear_tc_id() {
  tc_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxn::_internal_tc_id() const {
  return tc_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxn::tc_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxn.tc_id)
  return _internal_tc_id();
}
inline void CommandNewTxn::_internal_set_tc_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  tc_id_ = value;
}
inline void CommandNewTxn::set_tc_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tc_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxn.tc_id)
}

// -------------------------------------------------------------------

// CommandNewTxnResponse

// required uint64 request_id = 1;
inline bool CommandNewTxnResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandNewTxnResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandNewTxnResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxnResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxnResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.request_id)
  return _internal_request_id();
}
inline void CommandNewTxnResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandNewTxnResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandNewTxnResponse::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandNewTxnResponse::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandNewTxnResponse::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxnResponse::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxnResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandNewTxnResponse::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_least_bits_ = value;
}
inline void CommandNewTxnResponse::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandNewTxnResponse::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandNewTxnResponse::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandNewTxnResponse::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxnResponse::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandNewTxnResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandNewTxnResponse::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_most_bits_ = value;
}
inline void CommandNewTxnResponse::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.txnid_most_bits)
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandNewTxnResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandNewTxnResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandNewTxnResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandNewTxnResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandNewTxnResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.error)
  return _internal_error();
}
inline void CommandNewTxnResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
}
inline void CommandNewTxnResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.error)
}

// optional string message = 5;
inline bool CommandNewTxnResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandNewTxnResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandNewTxnResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandNewTxnResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandNewTxnResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.message)
}
inline std::string* CommandNewTxnResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandNewTxnResponse.message)
  return _s;
}
inline const std::string& CommandNewTxnResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandNewTxnResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandNewTxnResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandNewTxnResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandNewTxnResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandNewTxnResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandNewTxnResponse.message)
}

// -------------------------------------------------------------------

// CommandAddPartitionToTxn

// required uint64 request_id = 1;
inline bool CommandAddPartitionToTxn::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandAddPartitionToTxn::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandAddPartitionToTxn::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxn::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxn::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxn.request_id)
  return _internal_request_id();
}
inline void CommandAddPartitionToTxn::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_ = value;
}
inline void CommandAddPartitionToTxn::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAddPartitionToTxn::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandAddPartitionToTxn::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandAddPartitionToTxn::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxn::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxn::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxn.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAddPartitionToTxn::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  txnid_least_bits_ = value;
}
inline void CommandAddPartitionToTxn::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAddPartitionToTxn::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandAddPartitionToTxn::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandAddPartitionToTxn::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxn::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxn::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxn.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAddPartitionToTxn::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_most_bits_ = value;
}
inline void CommandAddPartitionToTxn::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.txnid_most_bits)
}

// repeated string partitions = 4;
inline int CommandAddPartitionToTxn::_internal_partitions_size() const {
  return partitions_.size();
}
inline int CommandAddPartitionToTxn::partitions_size() const {
  return _internal_partitions_size();
}
inline void CommandAddPartitionToTxn::clear_partitions() {
  partitions_.Clear();
}
inline std::string* CommandAddPartitionToTxn::add_partitions() {
  std::string* _s = _internal_add_partitions();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandAddPartitionToTxn.partitions)
  return _s;
}
inline const std::string& CommandAddPartitionToTxn::_internal_partitions(int index) const {
  return partitions_.Get(index);
}
inline const std::string& CommandAddPartitionToTxn::partitions(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxn.partitions)
  return _internal_partitions(index);
}
inline std::string* CommandAddPartitionToTxn::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAddPartitionToTxn.partitions)
  return partitions_.Mutable(index);
}
inline void CommandAddPartitionToTxn::set_partitions(int index, const std::string& value) {
  partitions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::set_partitions(int index, std::string&& value) {
  partitions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::set_partitions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partitions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::set_partitions(int index, const char* value, size_t size) {
  partitions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline std::string* CommandAddPartitionToTxn::_internal_add_partitions() {
  return partitions_.Add();
}
inline void CommandAddPartitionToTxn::add_partitions(const std::string& value) {
  partitions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::add_partitions(std::string&& value) {
  partitions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::add_partitions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partitions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::add_partitions(const char* value, size_t size) {
  partitions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CommandAddPartitionToTxn::partitions() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAddPartitionToTxn.partitions)
  return partitions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CommandAddPartitionToTxn::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAddPartitionToTxn.partitions)
  return &partitions_;
}

// -------------------------------------------------------------------

// CommandAddPartitionToTxnResponse

// required uint64 request_id = 1;
inline bool CommandAddPartitionToTxnResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandAddPartitionToTxnResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandAddPartitionToTxnResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxnResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxnResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.request_id)
  return _internal_request_id();
}
inline void CommandAddPartitionToTxnResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandAddPartitionToTxnResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAddPartitionToTxnResponse::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandAddPartitionToTxnResponse::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandAddPartitionToTxnResponse::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxnResponse::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxnResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAddPartitionToTxnResponse::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_least_bits_ = value;
}
inline void CommandAddPartitionToTxnResponse::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAddPartitionToTxnResponse::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandAddPartitionToTxnResponse::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandAddPartitionToTxnResponse::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxnResponse::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddPartitionToTxnResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAddPartitionToTxnResponse::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_most_bits_ = value;
}
inline void CommandAddPartitionToTxnResponse::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.txnid_most_bits)
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandAddPartitionToTxnResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandAddPartitionToTxnResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandAddPartitionToTxnResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandAddPartitionToTxnResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandAddPartitionToTxnResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.error)
  return _internal_error();
}
inline void CommandAddPartitionToTxnResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
}
inline void CommandAddPartitionToTxnResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.error)
}

// optional string message = 5;
inline bool CommandAddPartitionToTxnResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandAddPartitionToTxnResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandAddPartitionToTxnResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAddPartitionToTxnResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandAddPartitionToTxnResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.message)
}
inline std::string* CommandAddPartitionToTxnResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAddPartitionToTxnResponse.message)
  return _s;
}
inline const std::string& CommandAddPartitionToTxnResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandAddPartitionToTxnResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandAddPartitionToTxnResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandAddPartitionToTxnResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAddPartitionToTxnResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandAddPartitionToTxnResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAddPartitionToTxnResponse.message)
}

// -------------------------------------------------------------------

// Subscription

// required string topic = 1;
inline bool Subscription::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Subscription::has_topic() const {
  return _internal_has_topic();
}
inline void Subscription::clear_topic() {
  topic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Subscription::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Subscription.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_topic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.Subscription.topic)
}
inline std::string* Subscription::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Subscription.topic)
  return _s;
}
inline const std::string& Subscription::_internal_topic() const {
  return topic_.Get();
}
inline void Subscription::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_topic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.Subscription.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Subscription.topic)
}

// required string subscription = 2;
inline bool Subscription::_internal_has_subscription() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Subscription::has_subscription() const {
  return _internal_has_subscription();
}
inline void Subscription::clear_subscription() {
  subscription_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Subscription::subscription() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Subscription.subscription)
  return _internal_subscription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_subscription(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 subscription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.Subscription.subscription)
}
inline std::string* Subscription::mutable_subscription() {
  std::string* _s = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Subscription.subscription)
  return _s;
}
inline const std::string& Subscription::_internal_subscription() const {
  return subscription_.Get();
}
inline void Subscription::_internal_set_subscription(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  subscription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_subscription() {
  _has_bits_[0] |= 0x00000002u;
  return subscription_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_subscription() {
  // @@protoc_insertion_point(field_release:pulsar.proto.Subscription.subscription)
  if (!_internal_has_subscription()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return subscription_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_subscription(std::string* subscription) {
  if (subscription != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  subscription_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Subscription.subscription)
}

// -------------------------------------------------------------------

// CommandAddSubscriptionToTxn

// required uint64 request_id = 1;
inline bool CommandAddSubscriptionToTxn::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandAddSubscriptionToTxn::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandAddSubscriptionToTxn::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxn::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxn::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxn.request_id)
  return _internal_request_id();
}
inline void CommandAddSubscriptionToTxn::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_ = value;
}
inline void CommandAddSubscriptionToTxn::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxn.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAddSubscriptionToTxn::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandAddSubscriptionToTxn::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandAddSubscriptionToTxn::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxn::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxn::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxn.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAddSubscriptionToTxn::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  txnid_least_bits_ = value;
}
inline void CommandAddSubscriptionToTxn::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxn.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAddSubscriptionToTxn::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandAddSubscriptionToTxn::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandAddSubscriptionToTxn::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxn::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxn::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxn.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAddSubscriptionToTxn::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_most_bits_ = value;
}
inline void CommandAddSubscriptionToTxn::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxn.txnid_most_bits)
}

// repeated .pulsar.proto.Subscription subscription = 4;
inline int CommandAddSubscriptionToTxn::_internal_subscription_size() const {
  return subscription_.size();
}
inline int CommandAddSubscriptionToTxn::subscription_size() const {
  return _internal_subscription_size();
}
inline void CommandAddSubscriptionToTxn::clear_subscription() {
  subscription_.Clear();
}
inline ::pulsar::proto::Subscription* CommandAddSubscriptionToTxn::mutable_subscription(int index) {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  return subscription_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::Subscription >*
CommandAddSubscriptionToTxn::mutable_subscription() {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  return &subscription_;
}
inline const ::pulsar::proto::Subscription& CommandAddSubscriptionToTxn::_internal_subscription(int index) const {
  return subscription_.Get(index);
}
inline const ::pulsar::proto::Subscription& CommandAddSubscriptionToTxn::subscription(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  return _internal_subscription(index);
}
inline ::pulsar::proto::Subscription* CommandAddSubscriptionToTxn::_internal_add_subscription() {
  return subscription_.Add();
}
inline ::pulsar::proto::Subscription* CommandAddSubscriptionToTxn::add_subscription() {
  ::pulsar::proto::Subscription* _add = _internal_add_subscription();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulsar::proto::Subscription >&
CommandAddSubscriptionToTxn::subscription() const {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  return subscription_;
}

// -------------------------------------------------------------------

// CommandAddSubscriptionToTxnResponse

// required uint64 request_id = 1;
inline bool CommandAddSubscriptionToTxnResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandAddSubscriptionToTxnResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandAddSubscriptionToTxnResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxnResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxnResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.request_id)
  return _internal_request_id();
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandAddSubscriptionToTxnResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAddSubscriptionToTxnResponse::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandAddSubscriptionToTxnResponse::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandAddSubscriptionToTxnResponse::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxnResponse::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxnResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_least_bits_ = value;
}
inline void CommandAddSubscriptionToTxnResponse::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAddSubscriptionToTxnResponse::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandAddSubscriptionToTxnResponse::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandAddSubscriptionToTxnResponse::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxnResponse::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandAddSubscriptionToTxnResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_most_bits_ = value;
}
inline void CommandAddSubscriptionToTxnResponse::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.txnid_most_bits)
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandAddSubscriptionToTxnResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandAddSubscriptionToTxnResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandAddSubscriptionToTxnResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandAddSubscriptionToTxnResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandAddSubscriptionToTxnResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.error)
  return _internal_error();
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
}
inline void CommandAddSubscriptionToTxnResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.error)
}

// optional string message = 5;
inline bool CommandAddSubscriptionToTxnResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandAddSubscriptionToTxnResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandAddSubscriptionToTxnResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAddSubscriptionToTxnResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandAddSubscriptionToTxnResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
}
inline std::string* CommandAddSubscriptionToTxnResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
  return _s;
}
inline const std::string& CommandAddSubscriptionToTxnResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandAddSubscriptionToTxnResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandAddSubscriptionToTxnResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandAddSubscriptionToTxnResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
}

// -------------------------------------------------------------------

// CommandEndTxn

// required uint64 request_id = 1;
inline bool CommandEndTxn::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandEndTxn::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandEndTxn::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxn::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxn::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxn.request_id)
  return _internal_request_id();
}
inline void CommandEndTxn::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_ = value;
}
inline void CommandEndTxn::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxn.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxn::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandEndTxn::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandEndTxn::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxn::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxn::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxn.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxn::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  txnid_least_bits_ = value;
}
inline void CommandEndTxn::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxn.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxn::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandEndTxn::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandEndTxn::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxn::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxn::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxn.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxn::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_most_bits_ = value;
}
inline void CommandEndTxn::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxn.txnid_most_bits)
}

// optional .pulsar.proto.TxnAction txn_action = 4;
inline bool CommandEndTxn::_internal_has_txn_action() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandEndTxn::has_txn_action() const {
  return _internal_has_txn_action();
}
inline void CommandEndTxn::clear_txn_action() {
  txn_action_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::TxnAction CommandEndTxn::_internal_txn_action() const {
  return static_cast< ::pulsar::proto::TxnAction >(txn_action_);
}
inline ::pulsar::proto::TxnAction CommandEndTxn::txn_action() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxn.txn_action)
  return _internal_txn_action();
}
inline void CommandEndTxn::_internal_set_txn_action(::pulsar::proto::TxnAction value) {
  assert(::pulsar::proto::TxnAction_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  txn_action_ = value;
}
inline void CommandEndTxn::set_txn_action(::pulsar::proto::TxnAction value) {
  _internal_set_txn_action(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxn.txn_action)
}

// -------------------------------------------------------------------

// CommandEndTxnResponse

// required uint64 request_id = 1;
inline bool CommandEndTxnResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandEndTxnResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandEndTxnResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandEndTxnResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnResponse::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandEndTxnResponse::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandEndTxnResponse::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnResponse::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnResponse::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_least_bits_ = value;
}
inline void CommandEndTxnResponse::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnResponse::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandEndTxnResponse::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandEndTxnResponse::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnResponse::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnResponse::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_most_bits_ = value;
}
inline void CommandEndTxnResponse::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.txnid_most_bits)
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandEndTxnResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandEndTxnResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandEndTxnResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandEndTxnResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandEndTxnResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.error)
  return _internal_error();
}
inline void CommandEndTxnResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
}
inline void CommandEndTxnResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.error)
}

// optional string message = 5;
inline bool CommandEndTxnResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandEndTxnResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandEndTxnResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandEndTxnResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandEndTxnResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.message)
}
inline std::string* CommandEndTxnResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnResponse.message)
  return _s;
}
inline const std::string& CommandEndTxnResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandEndTxnResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandEndTxnResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandEndTxnResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandEndTxnResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnResponse.message)
}

// -------------------------------------------------------------------

// CommandEndTxnOnPartition

// required uint64 request_id = 1;
inline bool CommandEndTxnOnPartition::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartition::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandEndTxnOnPartition::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartition::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartition::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnOnPartition::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandEndTxnOnPartition::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnOnPartition::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartition::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandEndTxnOnPartition::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartition::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartition::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnOnPartition::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_least_bits_ = value;
}
inline void CommandEndTxnOnPartition::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnOnPartition::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartition::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandEndTxnOnPartition::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartition::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartition::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnOnPartition::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_most_bits_ = value;
}
inline void CommandEndTxnOnPartition::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.txnid_most_bits)
}

// optional string topic = 4;
inline bool CommandEndTxnOnPartition::_internal_has_topic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartition::has_topic() const {
  return _internal_has_topic();
}
inline void CommandEndTxnOnPartition::clear_topic() {
  topic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandEndTxnOnPartition::topic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandEndTxnOnPartition::set_topic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.topic)
}
inline std::string* CommandEndTxnOnPartition::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnOnPartition.topic)
  return _s;
}
inline const std::string& CommandEndTxnOnPartition::_internal_topic() const {
  return topic_.Get();
}
inline void CommandEndTxnOnPartition::_internal_set_topic(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandEndTxnOnPartition::_internal_mutable_topic() {
  _has_bits_[0] |= 0x00000001u;
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandEndTxnOnPartition::release_topic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnOnPartition.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return topic_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandEndTxnOnPartition::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnOnPartition.topic)
}

// optional .pulsar.proto.TxnAction txn_action = 5;
inline bool CommandEndTxnOnPartition::_internal_has_txn_action() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartition::has_txn_action() const {
  return _internal_has_txn_action();
}
inline void CommandEndTxnOnPartition::clear_txn_action() {
  txn_action_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::pulsar::proto::TxnAction CommandEndTxnOnPartition::_internal_txn_action() const {
  return static_cast< ::pulsar::proto::TxnAction >(txn_action_);
}
inline ::pulsar::proto::TxnAction CommandEndTxnOnPartition::txn_action() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.txn_action)
  return _internal_txn_action();
}
inline void CommandEndTxnOnPartition::_internal_set_txn_action(::pulsar::proto::TxnAction value) {
  assert(::pulsar::proto::TxnAction_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  txn_action_ = value;
}
inline void CommandEndTxnOnPartition::set_txn_action(::pulsar::proto::TxnAction value) {
  _internal_set_txn_action(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.txn_action)
}

// optional uint64 txnid_least_bits_of_low_watermark = 6;
inline bool CommandEndTxnOnPartition::_internal_has_txnid_least_bits_of_low_watermark() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartition::has_txnid_least_bits_of_low_watermark() const {
  return _internal_has_txnid_least_bits_of_low_watermark();
}
inline void CommandEndTxnOnPartition::clear_txnid_least_bits_of_low_watermark() {
  txnid_least_bits_of_low_watermark_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartition::_internal_txnid_least_bits_of_low_watermark() const {
  return txnid_least_bits_of_low_watermark_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartition::txnid_least_bits_of_low_watermark() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.txnid_least_bits_of_low_watermark)
  return _internal_txnid_least_bits_of_low_watermark();
}
inline void CommandEndTxnOnPartition::_internal_set_txnid_least_bits_of_low_watermark(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  txnid_least_bits_of_low_watermark_ = value;
}
inline void CommandEndTxnOnPartition::set_txnid_least_bits_of_low_watermark(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits_of_low_watermark(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.txnid_least_bits_of_low_watermark)
}

// -------------------------------------------------------------------

// CommandEndTxnOnPartitionResponse

// required uint64 request_id = 1;
inline bool CommandEndTxnOnPartitionResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartitionResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandEndTxnOnPartitionResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartitionResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartitionResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandEndTxnOnPartitionResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnOnPartitionResponse::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartitionResponse::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandEndTxnOnPartitionResponse::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartitionResponse::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartitionResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_least_bits_ = value;
}
inline void CommandEndTxnOnPartitionResponse::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnOnPartitionResponse::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartitionResponse::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandEndTxnOnPartitionResponse::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartitionResponse::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnPartitionResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_most_bits_ = value;
}
inline void CommandEndTxnOnPartitionResponse::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.txnid_most_bits)
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandEndTxnOnPartitionResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartitionResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandEndTxnOnPartitionResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandEndTxnOnPartitionResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandEndTxnOnPartitionResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.error)
  return _internal_error();
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
}
inline void CommandEndTxnOnPartitionResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.error)
}

// optional string message = 5;
inline bool CommandEndTxnOnPartitionResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandEndTxnOnPartitionResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandEndTxnOnPartitionResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandEndTxnOnPartitionResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandEndTxnOnPartitionResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
}
inline std::string* CommandEndTxnOnPartitionResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
  return _s;
}
inline const std::string& CommandEndTxnOnPartitionResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandEndTxnOnPartitionResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandEndTxnOnPartitionResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandEndTxnOnPartitionResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
}

// -------------------------------------------------------------------

// CommandEndTxnOnSubscription

// required uint64 request_id = 1;
inline bool CommandEndTxnOnSubscription::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscription::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandEndTxnOnSubscription::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscription::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscription::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnOnSubscription::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandEndTxnOnSubscription::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnOnSubscription::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscription::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandEndTxnOnSubscription::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscription::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscription::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnOnSubscription::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_least_bits_ = value;
}
inline void CommandEndTxnOnSubscription::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnOnSubscription::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscription::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandEndTxnOnSubscription::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscription::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscription::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnOnSubscription::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_most_bits_ = value;
}
inline void CommandEndTxnOnSubscription::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.txnid_most_bits)
}

// optional .pulsar.proto.Subscription subscription = 4;
inline bool CommandEndTxnOnSubscription::_internal_has_subscription() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || subscription_ != nullptr);
  return value;
}
inline bool CommandEndTxnOnSubscription::has_subscription() const {
  return _internal_has_subscription();
}
inline void CommandEndTxnOnSubscription::clear_subscription() {
  if (subscription_ != nullptr) subscription_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::Subscription& CommandEndTxnOnSubscription::_internal_subscription() const {
  const ::pulsar::proto::Subscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Subscription&>(
      ::pulsar::proto::_Subscription_default_instance_);
}
inline const ::pulsar::proto::Subscription& CommandEndTxnOnSubscription::subscription() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.subscription)
  return _internal_subscription();
}
inline void CommandEndTxnOnSubscription::unsafe_arena_set_allocated_subscription(
    ::pulsar::proto::Subscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandEndTxnOnSubscription.subscription)
}
inline ::pulsar::proto::Subscription* CommandEndTxnOnSubscription::release_subscription() {
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::Subscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::Subscription* CommandEndTxnOnSubscription::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnOnSubscription.subscription)
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::Subscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Subscription* CommandEndTxnOnSubscription::_internal_mutable_subscription() {
  _has_bits_[0] |= 0x00000001u;
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Subscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::pulsar::proto::Subscription* CommandEndTxnOnSubscription::mutable_subscription() {
  ::pulsar::proto::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnOnSubscription.subscription)
  return _msg;
}
inline void CommandEndTxnOnSubscription::set_allocated_subscription(::pulsar::proto::Subscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::Subscription>::GetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnOnSubscription.subscription)
}

// optional .pulsar.proto.TxnAction txn_action = 5;
inline bool CommandEndTxnOnSubscription::_internal_has_txn_action() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscription::has_txn_action() const {
  return _internal_has_txn_action();
}
inline void CommandEndTxnOnSubscription::clear_txn_action() {
  txn_action_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::pulsar::proto::TxnAction CommandEndTxnOnSubscription::_internal_txn_action() const {
  return static_cast< ::pulsar::proto::TxnAction >(txn_action_);
}
inline ::pulsar::proto::TxnAction CommandEndTxnOnSubscription::txn_action() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.txn_action)
  return _internal_txn_action();
}
inline void CommandEndTxnOnSubscription::_internal_set_txn_action(::pulsar::proto::TxnAction value) {
  assert(::pulsar::proto::TxnAction_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  txn_action_ = value;
}
inline void CommandEndTxnOnSubscription::set_txn_action(::pulsar::proto::TxnAction value) {
  _internal_set_txn_action(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.txn_action)
}

// optional uint64 txnid_least_bits_of_low_watermark = 6;
inline bool CommandEndTxnOnSubscription::_internal_has_txnid_least_bits_of_low_watermark() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscription::has_txnid_least_bits_of_low_watermark() const {
  return _internal_has_txnid_least_bits_of_low_watermark();
}
inline void CommandEndTxnOnSubscription::clear_txnid_least_bits_of_low_watermark() {
  txnid_least_bits_of_low_watermark_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscription::_internal_txnid_least_bits_of_low_watermark() const {
  return txnid_least_bits_of_low_watermark_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscription::txnid_least_bits_of_low_watermark() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.txnid_least_bits_of_low_watermark)
  return _internal_txnid_least_bits_of_low_watermark();
}
inline void CommandEndTxnOnSubscription::_internal_set_txnid_least_bits_of_low_watermark(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  txnid_least_bits_of_low_watermark_ = value;
}
inline void CommandEndTxnOnSubscription::set_txnid_least_bits_of_low_watermark(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits_of_low_watermark(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.txnid_least_bits_of_low_watermark)
}

// -------------------------------------------------------------------

// CommandEndTxnOnSubscriptionResponse

// required uint64 request_id = 1;
inline bool CommandEndTxnOnSubscriptionResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscriptionResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CommandEndTxnOnSubscriptionResponse::clear_request_id() {
  request_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscriptionResponse::_internal_request_id() const {
  return request_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscriptionResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CommandEndTxnOnSubscriptionResponse::set_request_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.request_id)
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnOnSubscriptionResponse::_internal_has_txnid_least_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscriptionResponse::has_txnid_least_bits() const {
  return _internal_has_txnid_least_bits();
}
inline void CommandEndTxnOnSubscriptionResponse::clear_txnid_least_bits() {
  txnid_least_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscriptionResponse::_internal_txnid_least_bits() const {
  return txnid_least_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscriptionResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  txnid_least_bits_ = value;
}
inline void CommandEndTxnOnSubscriptionResponse::set_txnid_least_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.txnid_least_bits)
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnOnSubscriptionResponse::_internal_has_txnid_most_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscriptionResponse::has_txnid_most_bits() const {
  return _internal_has_txnid_most_bits();
}
inline void CommandEndTxnOnSubscriptionResponse::clear_txnid_most_bits() {
  txnid_most_bits_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscriptionResponse::_internal_txnid_most_bits() const {
  return txnid_most_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CommandEndTxnOnSubscriptionResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  txnid_most_bits_ = value;
}
inline void CommandEndTxnOnSubscriptionResponse::set_txnid_most_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.txnid_most_bits)
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandEndTxnOnSubscriptionResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscriptionResponse::has_error() const {
  return _internal_has_error();
}
inline void CommandEndTxnOnSubscriptionResponse::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandEndTxnOnSubscriptionResponse::_internal_error() const {
  return static_cast< ::pulsar::proto::ServerError >(error_);
}
inline ::pulsar::proto::ServerError CommandEndTxnOnSubscriptionResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.error)
  return _internal_error();
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  assert(::pulsar::proto::ServerError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
}
inline void CommandEndTxnOnSubscriptionResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.error)
}

// optional string message = 5;
inline bool CommandEndTxnOnSubscriptionResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandEndTxnOnSubscriptionResponse::has_message() const {
  return _internal_has_message();
}
inline void CommandEndTxnOnSubscriptionResponse::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandEndTxnOnSubscriptionResponse::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommandEndTxnOnSubscriptionResponse::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
}
inline std::string* CommandEndTxnOnSubscriptionResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
  return _s;
}
inline const std::string& CommandEndTxnOnSubscriptionResponse::_internal_message() const {
  return message_.Get();
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommandEndTxnOnSubscriptionResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommandEndTxnOnSubscriptionResponse::release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommandEndTxnOnSubscriptionResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
}

// -------------------------------------------------------------------

// BaseCommand

// required .pulsar.proto.BaseCommand.Type type = 1;
inline bool BaseCommand::_internal_has_type() const {
  bool value = (_has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline bool BaseCommand::has_type() const {
  return _internal_has_type();
}
inline void BaseCommand::clear_type() {
  type_ = 2;
  _has_bits_[1] &= ~0x04000000u;
}
inline ::pulsar::proto::BaseCommand_Type BaseCommand::_internal_type() const {
  return static_cast< ::pulsar::proto::BaseCommand_Type >(type_);
}
inline ::pulsar::proto::BaseCommand_Type BaseCommand::type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.type)
  return _internal_type();
}
inline void BaseCommand::_internal_set_type(::pulsar::proto::BaseCommand_Type value) {
  assert(::pulsar::proto::BaseCommand_Type_IsValid(value));
  _has_bits_[1] |= 0x04000000u;
  type_ = value;
}
inline void BaseCommand::set_type(::pulsar::proto::BaseCommand_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.BaseCommand.type)
}

// optional .pulsar.proto.CommandConnect connect = 2;
inline bool BaseCommand::_internal_has_connect() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || connect_ != nullptr);
  return value;
}
inline bool BaseCommand::has_connect() const {
  return _internal_has_connect();
}
inline void BaseCommand::clear_connect() {
  if (connect_ != nullptr) connect_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::CommandConnect& BaseCommand::_internal_connect() const {
  const ::pulsar::proto::CommandConnect* p = connect_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandConnect&>(
      ::pulsar::proto::_CommandConnect_default_instance_);
}
inline const ::pulsar::proto::CommandConnect& BaseCommand::connect() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.connect)
  return _internal_connect();
}
inline void BaseCommand::unsafe_arena_set_allocated_connect(
    ::pulsar::proto::CommandConnect* connect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connect_);
  }
  connect_ = connect;
  if (connect) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.connect)
}
inline ::pulsar::proto::CommandConnect* BaseCommand::release_connect() {
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::CommandConnect* temp = connect_;
  connect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandConnect* BaseCommand::unsafe_arena_release_connect() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.connect)
  _has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::CommandConnect* temp = connect_;
  connect_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandConnect* BaseCommand::_internal_mutable_connect() {
  _has_bits_[0] |= 0x00000001u;
  if (connect_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandConnect>(GetArenaForAllocation());
    connect_ = p;
  }
  return connect_;
}
inline ::pulsar::proto::CommandConnect* BaseCommand::mutable_connect() {
  ::pulsar::proto::CommandConnect* _msg = _internal_mutable_connect();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.connect)
  return _msg;
}
inline void BaseCommand::set_allocated_connect(::pulsar::proto::CommandConnect* connect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete connect_;
  }
  if (connect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandConnect>::GetOwningArena(connect);
    if (message_arena != submessage_arena) {
      connect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connect, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  connect_ = connect;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.connect)
}

// optional .pulsar.proto.CommandConnected connected = 3;
inline bool BaseCommand::_internal_has_connected() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || connected_ != nullptr);
  return value;
}
inline bool BaseCommand::has_connected() const {
  return _internal_has_connected();
}
inline void BaseCommand::clear_connected() {
  if (connected_ != nullptr) connected_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::CommandConnected& BaseCommand::_internal_connected() const {
  const ::pulsar::proto::CommandConnected* p = connected_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandConnected&>(
      ::pulsar::proto::_CommandConnected_default_instance_);
}
inline const ::pulsar::proto::CommandConnected& BaseCommand::connected() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.connected)
  return _internal_connected();
}
inline void BaseCommand::unsafe_arena_set_allocated_connected(
    ::pulsar::proto::CommandConnected* connected) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_);
  }
  connected_ = connected;
  if (connected) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.connected)
}
inline ::pulsar::proto::CommandConnected* BaseCommand::release_connected() {
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::CommandConnected* temp = connected_;
  connected_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandConnected* BaseCommand::unsafe_arena_release_connected() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.connected)
  _has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::CommandConnected* temp = connected_;
  connected_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandConnected* BaseCommand::_internal_mutable_connected() {
  _has_bits_[0] |= 0x00000002u;
  if (connected_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandConnected>(GetArenaForAllocation());
    connected_ = p;
  }
  return connected_;
}
inline ::pulsar::proto::CommandConnected* BaseCommand::mutable_connected() {
  ::pulsar::proto::CommandConnected* _msg = _internal_mutable_connected();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.connected)
  return _msg;
}
inline void BaseCommand::set_allocated_connected(::pulsar::proto::CommandConnected* connected) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete connected_;
  }
  if (connected) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandConnected>::GetOwningArena(connected);
    if (message_arena != submessage_arena) {
      connected = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connected, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  connected_ = connected;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.connected)
}

// optional .pulsar.proto.CommandSubscribe subscribe = 4;
inline bool BaseCommand::_internal_has_subscribe() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || subscribe_ != nullptr);
  return value;
}
inline bool BaseCommand::has_subscribe() const {
  return _internal_has_subscribe();
}
inline void BaseCommand::clear_subscribe() {
  if (subscribe_ != nullptr) subscribe_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pulsar::proto::CommandSubscribe& BaseCommand::_internal_subscribe() const {
  const ::pulsar::proto::CommandSubscribe* p = subscribe_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSubscribe&>(
      ::pulsar::proto::_CommandSubscribe_default_instance_);
}
inline const ::pulsar::proto::CommandSubscribe& BaseCommand::subscribe() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.subscribe)
  return _internal_subscribe();
}
inline void BaseCommand::unsafe_arena_set_allocated_subscribe(
    ::pulsar::proto::CommandSubscribe* subscribe) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscribe_);
  }
  subscribe_ = subscribe;
  if (subscribe) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.subscribe)
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::release_subscribe() {
  _has_bits_[0] &= ~0x00000004u;
  ::pulsar::proto::CommandSubscribe* temp = subscribe_;
  subscribe_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::unsafe_arena_release_subscribe() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.subscribe)
  _has_bits_[0] &= ~0x00000004u;
  ::pulsar::proto::CommandSubscribe* temp = subscribe_;
  subscribe_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::_internal_mutable_subscribe() {
  _has_bits_[0] |= 0x00000004u;
  if (subscribe_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSubscribe>(GetArenaForAllocation());
    subscribe_ = p;
  }
  return subscribe_;
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::mutable_subscribe() {
  ::pulsar::proto::CommandSubscribe* _msg = _internal_mutable_subscribe();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.subscribe)
  return _msg;
}
inline void BaseCommand::set_allocated_subscribe(::pulsar::proto::CommandSubscribe* subscribe) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscribe_;
  }
  if (subscribe) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandSubscribe>::GetOwningArena(subscribe);
    if (message_arena != submessage_arena) {
      subscribe = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscribe, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  subscribe_ = subscribe;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.subscribe)
}

// optional .pulsar.proto.CommandProducer producer = 5;
inline bool BaseCommand::_internal_has_producer() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || producer_ != nullptr);
  return value;
}
inline bool BaseCommand::has_producer() const {
  return _internal_has_producer();
}
inline void BaseCommand::clear_producer() {
  if (producer_ != nullptr) producer_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pulsar::proto::CommandProducer& BaseCommand::_internal_producer() const {
  const ::pulsar::proto::CommandProducer* p = producer_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandProducer&>(
      ::pulsar::proto::_CommandProducer_default_instance_);
}
inline const ::pulsar::proto::CommandProducer& BaseCommand::producer() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.producer)
  return _internal_producer();
}
inline void BaseCommand::unsafe_arena_set_allocated_producer(
    ::pulsar::proto::CommandProducer* producer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(producer_);
  }
  producer_ = producer;
  if (producer) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.producer)
}
inline ::pulsar::proto::CommandProducer* BaseCommand::release_producer() {
  _has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::CommandProducer* temp = producer_;
  producer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandProducer* BaseCommand::unsafe_arena_release_producer() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.producer)
  _has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::CommandProducer* temp = producer_;
  producer_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandProducer* BaseCommand::_internal_mutable_producer() {
  _has_bits_[0] |= 0x00000008u;
  if (producer_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandProducer>(GetArenaForAllocation());
    producer_ = p;
  }
  return producer_;
}
inline ::pulsar::proto::CommandProducer* BaseCommand::mutable_producer() {
  ::pulsar::proto::CommandProducer* _msg = _internal_mutable_producer();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.producer)
  return _msg;
}
inline void BaseCommand::set_allocated_producer(::pulsar::proto::CommandProducer* producer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete producer_;
  }
  if (producer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandProducer>::GetOwningArena(producer);
    if (message_arena != submessage_arena) {
      producer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, producer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  producer_ = producer;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.producer)
}

// optional .pulsar.proto.CommandSend send = 6;
inline bool BaseCommand::_internal_has_send() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || send_ != nullptr);
  return value;
}
inline bool BaseCommand::has_send() const {
  return _internal_has_send();
}
inline void BaseCommand::clear_send() {
  if (send_ != nullptr) send_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::pulsar::proto::CommandSend& BaseCommand::_internal_send() const {
  const ::pulsar::proto::CommandSend* p = send_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSend&>(
      ::pulsar::proto::_CommandSend_default_instance_);
}
inline const ::pulsar::proto::CommandSend& BaseCommand::send() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.send)
  return _internal_send();
}
inline void BaseCommand::unsafe_arena_set_allocated_send(
    ::pulsar::proto::CommandSend* send) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_);
  }
  send_ = send;
  if (send) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.send)
}
inline ::pulsar::proto::CommandSend* BaseCommand::release_send() {
  _has_bits_[0] &= ~0x00000010u;
  ::pulsar::proto::CommandSend* temp = send_;
  send_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandSend* BaseCommand::unsafe_arena_release_send() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.send)
  _has_bits_[0] &= ~0x00000010u;
  ::pulsar::proto::CommandSend* temp = send_;
  send_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSend* BaseCommand::_internal_mutable_send() {
  _has_bits_[0] |= 0x00000010u;
  if (send_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSend>(GetArenaForAllocation());
    send_ = p;
  }
  return send_;
}
inline ::pulsar::proto::CommandSend* BaseCommand::mutable_send() {
  ::pulsar::proto::CommandSend* _msg = _internal_mutable_send();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.send)
  return _msg;
}
inline void BaseCommand::set_allocated_send(::pulsar::proto::CommandSend* send) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete send_;
  }
  if (send) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandSend>::GetOwningArena(send);
    if (message_arena != submessage_arena) {
      send = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  send_ = send;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.send)
}

// optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
inline bool BaseCommand::_internal_has_send_receipt() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || send_receipt_ != nullptr);
  return value;
}
inline bool BaseCommand::has_send_receipt() const {
  return _internal_has_send_receipt();
}
inline void BaseCommand::clear_send_receipt() {
  if (send_receipt_ != nullptr) send_receipt_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::pulsar::proto::CommandSendReceipt& BaseCommand::_internal_send_receipt() const {
  const ::pulsar::proto::CommandSendReceipt* p = send_receipt_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSendReceipt&>(
      ::pulsar::proto::_CommandSendReceipt_default_instance_);
}
inline const ::pulsar::proto::CommandSendReceipt& BaseCommand::send_receipt() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.send_receipt)
  return _internal_send_receipt();
}
inline void BaseCommand::unsafe_arena_set_allocated_send_receipt(
    ::pulsar::proto::CommandSendReceipt* send_receipt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_receipt_);
  }
  send_receipt_ = send_receipt;
  if (send_receipt) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.send_receipt)
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::release_send_receipt() {
  _has_bits_[0] &= ~0x00000020u;
  ::pulsar::proto::CommandSendReceipt* temp = send_receipt_;
  send_receipt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::unsafe_arena_release_send_receipt() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.send_receipt)
  _has_bits_[0] &= ~0x00000020u;
  ::pulsar::proto::CommandSendReceipt* temp = send_receipt_;
  send_receipt_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::_internal_mutable_send_receipt() {
  _has_bits_[0] |= 0x00000020u;
  if (send_receipt_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSendReceipt>(GetArenaForAllocation());
    send_receipt_ = p;
  }
  return send_receipt_;
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::mutable_send_receipt() {
  ::pulsar::proto::CommandSendReceipt* _msg = _internal_mutable_send_receipt();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.send_receipt)
  return _msg;
}
inline void BaseCommand::set_allocated_send_receipt(::pulsar::proto::CommandSendReceipt* send_receipt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete send_receipt_;
  }
  if (send_receipt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandSendReceipt>::GetOwningArena(send_receipt);
    if (message_arena != submessage_arena) {
      send_receipt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_receipt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  send_receipt_ = send_receipt;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.send_receipt)
}

// optional .pulsar.proto.CommandSendError send_error = 8;
inline bool BaseCommand::_internal_has_send_error() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || send_error_ != nullptr);
  return value;
}
inline bool BaseCommand::has_send_error() const {
  return _internal_has_send_error();
}
inline void BaseCommand::clear_send_error() {
  if (send_error_ != nullptr) send_error_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::pulsar::proto::CommandSendError& BaseCommand::_internal_send_error() const {
  const ::pulsar::proto::CommandSendError* p = send_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSendError&>(
      ::pulsar::proto::_CommandSendError_default_instance_);
}
inline const ::pulsar::proto::CommandSendError& BaseCommand::send_error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.send_error)
  return _internal_send_error();
}
inline void BaseCommand::unsafe_arena_set_allocated_send_error(
    ::pulsar::proto::CommandSendError* send_error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_error_);
  }
  send_error_ = send_error;
  if (send_error) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.send_error)
}
inline ::pulsar::proto::CommandSendError* BaseCommand::release_send_error() {
  _has_bits_[0] &= ~0x00000040u;
  ::pulsar::proto::CommandSendError* temp = send_error_;
  send_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandSendError* BaseCommand::unsafe_arena_release_send_error() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.send_error)
  _has_bits_[0] &= ~0x00000040u;
  ::pulsar::proto::CommandSendError* temp = send_error_;
  send_error_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSendError* BaseCommand::_internal_mutable_send_error() {
  _has_bits_[0] |= 0x00000040u;
  if (send_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSendError>(GetArenaForAllocation());
    send_error_ = p;
  }
  return send_error_;
}
inline ::pulsar::proto::CommandSendError* BaseCommand::mutable_send_error() {
  ::pulsar::proto::CommandSendError* _msg = _internal_mutable_send_error();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.send_error)
  return _msg;
}
inline void BaseCommand::set_allocated_send_error(::pulsar::proto::CommandSendError* send_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete send_error_;
  }
  if (send_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandSendError>::GetOwningArena(send_error);
    if (message_arena != submessage_arena) {
      send_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  send_error_ = send_error;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.send_error)
}

// optional .pulsar.proto.CommandMessage message = 9;
inline bool BaseCommand::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || message_ != nullptr);
  return value;
}
inline bool BaseCommand::has_message() const {
  return _internal_has_message();
}
inline void BaseCommand::clear_message() {
  if (message_ != nullptr) message_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::pulsar::proto::CommandMessage& BaseCommand::_internal_message() const {
  const ::pulsar::proto::CommandMessage* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandMessage&>(
      ::pulsar::proto::_CommandMessage_default_instance_);
}
inline const ::pulsar::proto::CommandMessage& BaseCommand::message() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.message)
  return _internal_message();
}
inline void BaseCommand::unsafe_arena_set_allocated_message(
    ::pulsar::proto::CommandMessage* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.message)
}
inline ::pulsar::proto::CommandMessage* BaseCommand::release_message() {
  _has_bits_[0] &= ~0x00000080u;
  ::pulsar::proto::CommandMessage* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandMessage* BaseCommand::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.message)
  _has_bits_[0] &= ~0x00000080u;
  ::pulsar::proto::CommandMessage* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandMessage* BaseCommand::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000080u;
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandMessage>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::pulsar::proto::CommandMessage* BaseCommand::mutable_message() {
  ::pulsar::proto::CommandMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.message)
  return _msg;
}
inline void BaseCommand::set_allocated_message(::pulsar::proto::CommandMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandMessage>::GetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.message)
}

// optional .pulsar.proto.CommandAck ack = 10;
inline bool BaseCommand::_internal_has_ack() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || ack_ != nullptr);
  return value;
}
inline bool BaseCommand::has_ack() const {
  return _internal_has_ack();
}
inline void BaseCommand::clear_ack() {
  if (ack_ != nullptr) ack_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::pulsar::proto::CommandAck& BaseCommand::_internal_ack() const {
  const ::pulsar::proto::CommandAck* p = ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAck&>(
      ::pulsar::proto::_CommandAck_default_instance_);
}
inline const ::pulsar::proto::CommandAck& BaseCommand::ack() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.ack)
  return _internal_ack();
}
inline void BaseCommand::unsafe_arena_set_allocated_ack(
    ::pulsar::proto::CommandAck* ack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ack_);
  }
  ack_ = ack;
  if (ack) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.ack)
}
inline ::pulsar::proto::CommandAck* BaseCommand::release_ack() {
  _has_bits_[0] &= ~0x00000100u;
  ::pulsar::proto::CommandAck* temp = ack_;
  ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandAck* BaseCommand::unsafe_arena_release_ack() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.ack)
  _has_bits_[0] &= ~0x00000100u;
  ::pulsar::proto::CommandAck* temp = ack_;
  ack_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAck* BaseCommand::_internal_mutable_ack() {
  _has_bits_[0] |= 0x00000100u;
  if (ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAck>(GetArenaForAllocation());
    ack_ = p;
  }
  return ack_;
}
inline ::pulsar::proto::CommandAck* BaseCommand::mutable_ack() {
  ::pulsar::proto::CommandAck* _msg = _internal_mutable_ack();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.ack)
  return _msg;
}
inline void BaseCommand::set_allocated_ack(::pulsar::proto::CommandAck* ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ack_;
  }
  if (ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandAck>::GetOwningArena(ack);
    if (message_arena != submessage_arena) {
      ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ack, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  ack_ = ack;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.ack)
}

// optional .pulsar.proto.CommandFlow flow = 11;
inline bool BaseCommand::_internal_has_flow() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || flow_ != nullptr);
  return value;
}
inline bool BaseCommand::has_flow() const {
  return _internal_has_flow();
}
inline void BaseCommand::clear_flow() {
  if (flow_ != nullptr) flow_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::pulsar::proto::CommandFlow& BaseCommand::_internal_flow() const {
  const ::pulsar::proto::CommandFlow* p = flow_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandFlow&>(
      ::pulsar::proto::_CommandFlow_default_instance_);
}
inline const ::pulsar::proto::CommandFlow& BaseCommand::flow() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.flow)
  return _internal_flow();
}
inline void BaseCommand::unsafe_arena_set_allocated_flow(
    ::pulsar::proto::CommandFlow* flow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_);
  }
  flow_ = flow;
  if (flow) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.flow)
}
inline ::pulsar::proto::CommandFlow* BaseCommand::release_flow() {
  _has_bits_[0] &= ~0x00000200u;
  ::pulsar::proto::CommandFlow* temp = flow_;
  flow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandFlow* BaseCommand::unsafe_arena_release_flow() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.flow)
  _has_bits_[0] &= ~0x00000200u;
  ::pulsar::proto::CommandFlow* temp = flow_;
  flow_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandFlow* BaseCommand::_internal_mutable_flow() {
  _has_bits_[0] |= 0x00000200u;
  if (flow_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandFlow>(GetArenaForAllocation());
    flow_ = p;
  }
  return flow_;
}
inline ::pulsar::proto::CommandFlow* BaseCommand::mutable_flow() {
  ::pulsar::proto::CommandFlow* _msg = _internal_mutable_flow();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.flow)
  return _msg;
}
inline void BaseCommand::set_allocated_flow(::pulsar::proto::CommandFlow* flow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete flow_;
  }
  if (flow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandFlow>::GetOwningArena(flow);
    if (message_arena != submessage_arena) {
      flow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  flow_ = flow;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.flow)
}

// optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
inline bool BaseCommand::_internal_has_unsubscribe() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || unsubscribe_ != nullptr);
  return value;
}
inline bool BaseCommand::has_unsubscribe() const {
  return _internal_has_unsubscribe();
}
inline void BaseCommand::clear_unsubscribe() {
  if (unsubscribe_ != nullptr) unsubscribe_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::pulsar::proto::CommandUnsubscribe& BaseCommand::_internal_unsubscribe() const {
  const ::pulsar::proto::CommandUnsubscribe* p = unsubscribe_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandUnsubscribe&>(
      ::pulsar::proto::_CommandUnsubscribe_default_instance_);
}
inline const ::pulsar::proto::CommandUnsubscribe& BaseCommand::unsubscribe() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.unsubscribe)
  return _internal_unsubscribe();
}
inline void BaseCommand::unsafe_arena_set_allocated_unsubscribe(
    ::pulsar::proto::CommandUnsubscribe* unsubscribe) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unsubscribe_);
  }
  unsubscribe_ = unsubscribe;
  if (unsubscribe) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.unsubscribe)
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::release_unsubscribe() {
  _has_bits_[0] &= ~0x00000400u;
  ::pulsar::proto::CommandUnsubscribe* temp = unsubscribe_;
  unsubscribe_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::unsafe_arena_release_unsubscribe() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.unsubscribe)
  _has_bits_[0] &= ~0x00000400u;
  ::pulsar::proto::CommandUnsubscribe* temp = unsubscribe_;
  unsubscribe_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::_internal_mutable_unsubscribe() {
  _has_bits_[0] |= 0x00000400u;
  if (unsubscribe_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandUnsubscribe>(GetArenaForAllocation());
    unsubscribe_ = p;
  }
  return unsubscribe_;
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::mutable_unsubscribe() {
  ::pulsar::proto::CommandUnsubscribe* _msg = _internal_mutable_unsubscribe();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.unsubscribe)
  return _msg;
}
inline void BaseCommand::set_allocated_unsubscribe(::pulsar::proto::CommandUnsubscribe* unsubscribe) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete unsubscribe_;
  }
  if (unsubscribe) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandUnsubscribe>::GetOwningArena(unsubscribe);
    if (message_arena != submessage_arena) {
      unsubscribe = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unsubscribe, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  unsubscribe_ = unsubscribe;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.unsubscribe)
}

// optional .pulsar.proto.CommandSuccess success = 13;
inline bool BaseCommand::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || success_ != nullptr);
  return value;
}
inline bool BaseCommand::has_success() const {
  return _internal_has_success();
}
inline void BaseCommand::clear_success() {
  if (success_ != nullptr) success_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::pulsar::proto::CommandSuccess& BaseCommand::_internal_success() const {
  const ::pulsar::proto::CommandSuccess* p = success_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSuccess&>(
      ::pulsar::proto::_CommandSuccess_default_instance_);
}
inline const ::pulsar::proto::CommandSuccess& BaseCommand::success() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.success)
  return _internal_success();
}
inline void BaseCommand::unsafe_arena_set_allocated_success(
    ::pulsar::proto::CommandSuccess* success) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(success_);
  }
  success_ = success;
  if (success) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.success)
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::release_success() {
  _has_bits_[0] &= ~0x00000800u;
  ::pulsar::proto::CommandSuccess* temp = success_;
  success_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::unsafe_arena_release_success() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.success)
  _has_bits_[0] &= ~0x00000800u;
  ::pulsar::proto::CommandSuccess* temp = success_;
  success_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::_internal_mutable_success() {
  _has_bits_[0] |= 0x00000800u;
  if (success_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSuccess>(GetArenaForAllocation());
    success_ = p;
  }
  return success_;
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::mutable_success() {
  ::pulsar::proto::CommandSuccess* _msg = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.success)
  return _msg;
}
inline void BaseCommand::set_allocated_success(::pulsar::proto::CommandSuccess* success) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete success_;
  }
  if (success) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandSuccess>::GetOwningArena(success);
    if (message_arena != submessage_arena) {
      success = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, success, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  success_ = success;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.success)
}

// optional .pulsar.proto.CommandError error = 14;
inline bool BaseCommand::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || error_ != nullptr);
  return value;
}
inline bool BaseCommand::has_error() const {
  return _internal_has_error();
}
inline void BaseCommand::clear_error() {
  if (error_ != nullptr) error_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::pulsar::proto::CommandError& BaseCommand::_internal_error() const {
  const ::pulsar::proto::CommandError* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandError&>(
      ::pulsar::proto::_CommandError_default_instance_);
}
inline const ::pulsar::proto::CommandError& BaseCommand::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.error)
  return _internal_error();
}
inline void BaseCommand::unsafe_arena_set_allocated_error(
    ::pulsar::proto::CommandError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.error)
}
inline ::pulsar::proto::CommandError* BaseCommand::release_error() {
  _has_bits_[0] &= ~0x00001000u;
  ::pulsar::proto::CommandError* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandError* BaseCommand::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.error)
  _has_bits_[0] &= ~0x00001000u;
  ::pulsar::proto::CommandError* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandError* BaseCommand::_internal_mutable_error() {
  _has_bits_[0] |= 0x00001000u;
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandError>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::pulsar::proto::CommandError* BaseCommand::mutable_error() {
  ::pulsar::proto::CommandError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.error)
  return _msg;
}
inline void BaseCommand::set_allocated_error(::pulsar::proto::CommandError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandError>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.error)
}

// optional .pulsar.proto.CommandCloseProducer close_producer = 15;
inline bool BaseCommand::_internal_has_close_producer() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || close_producer_ != nullptr);
  return value;
}
inline bool BaseCommand::has_close_producer() const {
  return _internal_has_close_producer();
}
inline void BaseCommand::clear_close_producer() {
  if (close_producer_ != nullptr) close_producer_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::pulsar::proto::CommandCloseProducer& BaseCommand::_internal_close_producer() const {
  const ::pulsar::proto::CommandCloseProducer* p = close_producer_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandCloseProducer&>(
      ::pulsar::proto::_CommandCloseProducer_default_instance_);
}
inline const ::pulsar::proto::CommandCloseProducer& BaseCommand::close_producer() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.close_producer)
  return _internal_close_producer();
}
inline void BaseCommand::unsafe_arena_set_allocated_close_producer(
    ::pulsar::proto::CommandCloseProducer* close_producer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(close_producer_);
  }
  close_producer_ = close_producer;
  if (close_producer) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.close_producer)
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::release_close_producer() {
  _has_bits_[0] &= ~0x00002000u;
  ::pulsar::proto::CommandCloseProducer* temp = close_producer_;
  close_producer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::unsafe_arena_release_close_producer() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.close_producer)
  _has_bits_[0] &= ~0x00002000u;
  ::pulsar::proto::CommandCloseProducer* temp = close_producer_;
  close_producer_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::_internal_mutable_close_producer() {
  _has_bits_[0] |= 0x00002000u;
  if (close_producer_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandCloseProducer>(GetArenaForAllocation());
    close_producer_ = p;
  }
  return close_producer_;
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::mutable_close_producer() {
  ::pulsar::proto::CommandCloseProducer* _msg = _internal_mutable_close_producer();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.close_producer)
  return _msg;
}
inline void BaseCommand::set_allocated_close_producer(::pulsar::proto::CommandCloseProducer* close_producer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete close_producer_;
  }
  if (close_producer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandCloseProducer>::GetOwningArena(close_producer);
    if (message_arena != submessage_arena) {
      close_producer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close_producer, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  close_producer_ = close_producer;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.close_producer)
}

// optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
inline bool BaseCommand::_internal_has_close_consumer() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || close_consumer_ != nullptr);
  return value;
}
inline bool BaseCommand::has_close_consumer() const {
  return _internal_has_close_consumer();
}
inline void BaseCommand::clear_close_consumer() {
  if (close_consumer_ != nullptr) close_consumer_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::pulsar::proto::CommandCloseConsumer& BaseCommand::_internal_close_consumer() const {
  const ::pulsar::proto::CommandCloseConsumer* p = close_consumer_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandCloseConsumer&>(
      ::pulsar::proto::_CommandCloseConsumer_default_instance_);
}
inline const ::pulsar::proto::CommandCloseConsumer& BaseCommand::close_consumer() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.close_consumer)
  return _internal_close_consumer();
}
inline void BaseCommand::unsafe_arena_set_allocated_close_consumer(
    ::pulsar::proto::CommandCloseConsumer* close_consumer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(close_consumer_);
  }
  close_consumer_ = close_consumer;
  if (close_consumer) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.close_consumer)
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::release_close_consumer() {
  _has_bits_[0] &= ~0x00004000u;
  ::pulsar::proto::CommandCloseConsumer* temp = close_consumer_;
  close_consumer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::unsafe_arena_release_close_consumer() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.close_consumer)
  _has_bits_[0] &= ~0x00004000u;
  ::pulsar::proto::CommandCloseConsumer* temp = close_consumer_;
  close_consumer_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::_internal_mutable_close_consumer() {
  _has_bits_[0] |= 0x00004000u;
  if (close_consumer_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandCloseConsumer>(GetArenaForAllocation());
    close_consumer_ = p;
  }
  return close_consumer_;
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::mutable_close_consumer() {
  ::pulsar::proto::CommandCloseConsumer* _msg = _internal_mutable_close_consumer();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.close_consumer)
  return _msg;
}
inline void BaseCommand::set_allocated_close_consumer(::pulsar::proto::CommandCloseConsumer* close_consumer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete close_consumer_;
  }
  if (close_consumer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandCloseConsumer>::GetOwningArena(close_consumer);
    if (message_arena != submessage_arena) {
      close_consumer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close_consumer, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  close_consumer_ = close_consumer;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.close_consumer)
}

// optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
inline bool BaseCommand::_internal_has_producer_success() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || producer_success_ != nullptr);
  return value;
}
inline bool BaseCommand::has_producer_success() const {
  return _internal_has_producer_success();
}
inline void BaseCommand::clear_producer_success() {
  if (producer_success_ != nullptr) producer_success_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::pulsar::proto::CommandProducerSuccess& BaseCommand::_internal_producer_success() const {
  const ::pulsar::proto::CommandProducerSuccess* p = producer_success_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandProducerSuccess&>(
      ::pulsar::proto::_CommandProducerSuccess_default_instance_);
}
inline const ::pulsar::proto::CommandProducerSuccess& BaseCommand::producer_success() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.producer_success)
  return _internal_producer_success();
}
inline void BaseCommand::unsafe_arena_set_allocated_producer_success(
    ::pulsar::proto::CommandProducerSuccess* producer_success) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(producer_success_);
  }
  producer_success_ = producer_success;
  if (producer_success) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.producer_success)
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::release_producer_success() {
  _has_bits_[0] &= ~0x00008000u;
  ::pulsar::proto::CommandProducerSuccess* temp = producer_success_;
  producer_success_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::unsafe_arena_release_producer_success() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.producer_success)
  _has_bits_[0] &= ~0x00008000u;
  ::pulsar::proto::CommandProducerSuccess* temp = producer_success_;
  producer_success_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::_internal_mutable_producer_success() {
  _has_bits_[0] |= 0x00008000u;
  if (producer_success_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandProducerSuccess>(GetArenaForAllocation());
    producer_success_ = p;
  }
  return producer_success_;
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::mutable_producer_success() {
  ::pulsar::proto::CommandProducerSuccess* _msg = _internal_mutable_producer_success();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.producer_success)
  return _msg;
}
inline void BaseCommand::set_allocated_producer_success(::pulsar::proto::CommandProducerSuccess* producer_success) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete producer_success_;
  }
  if (producer_success) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandProducerSuccess>::GetOwningArena(producer_success);
    if (message_arena != submessage_arena) {
      producer_success = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, producer_success, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  producer_success_ = producer_success;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.producer_success)
}

// optional .pulsar.proto.CommandPing ping = 18;
inline bool BaseCommand::_internal_has_ping() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || ping_ != nullptr);
  return value;
}
inline bool BaseCommand::has_ping() const {
  return _internal_has_ping();
}
inline void BaseCommand::clear_ping() {
  if (ping_ != nullptr) ping_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::pulsar::proto::CommandPing& BaseCommand::_internal_ping() const {
  const ::pulsar::proto::CommandPing* p = ping_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandPing&>(
      ::pulsar::proto::_CommandPing_default_instance_);
}
inline const ::pulsar::proto::CommandPing& BaseCommand::ping() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.ping)
  return _internal_ping();
}
inline void BaseCommand::unsafe_arena_set_allocated_ping(
    ::pulsar::proto::CommandPing* ping) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ping_);
  }
  ping_ = ping;
  if (ping) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.ping)
}
inline ::pulsar::proto::CommandPing* BaseCommand::release_ping() {
  _has_bits_[0] &= ~0x00010000u;
  ::pulsar::proto::CommandPing* temp = ping_;
  ping_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandPing* BaseCommand::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.ping)
  _has_bits_[0] &= ~0x00010000u;
  ::pulsar::proto::CommandPing* temp = ping_;
  ping_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandPing* BaseCommand::_internal_mutable_ping() {
  _has_bits_[0] |= 0x00010000u;
  if (ping_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandPing>(GetArenaForAllocation());
    ping_ = p;
  }
  return ping_;
}
inline ::pulsar::proto::CommandPing* BaseCommand::mutable_ping() {
  ::pulsar::proto::CommandPing* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.ping)
  return _msg;
}
inline void BaseCommand::set_allocated_ping(::pulsar::proto::CommandPing* ping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ping_;
  }
  if (ping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandPing>::GetOwningArena(ping);
    if (message_arena != submessage_arena) {
      ping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ping, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  ping_ = ping;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.ping)
}

// optional .pulsar.proto.CommandPong pong = 19;
inline bool BaseCommand::_internal_has_pong() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || pong_ != nullptr);
  return value;
}
inline bool BaseCommand::has_pong() const {
  return _internal_has_pong();
}
inline void BaseCommand::clear_pong() {
  if (pong_ != nullptr) pong_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::pulsar::proto::CommandPong& BaseCommand::_internal_pong() const {
  const ::pulsar::proto::CommandPong* p = pong_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandPong&>(
      ::pulsar::proto::_CommandPong_default_instance_);
}
inline const ::pulsar::proto::CommandPong& BaseCommand::pong() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.pong)
  return _internal_pong();
}
inline void BaseCommand::unsafe_arena_set_allocated_pong(
    ::pulsar::proto::CommandPong* pong) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pong_);
  }
  pong_ = pong;
  if (pong) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.pong)
}
inline ::pulsar::proto::CommandPong* BaseCommand::release_pong() {
  _has_bits_[0] &= ~0x00020000u;
  ::pulsar::proto::CommandPong* temp = pong_;
  pong_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandPong* BaseCommand::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.pong)
  _has_bits_[0] &= ~0x00020000u;
  ::pulsar::proto::CommandPong* temp = pong_;
  pong_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandPong* BaseCommand::_internal_mutable_pong() {
  _has_bits_[0] |= 0x00020000u;
  if (pong_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandPong>(GetArenaForAllocation());
    pong_ = p;
  }
  return pong_;
}
inline ::pulsar::proto::CommandPong* BaseCommand::mutable_pong() {
  ::pulsar::proto::CommandPong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.pong)
  return _msg;
}
inline void BaseCommand::set_allocated_pong(::pulsar::proto::CommandPong* pong) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pong_;
  }
  if (pong) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandPong>::GetOwningArena(pong);
    if (message_arena != submessage_arena) {
      pong = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pong, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  pong_ = pong;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.pong)
}

// optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
inline bool BaseCommand::_internal_has_redeliverunacknowledgedmessages() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || redeliverunacknowledgedmessages_ != nullptr);
  return value;
}
inline bool BaseCommand::has_redeliverunacknowledgedmessages() const {
  return _internal_has_redeliverunacknowledgedmessages();
}
inline void BaseCommand::clear_redeliverunacknowledgedmessages() {
  if (redeliverunacknowledgedmessages_ != nullptr) redeliverunacknowledgedmessages_->Clear();
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& BaseCommand::_internal_redeliverunacknowledgedmessages() const {
  const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* p = redeliverunacknowledgedmessages_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages&>(
      ::pulsar::proto::_CommandRedeliverUnacknowledgedMessages_default_instance_);
}
inline const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& BaseCommand::redeliverunacknowledgedmessages() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
  return _internal_redeliverunacknowledgedmessages();
}
inline void BaseCommand::unsafe_arena_set_allocated_redeliverunacknowledgedmessages(
    ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* redeliverunacknowledgedmessages) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(redeliverunacknowledgedmessages_);
  }
  redeliverunacknowledgedmessages_ = redeliverunacknowledgedmessages;
  if (redeliverunacknowledgedmessages) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::release_redeliverunacknowledgedmessages() {
  _has_bits_[0] &= ~0x00040000u;
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* temp = redeliverunacknowledgedmessages_;
  redeliverunacknowledgedmessages_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::unsafe_arena_release_redeliverunacknowledgedmessages() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
  _has_bits_[0] &= ~0x00040000u;
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* temp = redeliverunacknowledgedmessages_;
  redeliverunacknowledgedmessages_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::_internal_mutable_redeliverunacknowledgedmessages() {
  _has_bits_[0] |= 0x00040000u;
  if (redeliverunacknowledgedmessages_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandRedeliverUnacknowledgedMessages>(GetArenaForAllocation());
    redeliverunacknowledgedmessages_ = p;
  }
  return redeliverunacknowledgedmessages_;
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::mutable_redeliverunacknowledgedmessages() {
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* _msg = _internal_mutable_redeliverunacknowledgedmessages();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
  return _msg;
}
inline void BaseCommand::set_allocated_redeliverunacknowledgedmessages(::pulsar::proto::CommandRedeliverUnacknowledgedMessages* redeliverunacknowledgedmessages) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete redeliverunacknowledgedmessages_;
  }
  if (redeliverunacknowledgedmessages) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandRedeliverUnacknowledgedMessages>::GetOwningArena(redeliverunacknowledgedmessages);
    if (message_arena != submessage_arena) {
      redeliverunacknowledgedmessages = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, redeliverunacknowledgedmessages, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  redeliverunacknowledgedmessages_ = redeliverunacknowledgedmessages;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
}

// optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
inline bool BaseCommand::_internal_has_partitionmetadata() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || partitionmetadata_ != nullptr);
  return value;
}
inline bool BaseCommand::has_partitionmetadata() const {
  return _internal_has_partitionmetadata();
}
inline void BaseCommand::clear_partitionmetadata() {
  if (partitionmetadata_ != nullptr) partitionmetadata_->Clear();
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadata& BaseCommand::_internal_partitionmetadata() const {
  const ::pulsar::proto::CommandPartitionedTopicMetadata* p = partitionmetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandPartitionedTopicMetadata&>(
      ::pulsar::proto::_CommandPartitionedTopicMetadata_default_instance_);
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadata& BaseCommand::partitionmetadata() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.partitionMetadata)
  return _internal_partitionmetadata();
}
inline void BaseCommand::unsafe_arena_set_allocated_partitionmetadata(
    ::pulsar::proto::CommandPartitionedTopicMetadata* partitionmetadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partitionmetadata_);
  }
  partitionmetadata_ = partitionmetadata;
  if (partitionmetadata) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.partitionMetadata)
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::release_partitionmetadata() {
  _has_bits_[0] &= ~0x00080000u;
  ::pulsar::proto::CommandPartitionedTopicMetadata* temp = partitionmetadata_;
  partitionmetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::unsafe_arena_release_partitionmetadata() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.partitionMetadata)
  _has_bits_[0] &= ~0x00080000u;
  ::pulsar::proto::CommandPartitionedTopicMetadata* temp = partitionmetadata_;
  partitionmetadata_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::_internal_mutable_partitionmetadata() {
  _has_bits_[0] |= 0x00080000u;
  if (partitionmetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandPartitionedTopicMetadata>(GetArenaForAllocation());
    partitionmetadata_ = p;
  }
  return partitionmetadata_;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::mutable_partitionmetadata() {
  ::pulsar::proto::CommandPartitionedTopicMetadata* _msg = _internal_mutable_partitionmetadata();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.partitionMetadata)
  return _msg;
}
inline void BaseCommand::set_allocated_partitionmetadata(::pulsar::proto::CommandPartitionedTopicMetadata* partitionmetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete partitionmetadata_;
  }
  if (partitionmetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandPartitionedTopicMetadata>::GetOwningArena(partitionmetadata);
    if (message_arena != submessage_arena) {
      partitionmetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partitionmetadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  partitionmetadata_ = partitionmetadata;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.partitionMetadata)
}

// optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
inline bool BaseCommand::_internal_has_partitionmetadataresponse() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || partitionmetadataresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_partitionmetadataresponse() const {
  return _internal_has_partitionmetadataresponse();
}
inline void BaseCommand::clear_partitionmetadataresponse() {
  if (partitionmetadataresponse_ != nullptr) partitionmetadataresponse_->Clear();
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& BaseCommand::_internal_partitionmetadataresponse() const {
  const ::pulsar::proto::CommandPartitionedTopicMetadataResponse* p = partitionmetadataresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandPartitionedTopicMetadataResponse&>(
      ::pulsar::proto::_CommandPartitionedTopicMetadataResponse_default_instance_);
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& BaseCommand::partitionmetadataresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.partitionMetadataResponse)
  return _internal_partitionmetadataresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_partitionmetadataresponse(
    ::pulsar::proto::CommandPartitionedTopicMetadataResponse* partitionmetadataresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partitionmetadataresponse_);
  }
  partitionmetadataresponse_ = partitionmetadataresponse;
  if (partitionmetadataresponse) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.partitionMetadataResponse)
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::release_partitionmetadataresponse() {
  _has_bits_[0] &= ~0x00100000u;
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* temp = partitionmetadataresponse_;
  partitionmetadataresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::unsafe_arena_release_partitionmetadataresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.partitionMetadataResponse)
  _has_bits_[0] &= ~0x00100000u;
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* temp = partitionmetadataresponse_;
  partitionmetadataresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::_internal_mutable_partitionmetadataresponse() {
  _has_bits_[0] |= 0x00100000u;
  if (partitionmetadataresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandPartitionedTopicMetadataResponse>(GetArenaForAllocation());
    partitionmetadataresponse_ = p;
  }
  return partitionmetadataresponse_;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::mutable_partitionmetadataresponse() {
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* _msg = _internal_mutable_partitionmetadataresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.partitionMetadataResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_partitionmetadataresponse(::pulsar::proto::CommandPartitionedTopicMetadataResponse* partitionmetadataresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete partitionmetadataresponse_;
  }
  if (partitionmetadataresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandPartitionedTopicMetadataResponse>::GetOwningArena(partitionmetadataresponse);
    if (message_arena != submessage_arena) {
      partitionmetadataresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partitionmetadataresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  partitionmetadataresponse_ = partitionmetadataresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.partitionMetadataResponse)
}

// optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
inline bool BaseCommand::_internal_has_lookuptopic() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || lookuptopic_ != nullptr);
  return value;
}
inline bool BaseCommand::has_lookuptopic() const {
  return _internal_has_lookuptopic();
}
inline void BaseCommand::clear_lookuptopic() {
  if (lookuptopic_ != nullptr) lookuptopic_->Clear();
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::pulsar::proto::CommandLookupTopic& BaseCommand::_internal_lookuptopic() const {
  const ::pulsar::proto::CommandLookupTopic* p = lookuptopic_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandLookupTopic&>(
      ::pulsar::proto::_CommandLookupTopic_default_instance_);
}
inline const ::pulsar::proto::CommandLookupTopic& BaseCommand::lookuptopic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.lookupTopic)
  return _internal_lookuptopic();
}
inline void BaseCommand::unsafe_arena_set_allocated_lookuptopic(
    ::pulsar::proto::CommandLookupTopic* lookuptopic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lookuptopic_);
  }
  lookuptopic_ = lookuptopic;
  if (lookuptopic) {
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.lookupTopic)
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::release_lookuptopic() {
  _has_bits_[0] &= ~0x00200000u;
  ::pulsar::proto::CommandLookupTopic* temp = lookuptopic_;
  lookuptopic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::unsafe_arena_release_lookuptopic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.lookupTopic)
  _has_bits_[0] &= ~0x00200000u;
  ::pulsar::proto::CommandLookupTopic* temp = lookuptopic_;
  lookuptopic_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::_internal_mutable_lookuptopic() {
  _has_bits_[0] |= 0x00200000u;
  if (lookuptopic_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandLookupTopic>(GetArenaForAllocation());
    lookuptopic_ = p;
  }
  return lookuptopic_;
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::mutable_lookuptopic() {
  ::pulsar::proto::CommandLookupTopic* _msg = _internal_mutable_lookuptopic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.lookupTopic)
  return _msg;
}
inline void BaseCommand::set_allocated_lookuptopic(::pulsar::proto::CommandLookupTopic* lookuptopic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lookuptopic_;
  }
  if (lookuptopic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandLookupTopic>::GetOwningArena(lookuptopic);
    if (message_arena != submessage_arena) {
      lookuptopic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lookuptopic, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  lookuptopic_ = lookuptopic;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.lookupTopic)
}

// optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
inline bool BaseCommand::_internal_has_lookuptopicresponse() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || lookuptopicresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_lookuptopicresponse() const {
  return _internal_has_lookuptopicresponse();
}
inline void BaseCommand::clear_lookuptopicresponse() {
  if (lookuptopicresponse_ != nullptr) lookuptopicresponse_->Clear();
  _has_bits_[0] &= ~0x00400000u;
}
inline const ::pulsar::proto::CommandLookupTopicResponse& BaseCommand::_internal_lookuptopicresponse() const {
  const ::pulsar::proto::CommandLookupTopicResponse* p = lookuptopicresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandLookupTopicResponse&>(
      ::pulsar::proto::_CommandLookupTopicResponse_default_instance_);
}
inline const ::pulsar::proto::CommandLookupTopicResponse& BaseCommand::lookuptopicresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.lookupTopicResponse)
  return _internal_lookuptopicresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_lookuptopicresponse(
    ::pulsar::proto::CommandLookupTopicResponse* lookuptopicresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lookuptopicresponse_);
  }
  lookuptopicresponse_ = lookuptopicresponse;
  if (lookuptopicresponse) {
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.lookupTopicResponse)
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::release_lookuptopicresponse() {
  _has_bits_[0] &= ~0x00400000u;
  ::pulsar::proto::CommandLookupTopicResponse* temp = lookuptopicresponse_;
  lookuptopicresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::unsafe_arena_release_lookuptopicresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.lookupTopicResponse)
  _has_bits_[0] &= ~0x00400000u;
  ::pulsar::proto::CommandLookupTopicResponse* temp = lookuptopicresponse_;
  lookuptopicresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::_internal_mutable_lookuptopicresponse() {
  _has_bits_[0] |= 0x00400000u;
  if (lookuptopicresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandLookupTopicResponse>(GetArenaForAllocation());
    lookuptopicresponse_ = p;
  }
  return lookuptopicresponse_;
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::mutable_lookuptopicresponse() {
  ::pulsar::proto::CommandLookupTopicResponse* _msg = _internal_mutable_lookuptopicresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.lookupTopicResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_lookuptopicresponse(::pulsar::proto::CommandLookupTopicResponse* lookuptopicresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lookuptopicresponse_;
  }
  if (lookuptopicresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandLookupTopicResponse>::GetOwningArena(lookuptopicresponse);
    if (message_arena != submessage_arena) {
      lookuptopicresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lookuptopicresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  lookuptopicresponse_ = lookuptopicresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.lookupTopicResponse)
}

// optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
inline bool BaseCommand::_internal_has_consumerstats() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || consumerstats_ != nullptr);
  return value;
}
inline bool BaseCommand::has_consumerstats() const {
  return _internal_has_consumerstats();
}
inline void BaseCommand::clear_consumerstats() {
  if (consumerstats_ != nullptr) consumerstats_->Clear();
  _has_bits_[0] &= ~0x00800000u;
}
inline const ::pulsar::proto::CommandConsumerStats& BaseCommand::_internal_consumerstats() const {
  const ::pulsar::proto::CommandConsumerStats* p = consumerstats_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandConsumerStats&>(
      ::pulsar::proto::_CommandConsumerStats_default_instance_);
}
inline const ::pulsar::proto::CommandConsumerStats& BaseCommand::consumerstats() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.consumerStats)
  return _internal_consumerstats();
}
inline void BaseCommand::unsafe_arena_set_allocated_consumerstats(
    ::pulsar::proto::CommandConsumerStats* consumerstats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consumerstats_);
  }
  consumerstats_ = consumerstats;
  if (consumerstats) {
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.consumerStats)
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::release_consumerstats() {
  _has_bits_[0] &= ~0x00800000u;
  ::pulsar::proto::CommandConsumerStats* temp = consumerstats_;
  consumerstats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::unsafe_arena_release_consumerstats() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.consumerStats)
  _has_bits_[0] &= ~0x00800000u;
  ::pulsar::proto::CommandConsumerStats* temp = consumerstats_;
  consumerstats_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::_internal_mutable_consumerstats() {
  _has_bits_[0] |= 0x00800000u;
  if (consumerstats_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandConsumerStats>(GetArenaForAllocation());
    consumerstats_ = p;
  }
  return consumerstats_;
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::mutable_consumerstats() {
  ::pulsar::proto::CommandConsumerStats* _msg = _internal_mutable_consumerstats();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.consumerStats)
  return _msg;
}
inline void BaseCommand::set_allocated_consumerstats(::pulsar::proto::CommandConsumerStats* consumerstats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete consumerstats_;
  }
  if (consumerstats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandConsumerStats>::GetOwningArena(consumerstats);
    if (message_arena != submessage_arena) {
      consumerstats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consumerstats, submessage_arena);
    }
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  consumerstats_ = consumerstats;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.consumerStats)
}

// optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
inline bool BaseCommand::_internal_has_consumerstatsresponse() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || consumerstatsresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_consumerstatsresponse() const {
  return _internal_has_consumerstatsresponse();
}
inline void BaseCommand::clear_consumerstatsresponse() {
  if (consumerstatsresponse_ != nullptr) consumerstatsresponse_->Clear();
  _has_bits_[0] &= ~0x01000000u;
}
inline const ::pulsar::proto::CommandConsumerStatsResponse& BaseCommand::_internal_consumerstatsresponse() const {
  const ::pulsar::proto::CommandConsumerStatsResponse* p = consumerstatsresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandConsumerStatsResponse&>(
      ::pulsar::proto::_CommandConsumerStatsResponse_default_instance_);
}
inline const ::pulsar::proto::CommandConsumerStatsResponse& BaseCommand::consumerstatsresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.consumerStatsResponse)
  return _internal_consumerstatsresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_consumerstatsresponse(
    ::pulsar::proto::CommandConsumerStatsResponse* consumerstatsresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consumerstatsresponse_);
  }
  consumerstatsresponse_ = consumerstatsresponse;
  if (consumerstatsresponse) {
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.consumerStatsResponse)
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::release_consumerstatsresponse() {
  _has_bits_[0] &= ~0x01000000u;
  ::pulsar::proto::CommandConsumerStatsResponse* temp = consumerstatsresponse_;
  consumerstatsresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::unsafe_arena_release_consumerstatsresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.consumerStatsResponse)
  _has_bits_[0] &= ~0x01000000u;
  ::pulsar::proto::CommandConsumerStatsResponse* temp = consumerstatsresponse_;
  consumerstatsresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::_internal_mutable_consumerstatsresponse() {
  _has_bits_[0] |= 0x01000000u;
  if (consumerstatsresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandConsumerStatsResponse>(GetArenaForAllocation());
    consumerstatsresponse_ = p;
  }
  return consumerstatsresponse_;
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::mutable_consumerstatsresponse() {
  ::pulsar::proto::CommandConsumerStatsResponse* _msg = _internal_mutable_consumerstatsresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.consumerStatsResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_consumerstatsresponse(::pulsar::proto::CommandConsumerStatsResponse* consumerstatsresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete consumerstatsresponse_;
  }
  if (consumerstatsresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandConsumerStatsResponse>::GetOwningArena(consumerstatsresponse);
    if (message_arena != submessage_arena) {
      consumerstatsresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consumerstatsresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  consumerstatsresponse_ = consumerstatsresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.consumerStatsResponse)
}

// optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
inline bool BaseCommand::_internal_has_reachedendoftopic() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || reachedendoftopic_ != nullptr);
  return value;
}
inline bool BaseCommand::has_reachedendoftopic() const {
  return _internal_has_reachedendoftopic();
}
inline void BaseCommand::clear_reachedendoftopic() {
  if (reachedendoftopic_ != nullptr) reachedendoftopic_->Clear();
  _has_bits_[0] &= ~0x02000000u;
}
inline const ::pulsar::proto::CommandReachedEndOfTopic& BaseCommand::_internal_reachedendoftopic() const {
  const ::pulsar::proto::CommandReachedEndOfTopic* p = reachedendoftopic_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandReachedEndOfTopic&>(
      ::pulsar::proto::_CommandReachedEndOfTopic_default_instance_);
}
inline const ::pulsar::proto::CommandReachedEndOfTopic& BaseCommand::reachedendoftopic() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.reachedEndOfTopic)
  return _internal_reachedendoftopic();
}
inline void BaseCommand::unsafe_arena_set_allocated_reachedendoftopic(
    ::pulsar::proto::CommandReachedEndOfTopic* reachedendoftopic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reachedendoftopic_);
  }
  reachedendoftopic_ = reachedendoftopic;
  if (reachedendoftopic) {
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.reachedEndOfTopic)
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::release_reachedendoftopic() {
  _has_bits_[0] &= ~0x02000000u;
  ::pulsar::proto::CommandReachedEndOfTopic* temp = reachedendoftopic_;
  reachedendoftopic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::unsafe_arena_release_reachedendoftopic() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.reachedEndOfTopic)
  _has_bits_[0] &= ~0x02000000u;
  ::pulsar::proto::CommandReachedEndOfTopic* temp = reachedendoftopic_;
  reachedendoftopic_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::_internal_mutable_reachedendoftopic() {
  _has_bits_[0] |= 0x02000000u;
  if (reachedendoftopic_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandReachedEndOfTopic>(GetArenaForAllocation());
    reachedendoftopic_ = p;
  }
  return reachedendoftopic_;
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::mutable_reachedendoftopic() {
  ::pulsar::proto::CommandReachedEndOfTopic* _msg = _internal_mutable_reachedendoftopic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.reachedEndOfTopic)
  return _msg;
}
inline void BaseCommand::set_allocated_reachedendoftopic(::pulsar::proto::CommandReachedEndOfTopic* reachedendoftopic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reachedendoftopic_;
  }
  if (reachedendoftopic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandReachedEndOfTopic>::GetOwningArena(reachedendoftopic);
    if (message_arena != submessage_arena) {
      reachedendoftopic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reachedendoftopic, submessage_arena);
    }
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  reachedendoftopic_ = reachedendoftopic;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.reachedEndOfTopic)
}

// optional .pulsar.proto.CommandSeek seek = 28;
inline bool BaseCommand::_internal_has_seek() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || seek_ != nullptr);
  return value;
}
inline bool BaseCommand::has_seek() const {
  return _internal_has_seek();
}
inline void BaseCommand::clear_seek() {
  if (seek_ != nullptr) seek_->Clear();
  _has_bits_[0] &= ~0x04000000u;
}
inline const ::pulsar::proto::CommandSeek& BaseCommand::_internal_seek() const {
  const ::pulsar::proto::CommandSeek* p = seek_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSeek&>(
      ::pulsar::proto::_CommandSeek_default_instance_);
}
inline const ::pulsar::proto::CommandSeek& BaseCommand::seek() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.seek)
  return _internal_seek();
}
inline void BaseCommand::unsafe_arena_set_allocated_seek(
    ::pulsar::proto::CommandSeek* seek) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(seek_);
  }
  seek_ = seek;
  if (seek) {
    _has_bits_[0] |= 0x04000000u;
  } else {
    _has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.seek)
}
inline ::pulsar::proto::CommandSeek* BaseCommand::release_seek() {
  _has_bits_[0] &= ~0x04000000u;
  ::pulsar::proto::CommandSeek* temp = seek_;
  seek_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandSeek* BaseCommand::unsafe_arena_release_seek() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.seek)
  _has_bits_[0] &= ~0x04000000u;
  ::pulsar::proto::CommandSeek* temp = seek_;
  seek_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSeek* BaseCommand::_internal_mutable_seek() {
  _has_bits_[0] |= 0x04000000u;
  if (seek_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSeek>(GetArenaForAllocation());
    seek_ = p;
  }
  return seek_;
}
inline ::pulsar::proto::CommandSeek* BaseCommand::mutable_seek() {
  ::pulsar::proto::CommandSeek* _msg = _internal_mutable_seek();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.seek)
  return _msg;
}
inline void BaseCommand::set_allocated_seek(::pulsar::proto::CommandSeek* seek) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete seek_;
  }
  if (seek) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandSeek>::GetOwningArena(seek);
    if (message_arena != submessage_arena) {
      seek = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seek, submessage_arena);
    }
    _has_bits_[0] |= 0x04000000u;
  } else {
    _has_bits_[0] &= ~0x04000000u;
  }
  seek_ = seek;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.seek)
}

// optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
inline bool BaseCommand::_internal_has_getlastmessageid() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || getlastmessageid_ != nullptr);
  return value;
}
inline bool BaseCommand::has_getlastmessageid() const {
  return _internal_has_getlastmessageid();
}
inline void BaseCommand::clear_getlastmessageid() {
  if (getlastmessageid_ != nullptr) getlastmessageid_->Clear();
  _has_bits_[0] &= ~0x08000000u;
}
inline const ::pulsar::proto::CommandGetLastMessageId& BaseCommand::_internal_getlastmessageid() const {
  const ::pulsar::proto::CommandGetLastMessageId* p = getlastmessageid_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetLastMessageId&>(
      ::pulsar::proto::_CommandGetLastMessageId_default_instance_);
}
inline const ::pulsar::proto::CommandGetLastMessageId& BaseCommand::getlastmessageid() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getLastMessageId)
  return _internal_getlastmessageid();
}
inline void BaseCommand::unsafe_arena_set_allocated_getlastmessageid(
    ::pulsar::proto::CommandGetLastMessageId* getlastmessageid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getlastmessageid_);
  }
  getlastmessageid_ = getlastmessageid;
  if (getlastmessageid) {
    _has_bits_[0] |= 0x08000000u;
  } else {
    _has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getLastMessageId)
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::release_getlastmessageid() {
  _has_bits_[0] &= ~0x08000000u;
  ::pulsar::proto::CommandGetLastMessageId* temp = getlastmessageid_;
  getlastmessageid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::unsafe_arena_release_getlastmessageid() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getLastMessageId)
  _has_bits_[0] &= ~0x08000000u;
  ::pulsar::proto::CommandGetLastMessageId* temp = getlastmessageid_;
  getlastmessageid_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::_internal_mutable_getlastmessageid() {
  _has_bits_[0] |= 0x08000000u;
  if (getlastmessageid_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetLastMessageId>(GetArenaForAllocation());
    getlastmessageid_ = p;
  }
  return getlastmessageid_;
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::mutable_getlastmessageid() {
  ::pulsar::proto::CommandGetLastMessageId* _msg = _internal_mutable_getlastmessageid();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getLastMessageId)
  return _msg;
}
inline void BaseCommand::set_allocated_getlastmessageid(::pulsar::proto::CommandGetLastMessageId* getlastmessageid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getlastmessageid_;
  }
  if (getlastmessageid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandGetLastMessageId>::GetOwningArena(getlastmessageid);
    if (message_arena != submessage_arena) {
      getlastmessageid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getlastmessageid, submessage_arena);
    }
    _has_bits_[0] |= 0x08000000u;
  } else {
    _has_bits_[0] &= ~0x08000000u;
  }
  getlastmessageid_ = getlastmessageid;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getLastMessageId)
}

// optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
inline bool BaseCommand::_internal_has_getlastmessageidresponse() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || getlastmessageidresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_getlastmessageidresponse() const {
  return _internal_has_getlastmessageidresponse();
}
inline void BaseCommand::clear_getlastmessageidresponse() {
  if (getlastmessageidresponse_ != nullptr) getlastmessageidresponse_->Clear();
  _has_bits_[0] &= ~0x10000000u;
}
inline const ::pulsar::proto::CommandGetLastMessageIdResponse& BaseCommand::_internal_getlastmessageidresponse() const {
  const ::pulsar::proto::CommandGetLastMessageIdResponse* p = getlastmessageidresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetLastMessageIdResponse&>(
      ::pulsar::proto::_CommandGetLastMessageIdResponse_default_instance_);
}
inline const ::pulsar::proto::CommandGetLastMessageIdResponse& BaseCommand::getlastmessageidresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getLastMessageIdResponse)
  return _internal_getlastmessageidresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_getlastmessageidresponse(
    ::pulsar::proto::CommandGetLastMessageIdResponse* getlastmessageidresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getlastmessageidresponse_);
  }
  getlastmessageidresponse_ = getlastmessageidresponse;
  if (getlastmessageidresponse) {
    _has_bits_[0] |= 0x10000000u;
  } else {
    _has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getLastMessageIdResponse)
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::release_getlastmessageidresponse() {
  _has_bits_[0] &= ~0x10000000u;
  ::pulsar::proto::CommandGetLastMessageIdResponse* temp = getlastmessageidresponse_;
  getlastmessageidresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::unsafe_arena_release_getlastmessageidresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getLastMessageIdResponse)
  _has_bits_[0] &= ~0x10000000u;
  ::pulsar::proto::CommandGetLastMessageIdResponse* temp = getlastmessageidresponse_;
  getlastmessageidresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::_internal_mutable_getlastmessageidresponse() {
  _has_bits_[0] |= 0x10000000u;
  if (getlastmessageidresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetLastMessageIdResponse>(GetArenaForAllocation());
    getlastmessageidresponse_ = p;
  }
  return getlastmessageidresponse_;
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::mutable_getlastmessageidresponse() {
  ::pulsar::proto::CommandGetLastMessageIdResponse* _msg = _internal_mutable_getlastmessageidresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getLastMessageIdResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_getlastmessageidresponse(::pulsar::proto::CommandGetLastMessageIdResponse* getlastmessageidresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getlastmessageidresponse_;
  }
  if (getlastmessageidresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandGetLastMessageIdResponse>::GetOwningArena(getlastmessageidresponse);
    if (message_arena != submessage_arena) {
      getlastmessageidresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getlastmessageidresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x10000000u;
  } else {
    _has_bits_[0] &= ~0x10000000u;
  }
  getlastmessageidresponse_ = getlastmessageidresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getLastMessageIdResponse)
}

// optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
inline bool BaseCommand::_internal_has_active_consumer_change() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || active_consumer_change_ != nullptr);
  return value;
}
inline bool BaseCommand::has_active_consumer_change() const {
  return _internal_has_active_consumer_change();
}
inline void BaseCommand::clear_active_consumer_change() {
  if (active_consumer_change_ != nullptr) active_consumer_change_->Clear();
  _has_bits_[0] &= ~0x20000000u;
}
inline const ::pulsar::proto::CommandActiveConsumerChange& BaseCommand::_internal_active_consumer_change() const {
  const ::pulsar::proto::CommandActiveConsumerChange* p = active_consumer_change_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandActiveConsumerChange&>(
      ::pulsar::proto::_CommandActiveConsumerChange_default_instance_);
}
inline const ::pulsar::proto::CommandActiveConsumerChange& BaseCommand::active_consumer_change() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.active_consumer_change)
  return _internal_active_consumer_change();
}
inline void BaseCommand::unsafe_arena_set_allocated_active_consumer_change(
    ::pulsar::proto::CommandActiveConsumerChange* active_consumer_change) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(active_consumer_change_);
  }
  active_consumer_change_ = active_consumer_change;
  if (active_consumer_change) {
    _has_bits_[0] |= 0x20000000u;
  } else {
    _has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.active_consumer_change)
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::release_active_consumer_change() {
  _has_bits_[0] &= ~0x20000000u;
  ::pulsar::proto::CommandActiveConsumerChange* temp = active_consumer_change_;
  active_consumer_change_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::unsafe_arena_release_active_consumer_change() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.active_consumer_change)
  _has_bits_[0] &= ~0x20000000u;
  ::pulsar::proto::CommandActiveConsumerChange* temp = active_consumer_change_;
  active_consumer_change_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::_internal_mutable_active_consumer_change() {
  _has_bits_[0] |= 0x20000000u;
  if (active_consumer_change_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandActiveConsumerChange>(GetArenaForAllocation());
    active_consumer_change_ = p;
  }
  return active_consumer_change_;
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::mutable_active_consumer_change() {
  ::pulsar::proto::CommandActiveConsumerChange* _msg = _internal_mutable_active_consumer_change();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.active_consumer_change)
  return _msg;
}
inline void BaseCommand::set_allocated_active_consumer_change(::pulsar::proto::CommandActiveConsumerChange* active_consumer_change) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete active_consumer_change_;
  }
  if (active_consumer_change) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandActiveConsumerChange>::GetOwningArena(active_consumer_change);
    if (message_arena != submessage_arena) {
      active_consumer_change = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_consumer_change, submessage_arena);
    }
    _has_bits_[0] |= 0x20000000u;
  } else {
    _has_bits_[0] &= ~0x20000000u;
  }
  active_consumer_change_ = active_consumer_change;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.active_consumer_change)
}

// optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
inline bool BaseCommand::_internal_has_gettopicsofnamespace() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || gettopicsofnamespace_ != nullptr);
  return value;
}
inline bool BaseCommand::has_gettopicsofnamespace() const {
  return _internal_has_gettopicsofnamespace();
}
inline void BaseCommand::clear_gettopicsofnamespace() {
  if (gettopicsofnamespace_ != nullptr) gettopicsofnamespace_->Clear();
  _has_bits_[0] &= ~0x40000000u;
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespace& BaseCommand::_internal_gettopicsofnamespace() const {
  const ::pulsar::proto::CommandGetTopicsOfNamespace* p = gettopicsofnamespace_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetTopicsOfNamespace&>(
      ::pulsar::proto::_CommandGetTopicsOfNamespace_default_instance_);
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespace& BaseCommand::gettopicsofnamespace() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getTopicsOfNamespace)
  return _internal_gettopicsofnamespace();
}
inline void BaseCommand::unsafe_arena_set_allocated_gettopicsofnamespace(
    ::pulsar::proto::CommandGetTopicsOfNamespace* gettopicsofnamespace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gettopicsofnamespace_);
  }
  gettopicsofnamespace_ = gettopicsofnamespace;
  if (gettopicsofnamespace) {
    _has_bits_[0] |= 0x40000000u;
  } else {
    _has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespace)
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::release_gettopicsofnamespace() {
  _has_bits_[0] &= ~0x40000000u;
  ::pulsar::proto::CommandGetTopicsOfNamespace* temp = gettopicsofnamespace_;
  gettopicsofnamespace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::unsafe_arena_release_gettopicsofnamespace() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getTopicsOfNamespace)
  _has_bits_[0] &= ~0x40000000u;
  ::pulsar::proto::CommandGetTopicsOfNamespace* temp = gettopicsofnamespace_;
  gettopicsofnamespace_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::_internal_mutable_gettopicsofnamespace() {
  _has_bits_[0] |= 0x40000000u;
  if (gettopicsofnamespace_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetTopicsOfNamespace>(GetArenaForAllocation());
    gettopicsofnamespace_ = p;
  }
  return gettopicsofnamespace_;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::mutable_gettopicsofnamespace() {
  ::pulsar::proto::CommandGetTopicsOfNamespace* _msg = _internal_mutable_gettopicsofnamespace();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getTopicsOfNamespace)
  return _msg;
}
inline void BaseCommand::set_allocated_gettopicsofnamespace(::pulsar::proto::CommandGetTopicsOfNamespace* gettopicsofnamespace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gettopicsofnamespace_;
  }
  if (gettopicsofnamespace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandGetTopicsOfNamespace>::GetOwningArena(gettopicsofnamespace);
    if (message_arena != submessage_arena) {
      gettopicsofnamespace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gettopicsofnamespace, submessage_arena);
    }
    _has_bits_[0] |= 0x40000000u;
  } else {
    _has_bits_[0] &= ~0x40000000u;
  }
  gettopicsofnamespace_ = gettopicsofnamespace;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespace)
}

// optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
inline bool BaseCommand::_internal_has_gettopicsofnamespaceresponse() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || gettopicsofnamespaceresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_gettopicsofnamespaceresponse() const {
  return _internal_has_gettopicsofnamespaceresponse();
}
inline void BaseCommand::clear_gettopicsofnamespaceresponse() {
  if (gettopicsofnamespaceresponse_ != nullptr) gettopicsofnamespaceresponse_->Clear();
  _has_bits_[0] &= ~0x80000000u;
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& BaseCommand::_internal_gettopicsofnamespaceresponse() const {
  const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* p = gettopicsofnamespaceresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse&>(
      ::pulsar::proto::_CommandGetTopicsOfNamespaceResponse_default_instance_);
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& BaseCommand::gettopicsofnamespaceresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
  return _internal_gettopicsofnamespaceresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_gettopicsofnamespaceresponse(
    ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* gettopicsofnamespaceresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gettopicsofnamespaceresponse_);
  }
  gettopicsofnamespaceresponse_ = gettopicsofnamespaceresponse;
  if (gettopicsofnamespaceresponse) {
    _has_bits_[0] |= 0x80000000u;
  } else {
    _has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::release_gettopicsofnamespaceresponse() {
  _has_bits_[0] &= ~0x80000000u;
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* temp = gettopicsofnamespaceresponse_;
  gettopicsofnamespaceresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::unsafe_arena_release_gettopicsofnamespaceresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
  _has_bits_[0] &= ~0x80000000u;
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* temp = gettopicsofnamespaceresponse_;
  gettopicsofnamespaceresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::_internal_mutable_gettopicsofnamespaceresponse() {
  _has_bits_[0] |= 0x80000000u;
  if (gettopicsofnamespaceresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetTopicsOfNamespaceResponse>(GetArenaForAllocation());
    gettopicsofnamespaceresponse_ = p;
  }
  return gettopicsofnamespaceresponse_;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::mutable_gettopicsofnamespaceresponse() {
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* _msg = _internal_mutable_gettopicsofnamespaceresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_gettopicsofnamespaceresponse(::pulsar::proto::CommandGetTopicsOfNamespaceResponse* gettopicsofnamespaceresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gettopicsofnamespaceresponse_;
  }
  if (gettopicsofnamespaceresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandGetTopicsOfNamespaceResponse>::GetOwningArena(gettopicsofnamespaceresponse);
    if (message_arena != submessage_arena) {
      gettopicsofnamespaceresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gettopicsofnamespaceresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x80000000u;
  } else {
    _has_bits_[0] &= ~0x80000000u;
  }
  gettopicsofnamespaceresponse_ = gettopicsofnamespaceresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
}

// optional .pulsar.proto.CommandGetSchema getSchema = 34;
inline bool BaseCommand::_internal_has_getschema() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || getschema_ != nullptr);
  return value;
}
inline bool BaseCommand::has_getschema() const {
  return _internal_has_getschema();
}
inline void BaseCommand::clear_getschema() {
  if (getschema_ != nullptr) getschema_->Clear();
  _has_bits_[1] &= ~0x00000001u;
}
inline const ::pulsar::proto::CommandGetSchema& BaseCommand::_internal_getschema() const {
  const ::pulsar::proto::CommandGetSchema* p = getschema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetSchema&>(
      ::pulsar::proto::_CommandGetSchema_default_instance_);
}
inline const ::pulsar::proto::CommandGetSchema& BaseCommand::getschema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getSchema)
  return _internal_getschema();
}
inline void BaseCommand::unsafe_arena_set_allocated_getschema(
    ::pulsar::proto::CommandGetSchema* getschema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getschema_);
  }
  getschema_ = getschema;
  if (getschema) {
    _has_bits_[1] |= 0x00000001u;
  } else {
    _has_bits_[1] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getSchema)
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::release_getschema() {
  _has_bits_[1] &= ~0x00000001u;
  ::pulsar::proto::CommandGetSchema* temp = getschema_;
  getschema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::unsafe_arena_release_getschema() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getSchema)
  _has_bits_[1] &= ~0x00000001u;
  ::pulsar::proto::CommandGetSchema* temp = getschema_;
  getschema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::_internal_mutable_getschema() {
  _has_bits_[1] |= 0x00000001u;
  if (getschema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetSchema>(GetArenaForAllocation());
    getschema_ = p;
  }
  return getschema_;
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::mutable_getschema() {
  ::pulsar::proto::CommandGetSchema* _msg = _internal_mutable_getschema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getSchema)
  return _msg;
}
inline void BaseCommand::set_allocated_getschema(::pulsar::proto::CommandGetSchema* getschema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getschema_;
  }
  if (getschema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandGetSchema>::GetOwningArena(getschema);
    if (message_arena != submessage_arena) {
      getschema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getschema, submessage_arena);
    }
    _has_bits_[1] |= 0x00000001u;
  } else {
    _has_bits_[1] &= ~0x00000001u;
  }
  getschema_ = getschema;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getSchema)
}

// optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
inline bool BaseCommand::_internal_has_getschemaresponse() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || getschemaresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_getschemaresponse() const {
  return _internal_has_getschemaresponse();
}
inline void BaseCommand::clear_getschemaresponse() {
  if (getschemaresponse_ != nullptr) getschemaresponse_->Clear();
  _has_bits_[1] &= ~0x00000002u;
}
inline const ::pulsar::proto::CommandGetSchemaResponse& BaseCommand::_internal_getschemaresponse() const {
  const ::pulsar::proto::CommandGetSchemaResponse* p = getschemaresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetSchemaResponse&>(
      ::pulsar::proto::_CommandGetSchemaResponse_default_instance_);
}
inline const ::pulsar::proto::CommandGetSchemaResponse& BaseCommand::getschemaresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getSchemaResponse)
  return _internal_getschemaresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_getschemaresponse(
    ::pulsar::proto::CommandGetSchemaResponse* getschemaresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getschemaresponse_);
  }
  getschemaresponse_ = getschemaresponse;
  if (getschemaresponse) {
    _has_bits_[1] |= 0x00000002u;
  } else {
    _has_bits_[1] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getSchemaResponse)
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::release_getschemaresponse() {
  _has_bits_[1] &= ~0x00000002u;
  ::pulsar::proto::CommandGetSchemaResponse* temp = getschemaresponse_;
  getschemaresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::unsafe_arena_release_getschemaresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getSchemaResponse)
  _has_bits_[1] &= ~0x00000002u;
  ::pulsar::proto::CommandGetSchemaResponse* temp = getschemaresponse_;
  getschemaresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::_internal_mutable_getschemaresponse() {
  _has_bits_[1] |= 0x00000002u;
  if (getschemaresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetSchemaResponse>(GetArenaForAllocation());
    getschemaresponse_ = p;
  }
  return getschemaresponse_;
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::mutable_getschemaresponse() {
  ::pulsar::proto::CommandGetSchemaResponse* _msg = _internal_mutable_getschemaresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getSchemaResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_getschemaresponse(::pulsar::proto::CommandGetSchemaResponse* getschemaresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getschemaresponse_;
  }
  if (getschemaresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandGetSchemaResponse>::GetOwningArena(getschemaresponse);
    if (message_arena != submessage_arena) {
      getschemaresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getschemaresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00000002u;
  } else {
    _has_bits_[1] &= ~0x00000002u;
  }
  getschemaresponse_ = getschemaresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getSchemaResponse)
}

// optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
inline bool BaseCommand::_internal_has_authchallenge() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || authchallenge_ != nullptr);
  return value;
}
inline bool BaseCommand::has_authchallenge() const {
  return _internal_has_authchallenge();
}
inline void BaseCommand::clear_authchallenge() {
  if (authchallenge_ != nullptr) authchallenge_->Clear();
  _has_bits_[1] &= ~0x00000004u;
}
inline const ::pulsar::proto::CommandAuthChallenge& BaseCommand::_internal_authchallenge() const {
  const ::pulsar::proto::CommandAuthChallenge* p = authchallenge_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAuthChallenge&>(
      ::pulsar::proto::_CommandAuthChallenge_default_instance_);
}
inline const ::pulsar::proto::CommandAuthChallenge& BaseCommand::authchallenge() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.authChallenge)
  return _internal_authchallenge();
}
inline void BaseCommand::unsafe_arena_set_allocated_authchallenge(
    ::pulsar::proto::CommandAuthChallenge* authchallenge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authchallenge_);
  }
  authchallenge_ = authchallenge;
  if (authchallenge) {
    _has_bits_[1] |= 0x00000004u;
  } else {
    _has_bits_[1] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.authChallenge)
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::release_authchallenge() {
  _has_bits_[1] &= ~0x00000004u;
  ::pulsar::proto::CommandAuthChallenge* temp = authchallenge_;
  authchallenge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::unsafe_arena_release_authchallenge() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.authChallenge)
  _has_bits_[1] &= ~0x00000004u;
  ::pulsar::proto::CommandAuthChallenge* temp = authchallenge_;
  authchallenge_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::_internal_mutable_authchallenge() {
  _has_bits_[1] |= 0x00000004u;
  if (authchallenge_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAuthChallenge>(GetArenaForAllocation());
    authchallenge_ = p;
  }
  return authchallenge_;
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::mutable_authchallenge() {
  ::pulsar::proto::CommandAuthChallenge* _msg = _internal_mutable_authchallenge();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.authChallenge)
  return _msg;
}
inline void BaseCommand::set_allocated_authchallenge(::pulsar::proto::CommandAuthChallenge* authchallenge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authchallenge_;
  }
  if (authchallenge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandAuthChallenge>::GetOwningArena(authchallenge);
    if (message_arena != submessage_arena) {
      authchallenge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authchallenge, submessage_arena);
    }
    _has_bits_[1] |= 0x00000004u;
  } else {
    _has_bits_[1] &= ~0x00000004u;
  }
  authchallenge_ = authchallenge;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.authChallenge)
}

// optional .pulsar.proto.CommandAuthResponse authResponse = 37;
inline bool BaseCommand::_internal_has_authresponse() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || authresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_authresponse() const {
  return _internal_has_authresponse();
}
inline void BaseCommand::clear_authresponse() {
  if (authresponse_ != nullptr) authresponse_->Clear();
  _has_bits_[1] &= ~0x00000008u;
}
inline const ::pulsar::proto::CommandAuthResponse& BaseCommand::_internal_authresponse() const {
  const ::pulsar::proto::CommandAuthResponse* p = authresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAuthResponse&>(
      ::pulsar::proto::_CommandAuthResponse_default_instance_);
}
inline const ::pulsar::proto::CommandAuthResponse& BaseCommand::authresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.authResponse)
  return _internal_authresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_authresponse(
    ::pulsar::proto::CommandAuthResponse* authresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(authresponse_);
  }
  authresponse_ = authresponse;
  if (authresponse) {
    _has_bits_[1] |= 0x00000008u;
  } else {
    _has_bits_[1] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.authResponse)
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::release_authresponse() {
  _has_bits_[1] &= ~0x00000008u;
  ::pulsar::proto::CommandAuthResponse* temp = authresponse_;
  authresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::unsafe_arena_release_authresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.authResponse)
  _has_bits_[1] &= ~0x00000008u;
  ::pulsar::proto::CommandAuthResponse* temp = authresponse_;
  authresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::_internal_mutable_authresponse() {
  _has_bits_[1] |= 0x00000008u;
  if (authresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAuthResponse>(GetArenaForAllocation());
    authresponse_ = p;
  }
  return authresponse_;
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::mutable_authresponse() {
  ::pulsar::proto::CommandAuthResponse* _msg = _internal_mutable_authresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.authResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_authresponse(::pulsar::proto::CommandAuthResponse* authresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete authresponse_;
  }
  if (authresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandAuthResponse>::GetOwningArena(authresponse);
    if (message_arena != submessage_arena) {
      authresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00000008u;
  } else {
    _has_bits_[1] &= ~0x00000008u;
  }
  authresponse_ = authresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.authResponse)
}

// optional .pulsar.proto.CommandAckResponse ackResponse = 38;
inline bool BaseCommand::_internal_has_ackresponse() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || ackresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_ackresponse() const {
  return _internal_has_ackresponse();
}
inline void BaseCommand::clear_ackresponse() {
  if (ackresponse_ != nullptr) ackresponse_->Clear();
  _has_bits_[1] &= ~0x00000010u;
}
inline const ::pulsar::proto::CommandAckResponse& BaseCommand::_internal_ackresponse() const {
  const ::pulsar::proto::CommandAckResponse* p = ackresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAckResponse&>(
      ::pulsar::proto::_CommandAckResponse_default_instance_);
}
inline const ::pulsar::proto::CommandAckResponse& BaseCommand::ackresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.ackResponse)
  return _internal_ackresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_ackresponse(
    ::pulsar::proto::CommandAckResponse* ackresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ackresponse_);
  }
  ackresponse_ = ackresponse;
  if (ackresponse) {
    _has_bits_[1] |= 0x00000010u;
  } else {
    _has_bits_[1] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.ackResponse)
}
inline ::pulsar::proto::CommandAckResponse* BaseCommand::release_ackresponse() {
  _has_bits_[1] &= ~0x00000010u;
  ::pulsar::proto::CommandAckResponse* temp = ackresponse_;
  ackresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandAckResponse* BaseCommand::unsafe_arena_release_ackresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.ackResponse)
  _has_bits_[1] &= ~0x00000010u;
  ::pulsar::proto::CommandAckResponse* temp = ackresponse_;
  ackresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAckResponse* BaseCommand::_internal_mutable_ackresponse() {
  _has_bits_[1] |= 0x00000010u;
  if (ackresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAckResponse>(GetArenaForAllocation());
    ackresponse_ = p;
  }
  return ackresponse_;
}
inline ::pulsar::proto::CommandAckResponse* BaseCommand::mutable_ackresponse() {
  ::pulsar::proto::CommandAckResponse* _msg = _internal_mutable_ackresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.ackResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_ackresponse(::pulsar::proto::CommandAckResponse* ackresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ackresponse_;
  }
  if (ackresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandAckResponse>::GetOwningArena(ackresponse);
    if (message_arena != submessage_arena) {
      ackresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ackresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00000010u;
  } else {
    _has_bits_[1] &= ~0x00000010u;
  }
  ackresponse_ = ackresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.ackResponse)
}

// optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
inline bool BaseCommand::_internal_has_getorcreateschema() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || getorcreateschema_ != nullptr);
  return value;
}
inline bool BaseCommand::has_getorcreateschema() const {
  return _internal_has_getorcreateschema();
}
inline void BaseCommand::clear_getorcreateschema() {
  if (getorcreateschema_ != nullptr) getorcreateschema_->Clear();
  _has_bits_[1] &= ~0x00000020u;
}
inline const ::pulsar::proto::CommandGetOrCreateSchema& BaseCommand::_internal_getorcreateschema() const {
  const ::pulsar::proto::CommandGetOrCreateSchema* p = getorcreateschema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetOrCreateSchema&>(
      ::pulsar::proto::_CommandGetOrCreateSchema_default_instance_);
}
inline const ::pulsar::proto::CommandGetOrCreateSchema& BaseCommand::getorcreateschema() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getOrCreateSchema)
  return _internal_getorcreateschema();
}
inline void BaseCommand::unsafe_arena_set_allocated_getorcreateschema(
    ::pulsar::proto::CommandGetOrCreateSchema* getorcreateschema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getorcreateschema_);
  }
  getorcreateschema_ = getorcreateschema;
  if (getorcreateschema) {
    _has_bits_[1] |= 0x00000020u;
  } else {
    _has_bits_[1] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getOrCreateSchema)
}
inline ::pulsar::proto::CommandGetOrCreateSchema* BaseCommand::release_getorcreateschema() {
  _has_bits_[1] &= ~0x00000020u;
  ::pulsar::proto::CommandGetOrCreateSchema* temp = getorcreateschema_;
  getorcreateschema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandGetOrCreateSchema* BaseCommand::unsafe_arena_release_getorcreateschema() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getOrCreateSchema)
  _has_bits_[1] &= ~0x00000020u;
  ::pulsar::proto::CommandGetOrCreateSchema* temp = getorcreateschema_;
  getorcreateschema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetOrCreateSchema* BaseCommand::_internal_mutable_getorcreateschema() {
  _has_bits_[1] |= 0x00000020u;
  if (getorcreateschema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetOrCreateSchema>(GetArenaForAllocation());
    getorcreateschema_ = p;
  }
  return getorcreateschema_;
}
inline ::pulsar::proto::CommandGetOrCreateSchema* BaseCommand::mutable_getorcreateschema() {
  ::pulsar::proto::CommandGetOrCreateSchema* _msg = _internal_mutable_getorcreateschema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getOrCreateSchema)
  return _msg;
}
inline void BaseCommand::set_allocated_getorcreateschema(::pulsar::proto::CommandGetOrCreateSchema* getorcreateschema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getorcreateschema_;
  }
  if (getorcreateschema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandGetOrCreateSchema>::GetOwningArena(getorcreateschema);
    if (message_arena != submessage_arena) {
      getorcreateschema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getorcreateschema, submessage_arena);
    }
    _has_bits_[1] |= 0x00000020u;
  } else {
    _has_bits_[1] &= ~0x00000020u;
  }
  getorcreateschema_ = getorcreateschema;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getOrCreateSchema)
}

// optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
inline bool BaseCommand::_internal_has_getorcreateschemaresponse() const {
  bool value = (_has_bits_[1] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || getorcreateschemaresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_getorcreateschemaresponse() const {
  return _internal_has_getorcreateschemaresponse();
}
inline void BaseCommand::clear_getorcreateschemaresponse() {
  if (getorcreateschemaresponse_ != nullptr) getorcreateschemaresponse_->Clear();
  _has_bits_[1] &= ~0x00000040u;
}
inline const ::pulsar::proto::CommandGetOrCreateSchemaResponse& BaseCommand::_internal_getorcreateschemaresponse() const {
  const ::pulsar::proto::CommandGetOrCreateSchemaResponse* p = getorcreateschemaresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetOrCreateSchemaResponse&>(
      ::pulsar::proto::_CommandGetOrCreateSchemaResponse_default_instance_);
}
inline const ::pulsar::proto::CommandGetOrCreateSchemaResponse& BaseCommand::getorcreateschemaresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)
  return _internal_getorcreateschemaresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_getorcreateschemaresponse(
    ::pulsar::proto::CommandGetOrCreateSchemaResponse* getorcreateschemaresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getorcreateschemaresponse_);
  }
  getorcreateschemaresponse_ = getorcreateschemaresponse;
  if (getorcreateschemaresponse) {
    _has_bits_[1] |= 0x00000040u;
  } else {
    _has_bits_[1] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)
}
inline ::pulsar::proto::CommandGetOrCreateSchemaResponse* BaseCommand::release_getorcreateschemaresponse() {
  _has_bits_[1] &= ~0x00000040u;
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* temp = getorcreateschemaresponse_;
  getorcreateschemaresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandGetOrCreateSchemaResponse* BaseCommand::unsafe_arena_release_getorcreateschemaresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)
  _has_bits_[1] &= ~0x00000040u;
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* temp = getorcreateschemaresponse_;
  getorcreateschemaresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetOrCreateSchemaResponse* BaseCommand::_internal_mutable_getorcreateschemaresponse() {
  _has_bits_[1] |= 0x00000040u;
  if (getorcreateschemaresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetOrCreateSchemaResponse>(GetArenaForAllocation());
    getorcreateschemaresponse_ = p;
  }
  return getorcreateschemaresponse_;
}
inline ::pulsar::proto::CommandGetOrCreateSchemaResponse* BaseCommand::mutable_getorcreateschemaresponse() {
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* _msg = _internal_mutable_getorcreateschemaresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_getorcreateschemaresponse(::pulsar::proto::CommandGetOrCreateSchemaResponse* getorcreateschemaresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getorcreateschemaresponse_;
  }
  if (getorcreateschemaresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandGetOrCreateSchemaResponse>::GetOwningArena(getorcreateschemaresponse);
    if (message_arena != submessage_arena) {
      getorcreateschemaresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getorcreateschemaresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00000040u;
  } else {
    _has_bits_[1] &= ~0x00000040u;
  }
  getorcreateschemaresponse_ = getorcreateschemaresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)
}

// optional .pulsar.proto.CommandNewTxn newTxn = 50;
inline bool BaseCommand::_internal_has_newtxn() const {
  bool value = (_has_bits_[1] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || newtxn_ != nullptr);
  return value;
}
inline bool BaseCommand::has_newtxn() const {
  return _internal_has_newtxn();
}
inline void BaseCommand::clear_newtxn() {
  if (newtxn_ != nullptr) newtxn_->Clear();
  _has_bits_[1] &= ~0x00000080u;
}
inline const ::pulsar::proto::CommandNewTxn& BaseCommand::_internal_newtxn() const {
  const ::pulsar::proto::CommandNewTxn* p = newtxn_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandNewTxn&>(
      ::pulsar::proto::_CommandNewTxn_default_instance_);
}
inline const ::pulsar::proto::CommandNewTxn& BaseCommand::newtxn() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.newTxn)
  return _internal_newtxn();
}
inline void BaseCommand::unsafe_arena_set_allocated_newtxn(
    ::pulsar::proto::CommandNewTxn* newtxn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newtxn_);
  }
  newtxn_ = newtxn;
  if (newtxn) {
    _has_bits_[1] |= 0x00000080u;
  } else {
    _has_bits_[1] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.newTxn)
}
inline ::pulsar::proto::CommandNewTxn* BaseCommand::release_newtxn() {
  _has_bits_[1] &= ~0x00000080u;
  ::pulsar::proto::CommandNewTxn* temp = newtxn_;
  newtxn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandNewTxn* BaseCommand::unsafe_arena_release_newtxn() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.newTxn)
  _has_bits_[1] &= ~0x00000080u;
  ::pulsar::proto::CommandNewTxn* temp = newtxn_;
  newtxn_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandNewTxn* BaseCommand::_internal_mutable_newtxn() {
  _has_bits_[1] |= 0x00000080u;
  if (newtxn_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandNewTxn>(GetArenaForAllocation());
    newtxn_ = p;
  }
  return newtxn_;
}
inline ::pulsar::proto::CommandNewTxn* BaseCommand::mutable_newtxn() {
  ::pulsar::proto::CommandNewTxn* _msg = _internal_mutable_newtxn();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.newTxn)
  return _msg;
}
inline void BaseCommand::set_allocated_newtxn(::pulsar::proto::CommandNewTxn* newtxn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete newtxn_;
  }
  if (newtxn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandNewTxn>::GetOwningArena(newtxn);
    if (message_arena != submessage_arena) {
      newtxn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newtxn, submessage_arena);
    }
    _has_bits_[1] |= 0x00000080u;
  } else {
    _has_bits_[1] &= ~0x00000080u;
  }
  newtxn_ = newtxn;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.newTxn)
}

// optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
inline bool BaseCommand::_internal_has_newtxnresponse() const {
  bool value = (_has_bits_[1] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || newtxnresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_newtxnresponse() const {
  return _internal_has_newtxnresponse();
}
inline void BaseCommand::clear_newtxnresponse() {
  if (newtxnresponse_ != nullptr) newtxnresponse_->Clear();
  _has_bits_[1] &= ~0x00000100u;
}
inline const ::pulsar::proto::CommandNewTxnResponse& BaseCommand::_internal_newtxnresponse() const {
  const ::pulsar::proto::CommandNewTxnResponse* p = newtxnresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandNewTxnResponse&>(
      ::pulsar::proto::_CommandNewTxnResponse_default_instance_);
}
inline const ::pulsar::proto::CommandNewTxnResponse& BaseCommand::newtxnresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.newTxnResponse)
  return _internal_newtxnresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_newtxnresponse(
    ::pulsar::proto::CommandNewTxnResponse* newtxnresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newtxnresponse_);
  }
  newtxnresponse_ = newtxnresponse;
  if (newtxnresponse) {
    _has_bits_[1] |= 0x00000100u;
  } else {
    _has_bits_[1] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.newTxnResponse)
}
inline ::pulsar::proto::CommandNewTxnResponse* BaseCommand::release_newtxnresponse() {
  _has_bits_[1] &= ~0x00000100u;
  ::pulsar::proto::CommandNewTxnResponse* temp = newtxnresponse_;
  newtxnresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandNewTxnResponse* BaseCommand::unsafe_arena_release_newtxnresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.newTxnResponse)
  _has_bits_[1] &= ~0x00000100u;
  ::pulsar::proto::CommandNewTxnResponse* temp = newtxnresponse_;
  newtxnresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandNewTxnResponse* BaseCommand::_internal_mutable_newtxnresponse() {
  _has_bits_[1] |= 0x00000100u;
  if (newtxnresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandNewTxnResponse>(GetArenaForAllocation());
    newtxnresponse_ = p;
  }
  return newtxnresponse_;
}
inline ::pulsar::proto::CommandNewTxnResponse* BaseCommand::mutable_newtxnresponse() {
  ::pulsar::proto::CommandNewTxnResponse* _msg = _internal_mutable_newtxnresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.newTxnResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_newtxnresponse(::pulsar::proto::CommandNewTxnResponse* newtxnresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete newtxnresponse_;
  }
  if (newtxnresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandNewTxnResponse>::GetOwningArena(newtxnresponse);
    if (message_arena != submessage_arena) {
      newtxnresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newtxnresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00000100u;
  } else {
    _has_bits_[1] &= ~0x00000100u;
  }
  newtxnresponse_ = newtxnresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.newTxnResponse)
}

// optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
inline bool BaseCommand::_internal_has_addpartitiontotxn() const {
  bool value = (_has_bits_[1] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || addpartitiontotxn_ != nullptr);
  return value;
}
inline bool BaseCommand::has_addpartitiontotxn() const {
  return _internal_has_addpartitiontotxn();
}
inline void BaseCommand::clear_addpartitiontotxn() {
  if (addpartitiontotxn_ != nullptr) addpartitiontotxn_->Clear();
  _has_bits_[1] &= ~0x00000200u;
}
inline const ::pulsar::proto::CommandAddPartitionToTxn& BaseCommand::_internal_addpartitiontotxn() const {
  const ::pulsar::proto::CommandAddPartitionToTxn* p = addpartitiontotxn_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAddPartitionToTxn&>(
      ::pulsar::proto::_CommandAddPartitionToTxn_default_instance_);
}
inline const ::pulsar::proto::CommandAddPartitionToTxn& BaseCommand::addpartitiontotxn() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.addPartitionToTxn)
  return _internal_addpartitiontotxn();
}
inline void BaseCommand::unsafe_arena_set_allocated_addpartitiontotxn(
    ::pulsar::proto::CommandAddPartitionToTxn* addpartitiontotxn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addpartitiontotxn_);
  }
  addpartitiontotxn_ = addpartitiontotxn;
  if (addpartitiontotxn) {
    _has_bits_[1] |= 0x00000200u;
  } else {
    _has_bits_[1] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.addPartitionToTxn)
}
inline ::pulsar::proto::CommandAddPartitionToTxn* BaseCommand::release_addpartitiontotxn() {
  _has_bits_[1] &= ~0x00000200u;
  ::pulsar::proto::CommandAddPartitionToTxn* temp = addpartitiontotxn_;
  addpartitiontotxn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandAddPartitionToTxn* BaseCommand::unsafe_arena_release_addpartitiontotxn() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.addPartitionToTxn)
  _has_bits_[1] &= ~0x00000200u;
  ::pulsar::proto::CommandAddPartitionToTxn* temp = addpartitiontotxn_;
  addpartitiontotxn_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAddPartitionToTxn* BaseCommand::_internal_mutable_addpartitiontotxn() {
  _has_bits_[1] |= 0x00000200u;
  if (addpartitiontotxn_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAddPartitionToTxn>(GetArenaForAllocation());
    addpartitiontotxn_ = p;
  }
  return addpartitiontotxn_;
}
inline ::pulsar::proto::CommandAddPartitionToTxn* BaseCommand::mutable_addpartitiontotxn() {
  ::pulsar::proto::CommandAddPartitionToTxn* _msg = _internal_mutable_addpartitiontotxn();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.addPartitionToTxn)
  return _msg;
}
inline void BaseCommand::set_allocated_addpartitiontotxn(::pulsar::proto::CommandAddPartitionToTxn* addpartitiontotxn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addpartitiontotxn_;
  }
  if (addpartitiontotxn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandAddPartitionToTxn>::GetOwningArena(addpartitiontotxn);
    if (message_arena != submessage_arena) {
      addpartitiontotxn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addpartitiontotxn, submessage_arena);
    }
    _has_bits_[1] |= 0x00000200u;
  } else {
    _has_bits_[1] &= ~0x00000200u;
  }
  addpartitiontotxn_ = addpartitiontotxn;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.addPartitionToTxn)
}

// optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
inline bool BaseCommand::_internal_has_addpartitiontotxnresponse() const {
  bool value = (_has_bits_[1] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || addpartitiontotxnresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_addpartitiontotxnresponse() const {
  return _internal_has_addpartitiontotxnresponse();
}
inline void BaseCommand::clear_addpartitiontotxnresponse() {
  if (addpartitiontotxnresponse_ != nullptr) addpartitiontotxnresponse_->Clear();
  _has_bits_[1] &= ~0x00000400u;
}
inline const ::pulsar::proto::CommandAddPartitionToTxnResponse& BaseCommand::_internal_addpartitiontotxnresponse() const {
  const ::pulsar::proto::CommandAddPartitionToTxnResponse* p = addpartitiontotxnresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAddPartitionToTxnResponse&>(
      ::pulsar::proto::_CommandAddPartitionToTxnResponse_default_instance_);
}
inline const ::pulsar::proto::CommandAddPartitionToTxnResponse& BaseCommand::addpartitiontotxnresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.addPartitionToTxnResponse)
  return _internal_addpartitiontotxnresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_addpartitiontotxnresponse(
    ::pulsar::proto::CommandAddPartitionToTxnResponse* addpartitiontotxnresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addpartitiontotxnresponse_);
  }
  addpartitiontotxnresponse_ = addpartitiontotxnresponse;
  if (addpartitiontotxnresponse) {
    _has_bits_[1] |= 0x00000400u;
  } else {
    _has_bits_[1] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.addPartitionToTxnResponse)
}
inline ::pulsar::proto::CommandAddPartitionToTxnResponse* BaseCommand::release_addpartitiontotxnresponse() {
  _has_bits_[1] &= ~0x00000400u;
  ::pulsar::proto::CommandAddPartitionToTxnResponse* temp = addpartitiontotxnresponse_;
  addpartitiontotxnresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandAddPartitionToTxnResponse* BaseCommand::unsafe_arena_release_addpartitiontotxnresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.addPartitionToTxnResponse)
  _has_bits_[1] &= ~0x00000400u;
  ::pulsar::proto::CommandAddPartitionToTxnResponse* temp = addpartitiontotxnresponse_;
  addpartitiontotxnresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAddPartitionToTxnResponse* BaseCommand::_internal_mutable_addpartitiontotxnresponse() {
  _has_bits_[1] |= 0x00000400u;
  if (addpartitiontotxnresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAddPartitionToTxnResponse>(GetArenaForAllocation());
    addpartitiontotxnresponse_ = p;
  }
  return addpartitiontotxnresponse_;
}
inline ::pulsar::proto::CommandAddPartitionToTxnResponse* BaseCommand::mutable_addpartitiontotxnresponse() {
  ::pulsar::proto::CommandAddPartitionToTxnResponse* _msg = _internal_mutable_addpartitiontotxnresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.addPartitionToTxnResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_addpartitiontotxnresponse(::pulsar::proto::CommandAddPartitionToTxnResponse* addpartitiontotxnresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addpartitiontotxnresponse_;
  }
  if (addpartitiontotxnresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandAddPartitionToTxnResponse>::GetOwningArena(addpartitiontotxnresponse);
    if (message_arena != submessage_arena) {
      addpartitiontotxnresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addpartitiontotxnresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00000400u;
  } else {
    _has_bits_[1] &= ~0x00000400u;
  }
  addpartitiontotxnresponse_ = addpartitiontotxnresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.addPartitionToTxnResponse)
}

// optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
inline bool BaseCommand::_internal_has_addsubscriptiontotxn() const {
  bool value = (_has_bits_[1] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || addsubscriptiontotxn_ != nullptr);
  return value;
}
inline bool BaseCommand::has_addsubscriptiontotxn() const {
  return _internal_has_addsubscriptiontotxn();
}
inline void BaseCommand::clear_addsubscriptiontotxn() {
  if (addsubscriptiontotxn_ != nullptr) addsubscriptiontotxn_->Clear();
  _has_bits_[1] &= ~0x00000800u;
}
inline const ::pulsar::proto::CommandAddSubscriptionToTxn& BaseCommand::_internal_addsubscriptiontotxn() const {
  const ::pulsar::proto::CommandAddSubscriptionToTxn* p = addsubscriptiontotxn_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAddSubscriptionToTxn&>(
      ::pulsar::proto::_CommandAddSubscriptionToTxn_default_instance_);
}
inline const ::pulsar::proto::CommandAddSubscriptionToTxn& BaseCommand::addsubscriptiontotxn() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.addSubscriptionToTxn)
  return _internal_addsubscriptiontotxn();
}
inline void BaseCommand::unsafe_arena_set_allocated_addsubscriptiontotxn(
    ::pulsar::proto::CommandAddSubscriptionToTxn* addsubscriptiontotxn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addsubscriptiontotxn_);
  }
  addsubscriptiontotxn_ = addsubscriptiontotxn;
  if (addsubscriptiontotxn) {
    _has_bits_[1] |= 0x00000800u;
  } else {
    _has_bits_[1] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.addSubscriptionToTxn)
}
inline ::pulsar::proto::CommandAddSubscriptionToTxn* BaseCommand::release_addsubscriptiontotxn() {
  _has_bits_[1] &= ~0x00000800u;
  ::pulsar::proto::CommandAddSubscriptionToTxn* temp = addsubscriptiontotxn_;
  addsubscriptiontotxn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxn* BaseCommand::unsafe_arena_release_addsubscriptiontotxn() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.addSubscriptionToTxn)
  _has_bits_[1] &= ~0x00000800u;
  ::pulsar::proto::CommandAddSubscriptionToTxn* temp = addsubscriptiontotxn_;
  addsubscriptiontotxn_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxn* BaseCommand::_internal_mutable_addsubscriptiontotxn() {
  _has_bits_[1] |= 0x00000800u;
  if (addsubscriptiontotxn_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAddSubscriptionToTxn>(GetArenaForAllocation());
    addsubscriptiontotxn_ = p;
  }
  return addsubscriptiontotxn_;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxn* BaseCommand::mutable_addsubscriptiontotxn() {
  ::pulsar::proto::CommandAddSubscriptionToTxn* _msg = _internal_mutable_addsubscriptiontotxn();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.addSubscriptionToTxn)
  return _msg;
}
inline void BaseCommand::set_allocated_addsubscriptiontotxn(::pulsar::proto::CommandAddSubscriptionToTxn* addsubscriptiontotxn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addsubscriptiontotxn_;
  }
  if (addsubscriptiontotxn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandAddSubscriptionToTxn>::GetOwningArena(addsubscriptiontotxn);
    if (message_arena != submessage_arena) {
      addsubscriptiontotxn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addsubscriptiontotxn, submessage_arena);
    }
    _has_bits_[1] |= 0x00000800u;
  } else {
    _has_bits_[1] &= ~0x00000800u;
  }
  addsubscriptiontotxn_ = addsubscriptiontotxn;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.addSubscriptionToTxn)
}

// optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
inline bool BaseCommand::_internal_has_addsubscriptiontotxnresponse() const {
  bool value = (_has_bits_[1] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || addsubscriptiontotxnresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_addsubscriptiontotxnresponse() const {
  return _internal_has_addsubscriptiontotxnresponse();
}
inline void BaseCommand::clear_addsubscriptiontotxnresponse() {
  if (addsubscriptiontotxnresponse_ != nullptr) addsubscriptiontotxnresponse_->Clear();
  _has_bits_[1] &= ~0x00001000u;
}
inline const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& BaseCommand::_internal_addsubscriptiontotxnresponse() const {
  const ::pulsar::proto::CommandAddSubscriptionToTxnResponse* p = addsubscriptiontotxnresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAddSubscriptionToTxnResponse&>(
      ::pulsar::proto::_CommandAddSubscriptionToTxnResponse_default_instance_);
}
inline const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& BaseCommand::addsubscriptiontotxnresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)
  return _internal_addsubscriptiontotxnresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_addsubscriptiontotxnresponse(
    ::pulsar::proto::CommandAddSubscriptionToTxnResponse* addsubscriptiontotxnresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addsubscriptiontotxnresponse_);
  }
  addsubscriptiontotxnresponse_ = addsubscriptiontotxnresponse;
  if (addsubscriptiontotxnresponse) {
    _has_bits_[1] |= 0x00001000u;
  } else {
    _has_bits_[1] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)
}
inline ::pulsar::proto::CommandAddSubscriptionToTxnResponse* BaseCommand::release_addsubscriptiontotxnresponse() {
  _has_bits_[1] &= ~0x00001000u;
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* temp = addsubscriptiontotxnresponse_;
  addsubscriptiontotxnresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxnResponse* BaseCommand::unsafe_arena_release_addsubscriptiontotxnresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)
  _has_bits_[1] &= ~0x00001000u;
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* temp = addsubscriptiontotxnresponse_;
  addsubscriptiontotxnresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxnResponse* BaseCommand::_internal_mutable_addsubscriptiontotxnresponse() {
  _has_bits_[1] |= 0x00001000u;
  if (addsubscriptiontotxnresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAddSubscriptionToTxnResponse>(GetArenaForAllocation());
    addsubscriptiontotxnresponse_ = p;
  }
  return addsubscriptiontotxnresponse_;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxnResponse* BaseCommand::mutable_addsubscriptiontotxnresponse() {
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* _msg = _internal_mutable_addsubscriptiontotxnresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_addsubscriptiontotxnresponse(::pulsar::proto::CommandAddSubscriptionToTxnResponse* addsubscriptiontotxnresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addsubscriptiontotxnresponse_;
  }
  if (addsubscriptiontotxnresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandAddSubscriptionToTxnResponse>::GetOwningArena(addsubscriptiontotxnresponse);
    if (message_arena != submessage_arena) {
      addsubscriptiontotxnresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addsubscriptiontotxnresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00001000u;
  } else {
    _has_bits_[1] &= ~0x00001000u;
  }
  addsubscriptiontotxnresponse_ = addsubscriptiontotxnresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)
}

// optional .pulsar.proto.CommandEndTxn endTxn = 56;
inline bool BaseCommand::_internal_has_endtxn() const {
  bool value = (_has_bits_[1] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || endtxn_ != nullptr);
  return value;
}
inline bool BaseCommand::has_endtxn() const {
  return _internal_has_endtxn();
}
inline void BaseCommand::clear_endtxn() {
  if (endtxn_ != nullptr) endtxn_->Clear();
  _has_bits_[1] &= ~0x00002000u;
}
inline const ::pulsar::proto::CommandEndTxn& BaseCommand::_internal_endtxn() const {
  const ::pulsar::proto::CommandEndTxn* p = endtxn_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxn&>(
      ::pulsar::proto::_CommandEndTxn_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxn& BaseCommand::endtxn() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxn)
  return _internal_endtxn();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxn(
    ::pulsar::proto::CommandEndTxn* endtxn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtxn_);
  }
  endtxn_ = endtxn;
  if (endtxn) {
    _has_bits_[1] |= 0x00002000u;
  } else {
    _has_bits_[1] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxn)
}
inline ::pulsar::proto::CommandEndTxn* BaseCommand::release_endtxn() {
  _has_bits_[1] &= ~0x00002000u;
  ::pulsar::proto::CommandEndTxn* temp = endtxn_;
  endtxn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandEndTxn* BaseCommand::unsafe_arena_release_endtxn() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxn)
  _has_bits_[1] &= ~0x00002000u;
  ::pulsar::proto::CommandEndTxn* temp = endtxn_;
  endtxn_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxn* BaseCommand::_internal_mutable_endtxn() {
  _has_bits_[1] |= 0x00002000u;
  if (endtxn_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxn>(GetArenaForAllocation());
    endtxn_ = p;
  }
  return endtxn_;
}
inline ::pulsar::proto::CommandEndTxn* BaseCommand::mutable_endtxn() {
  ::pulsar::proto::CommandEndTxn* _msg = _internal_mutable_endtxn();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxn)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxn(::pulsar::proto::CommandEndTxn* endtxn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endtxn_;
  }
  if (endtxn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandEndTxn>::GetOwningArena(endtxn);
    if (message_arena != submessage_arena) {
      endtxn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtxn, submessage_arena);
    }
    _has_bits_[1] |= 0x00002000u;
  } else {
    _has_bits_[1] &= ~0x00002000u;
  }
  endtxn_ = endtxn;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxn)
}

// optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
inline bool BaseCommand::_internal_has_endtxnresponse() const {
  bool value = (_has_bits_[1] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || endtxnresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_endtxnresponse() const {
  return _internal_has_endtxnresponse();
}
inline void BaseCommand::clear_endtxnresponse() {
  if (endtxnresponse_ != nullptr) endtxnresponse_->Clear();
  _has_bits_[1] &= ~0x00004000u;
}
inline const ::pulsar::proto::CommandEndTxnResponse& BaseCommand::_internal_endtxnresponse() const {
  const ::pulsar::proto::CommandEndTxnResponse* p = endtxnresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnResponse&>(
      ::pulsar::proto::_CommandEndTxnResponse_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnResponse& BaseCommand::endtxnresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnResponse)
  return _internal_endtxnresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnresponse(
    ::pulsar::proto::CommandEndTxnResponse* endtxnresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtxnresponse_);
  }
  endtxnresponse_ = endtxnresponse;
  if (endtxnresponse) {
    _has_bits_[1] |= 0x00004000u;
  } else {
    _has_bits_[1] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnResponse)
}
inline ::pulsar::proto::CommandEndTxnResponse* BaseCommand::release_endtxnresponse() {
  _has_bits_[1] &= ~0x00004000u;
  ::pulsar::proto::CommandEndTxnResponse* temp = endtxnresponse_;
  endtxnresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandEndTxnResponse* BaseCommand::unsafe_arena_release_endtxnresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnResponse)
  _has_bits_[1] &= ~0x00004000u;
  ::pulsar::proto::CommandEndTxnResponse* temp = endtxnresponse_;
  endtxnresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnResponse* BaseCommand::_internal_mutable_endtxnresponse() {
  _has_bits_[1] |= 0x00004000u;
  if (endtxnresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnResponse>(GetArenaForAllocation());
    endtxnresponse_ = p;
  }
  return endtxnresponse_;
}
inline ::pulsar::proto::CommandEndTxnResponse* BaseCommand::mutable_endtxnresponse() {
  ::pulsar::proto::CommandEndTxnResponse* _msg = _internal_mutable_endtxnresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnresponse(::pulsar::proto::CommandEndTxnResponse* endtxnresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endtxnresponse_;
  }
  if (endtxnresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandEndTxnResponse>::GetOwningArena(endtxnresponse);
    if (message_arena != submessage_arena) {
      endtxnresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtxnresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00004000u;
  } else {
    _has_bits_[1] &= ~0x00004000u;
  }
  endtxnresponse_ = endtxnresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnResponse)
}

// optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
inline bool BaseCommand::_internal_has_endtxnonpartition() const {
  bool value = (_has_bits_[1] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || endtxnonpartition_ != nullptr);
  return value;
}
inline bool BaseCommand::has_endtxnonpartition() const {
  return _internal_has_endtxnonpartition();
}
inline void BaseCommand::clear_endtxnonpartition() {
  if (endtxnonpartition_ != nullptr) endtxnonpartition_->Clear();
  _has_bits_[1] &= ~0x00008000u;
}
inline const ::pulsar::proto::CommandEndTxnOnPartition& BaseCommand::_internal_endtxnonpartition() const {
  const ::pulsar::proto::CommandEndTxnOnPartition* p = endtxnonpartition_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnOnPartition&>(
      ::pulsar::proto::_CommandEndTxnOnPartition_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnOnPartition& BaseCommand::endtxnonpartition() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnOnPartition)
  return _internal_endtxnonpartition();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnonpartition(
    ::pulsar::proto::CommandEndTxnOnPartition* endtxnonpartition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtxnonpartition_);
  }
  endtxnonpartition_ = endtxnonpartition;
  if (endtxnonpartition) {
    _has_bits_[1] |= 0x00008000u;
  } else {
    _has_bits_[1] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnOnPartition)
}
inline ::pulsar::proto::CommandEndTxnOnPartition* BaseCommand::release_endtxnonpartition() {
  _has_bits_[1] &= ~0x00008000u;
  ::pulsar::proto::CommandEndTxnOnPartition* temp = endtxnonpartition_;
  endtxnonpartition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnPartition* BaseCommand::unsafe_arena_release_endtxnonpartition() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnOnPartition)
  _has_bits_[1] &= ~0x00008000u;
  ::pulsar::proto::CommandEndTxnOnPartition* temp = endtxnonpartition_;
  endtxnonpartition_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnPartition* BaseCommand::_internal_mutable_endtxnonpartition() {
  _has_bits_[1] |= 0x00008000u;
  if (endtxnonpartition_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnPartition>(GetArenaForAllocation());
    endtxnonpartition_ = p;
  }
  return endtxnonpartition_;
}
inline ::pulsar::proto::CommandEndTxnOnPartition* BaseCommand::mutable_endtxnonpartition() {
  ::pulsar::proto::CommandEndTxnOnPartition* _msg = _internal_mutable_endtxnonpartition();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnOnPartition)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnonpartition(::pulsar::proto::CommandEndTxnOnPartition* endtxnonpartition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endtxnonpartition_;
  }
  if (endtxnonpartition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandEndTxnOnPartition>::GetOwningArena(endtxnonpartition);
    if (message_arena != submessage_arena) {
      endtxnonpartition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtxnonpartition, submessage_arena);
    }
    _has_bits_[1] |= 0x00008000u;
  } else {
    _has_bits_[1] &= ~0x00008000u;
  }
  endtxnonpartition_ = endtxnonpartition;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnOnPartition)
}

// optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
inline bool BaseCommand::_internal_has_endtxnonpartitionresponse() const {
  bool value = (_has_bits_[1] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || endtxnonpartitionresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_endtxnonpartitionresponse() const {
  return _internal_has_endtxnonpartitionresponse();
}
inline void BaseCommand::clear_endtxnonpartitionresponse() {
  if (endtxnonpartitionresponse_ != nullptr) endtxnonpartitionresponse_->Clear();
  _has_bits_[1] &= ~0x00010000u;
}
inline const ::pulsar::proto::CommandEndTxnOnPartitionResponse& BaseCommand::_internal_endtxnonpartitionresponse() const {
  const ::pulsar::proto::CommandEndTxnOnPartitionResponse* p = endtxnonpartitionresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnOnPartitionResponse&>(
      ::pulsar::proto::_CommandEndTxnOnPartitionResponse_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnOnPartitionResponse& BaseCommand::endtxnonpartitionresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)
  return _internal_endtxnonpartitionresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnonpartitionresponse(
    ::pulsar::proto::CommandEndTxnOnPartitionResponse* endtxnonpartitionresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtxnonpartitionresponse_);
  }
  endtxnonpartitionresponse_ = endtxnonpartitionresponse;
  if (endtxnonpartitionresponse) {
    _has_bits_[1] |= 0x00010000u;
  } else {
    _has_bits_[1] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)
}
inline ::pulsar::proto::CommandEndTxnOnPartitionResponse* BaseCommand::release_endtxnonpartitionresponse() {
  _has_bits_[1] &= ~0x00010000u;
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* temp = endtxnonpartitionresponse_;
  endtxnonpartitionresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnPartitionResponse* BaseCommand::unsafe_arena_release_endtxnonpartitionresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)
  _has_bits_[1] &= ~0x00010000u;
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* temp = endtxnonpartitionresponse_;
  endtxnonpartitionresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnPartitionResponse* BaseCommand::_internal_mutable_endtxnonpartitionresponse() {
  _has_bits_[1] |= 0x00010000u;
  if (endtxnonpartitionresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnPartitionResponse>(GetArenaForAllocation());
    endtxnonpartitionresponse_ = p;
  }
  return endtxnonpartitionresponse_;
}
inline ::pulsar::proto::CommandEndTxnOnPartitionResponse* BaseCommand::mutable_endtxnonpartitionresponse() {
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* _msg = _internal_mutable_endtxnonpartitionresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnonpartitionresponse(::pulsar::proto::CommandEndTxnOnPartitionResponse* endtxnonpartitionresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endtxnonpartitionresponse_;
  }
  if (endtxnonpartitionresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandEndTxnOnPartitionResponse>::GetOwningArena(endtxnonpartitionresponse);
    if (message_arena != submessage_arena) {
      endtxnonpartitionresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtxnonpartitionresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00010000u;
  } else {
    _has_bits_[1] &= ~0x00010000u;
  }
  endtxnonpartitionresponse_ = endtxnonpartitionresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)
}

// optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
inline bool BaseCommand::_internal_has_endtxnonsubscription() const {
  bool value = (_has_bits_[1] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || endtxnonsubscription_ != nullptr);
  return value;
}
inline bool BaseCommand::has_endtxnonsubscription() const {
  return _internal_has_endtxnonsubscription();
}
inline void BaseCommand::clear_endtxnonsubscription() {
  if (endtxnonsubscription_ != nullptr) endtxnonsubscription_->Clear();
  _has_bits_[1] &= ~0x00020000u;
}
inline const ::pulsar::proto::CommandEndTxnOnSubscription& BaseCommand::_internal_endtxnonsubscription() const {
  const ::pulsar::proto::CommandEndTxnOnSubscription* p = endtxnonsubscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnOnSubscription&>(
      ::pulsar::proto::_CommandEndTxnOnSubscription_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnOnSubscription& BaseCommand::endtxnonsubscription() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnOnSubscription)
  return _internal_endtxnonsubscription();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnonsubscription(
    ::pulsar::proto::CommandEndTxnOnSubscription* endtxnonsubscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtxnonsubscription_);
  }
  endtxnonsubscription_ = endtxnonsubscription;
  if (endtxnonsubscription) {
    _has_bits_[1] |= 0x00020000u;
  } else {
    _has_bits_[1] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnOnSubscription)
}
inline ::pulsar::proto::CommandEndTxnOnSubscription* BaseCommand::release_endtxnonsubscription() {
  _has_bits_[1] &= ~0x00020000u;
  ::pulsar::proto::CommandEndTxnOnSubscription* temp = endtxnonsubscription_;
  endtxnonsubscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnSubscription* BaseCommand::unsafe_arena_release_endtxnonsubscription() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnOnSubscription)
  _has_bits_[1] &= ~0x00020000u;
  ::pulsar::proto::CommandEndTxnOnSubscription* temp = endtxnonsubscription_;
  endtxnonsubscription_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnSubscription* BaseCommand::_internal_mutable_endtxnonsubscription() {
  _has_bits_[1] |= 0x00020000u;
  if (endtxnonsubscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnSubscription>(GetArenaForAllocation());
    endtxnonsubscription_ = p;
  }
  return endtxnonsubscription_;
}
inline ::pulsar::proto::CommandEndTxnOnSubscription* BaseCommand::mutable_endtxnonsubscription() {
  ::pulsar::proto::CommandEndTxnOnSubscription* _msg = _internal_mutable_endtxnonsubscription();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnOnSubscription)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnonsubscription(::pulsar::proto::CommandEndTxnOnSubscription* endtxnonsubscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endtxnonsubscription_;
  }
  if (endtxnonsubscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandEndTxnOnSubscription>::GetOwningArena(endtxnonsubscription);
    if (message_arena != submessage_arena) {
      endtxnonsubscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtxnonsubscription, submessage_arena);
    }
    _has_bits_[1] |= 0x00020000u;
  } else {
    _has_bits_[1] &= ~0x00020000u;
  }
  endtxnonsubscription_ = endtxnonsubscription;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnOnSubscription)
}

// optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
inline bool BaseCommand::_internal_has_endtxnonsubscriptionresponse() const {
  bool value = (_has_bits_[1] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || endtxnonsubscriptionresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_endtxnonsubscriptionresponse() const {
  return _internal_has_endtxnonsubscriptionresponse();
}
inline void BaseCommand::clear_endtxnonsubscriptionresponse() {
  if (endtxnonsubscriptionresponse_ != nullptr) endtxnonsubscriptionresponse_->Clear();
  _has_bits_[1] &= ~0x00040000u;
}
inline const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& BaseCommand::_internal_endtxnonsubscriptionresponse() const {
  const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* p = endtxnonsubscriptionresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse&>(
      ::pulsar::proto::_CommandEndTxnOnSubscriptionResponse_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& BaseCommand::endtxnonsubscriptionresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)
  return _internal_endtxnonsubscriptionresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnonsubscriptionresponse(
    ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* endtxnonsubscriptionresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtxnonsubscriptionresponse_);
  }
  endtxnonsubscriptionresponse_ = endtxnonsubscriptionresponse;
  if (endtxnonsubscriptionresponse) {
    _has_bits_[1] |= 0x00040000u;
  } else {
    _has_bits_[1] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)
}
inline ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* BaseCommand::release_endtxnonsubscriptionresponse() {
  _has_bits_[1] &= ~0x00040000u;
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* temp = endtxnonsubscriptionresponse_;
  endtxnonsubscriptionresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* BaseCommand::unsafe_arena_release_endtxnonsubscriptionresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)
  _has_bits_[1] &= ~0x00040000u;
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* temp = endtxnonsubscriptionresponse_;
  endtxnonsubscriptionresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* BaseCommand::_internal_mutable_endtxnonsubscriptionresponse() {
  _has_bits_[1] |= 0x00040000u;
  if (endtxnonsubscriptionresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnSubscriptionResponse>(GetArenaForAllocation());
    endtxnonsubscriptionresponse_ = p;
  }
  return endtxnonsubscriptionresponse_;
}
inline ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* BaseCommand::mutable_endtxnonsubscriptionresponse() {
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* _msg = _internal_mutable_endtxnonsubscriptionresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnonsubscriptionresponse(::pulsar::proto::CommandEndTxnOnSubscriptionResponse* endtxnonsubscriptionresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endtxnonsubscriptionresponse_;
  }
  if (endtxnonsubscriptionresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandEndTxnOnSubscriptionResponse>::GetOwningArena(endtxnonsubscriptionresponse);
    if (message_arena != submessage_arena) {
      endtxnonsubscriptionresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtxnonsubscriptionresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00040000u;
  } else {
    _has_bits_[1] &= ~0x00040000u;
  }
  endtxnonsubscriptionresponse_ = endtxnonsubscriptionresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)
}

// optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
inline bool BaseCommand::_internal_has_tcclientconnectrequest() const {
  bool value = (_has_bits_[1] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || tcclientconnectrequest_ != nullptr);
  return value;
}
inline bool BaseCommand::has_tcclientconnectrequest() const {
  return _internal_has_tcclientconnectrequest();
}
inline void BaseCommand::clear_tcclientconnectrequest() {
  if (tcclientconnectrequest_ != nullptr) tcclientconnectrequest_->Clear();
  _has_bits_[1] &= ~0x00080000u;
}
inline const ::pulsar::proto::CommandTcClientConnectRequest& BaseCommand::_internal_tcclientconnectrequest() const {
  const ::pulsar::proto::CommandTcClientConnectRequest* p = tcclientconnectrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandTcClientConnectRequest&>(
      ::pulsar::proto::_CommandTcClientConnectRequest_default_instance_);
}
inline const ::pulsar::proto::CommandTcClientConnectRequest& BaseCommand::tcclientconnectrequest() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.tcClientConnectRequest)
  return _internal_tcclientconnectrequest();
}
inline void BaseCommand::unsafe_arena_set_allocated_tcclientconnectrequest(
    ::pulsar::proto::CommandTcClientConnectRequest* tcclientconnectrequest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tcclientconnectrequest_);
  }
  tcclientconnectrequest_ = tcclientconnectrequest;
  if (tcclientconnectrequest) {
    _has_bits_[1] |= 0x00080000u;
  } else {
    _has_bits_[1] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.tcClientConnectRequest)
}
inline ::pulsar::proto::CommandTcClientConnectRequest* BaseCommand::release_tcclientconnectrequest() {
  _has_bits_[1] &= ~0x00080000u;
  ::pulsar::proto::CommandTcClientConnectRequest* temp = tcclientconnectrequest_;
  tcclientconnectrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandTcClientConnectRequest* BaseCommand::unsafe_arena_release_tcclientconnectrequest() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.tcClientConnectRequest)
  _has_bits_[1] &= ~0x00080000u;
  ::pulsar::proto::CommandTcClientConnectRequest* temp = tcclientconnectrequest_;
  tcclientconnectrequest_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandTcClientConnectRequest* BaseCommand::_internal_mutable_tcclientconnectrequest() {
  _has_bits_[1] |= 0x00080000u;
  if (tcclientconnectrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandTcClientConnectRequest>(GetArenaForAllocation());
    tcclientconnectrequest_ = p;
  }
  return tcclientconnectrequest_;
}
inline ::pulsar::proto::CommandTcClientConnectRequest* BaseCommand::mutable_tcclientconnectrequest() {
  ::pulsar::proto::CommandTcClientConnectRequest* _msg = _internal_mutable_tcclientconnectrequest();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.tcClientConnectRequest)
  return _msg;
}
inline void BaseCommand::set_allocated_tcclientconnectrequest(::pulsar::proto::CommandTcClientConnectRequest* tcclientconnectrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tcclientconnectrequest_;
  }
  if (tcclientconnectrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandTcClientConnectRequest>::GetOwningArena(tcclientconnectrequest);
    if (message_arena != submessage_arena) {
      tcclientconnectrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tcclientconnectrequest, submessage_arena);
    }
    _has_bits_[1] |= 0x00080000u;
  } else {
    _has_bits_[1] &= ~0x00080000u;
  }
  tcclientconnectrequest_ = tcclientconnectrequest;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.tcClientConnectRequest)
}

// optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
inline bool BaseCommand::_internal_has_tcclientconnectresponse() const {
  bool value = (_has_bits_[1] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || tcclientconnectresponse_ != nullptr);
  return value;
}
inline bool BaseCommand::has_tcclientconnectresponse() const {
  return _internal_has_tcclientconnectresponse();
}
inline void BaseCommand::clear_tcclientconnectresponse() {
  if (tcclientconnectresponse_ != nullptr) tcclientconnectresponse_->Clear();
  _has_bits_[1] &= ~0x00100000u;
}
inline const ::pulsar::proto::CommandTcClientConnectResponse& BaseCommand::_internal_tcclientconnectresponse() const {
  const ::pulsar::proto::CommandTcClientConnectResponse* p = tcclientconnectresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandTcClientConnectResponse&>(
      ::pulsar::proto::_CommandTcClientConnectResponse_default_instance_);
}
inline const ::pulsar::proto::CommandTcClientConnectResponse& BaseCommand::tcclientconnectresponse() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.tcClientConnectResponse)
  return _internal_tcclientconnectresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_tcclientconnectresponse(
    ::pulsar::proto::CommandTcClientConnectResponse* tcclientconnectresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tcclientconnectresponse_);
  }
  tcclientconnectresponse_ = tcclientconnectresponse;
  if (tcclientconnectresponse) {
    _has_bits_[1] |= 0x00100000u;
  } else {
    _has_bits_[1] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.tcClientConnectResponse)
}
inline ::pulsar::proto::CommandTcClientConnectResponse* BaseCommand::release_tcclientconnectresponse() {
  _has_bits_[1] &= ~0x00100000u;
  ::pulsar::proto::CommandTcClientConnectResponse* temp = tcclientconnectresponse_;
  tcclientconnectresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandTcClientConnectResponse* BaseCommand::unsafe_arena_release_tcclientconnectresponse() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.tcClientConnectResponse)
  _has_bits_[1] &= ~0x00100000u;
  ::pulsar::proto::CommandTcClientConnectResponse* temp = tcclientconnectresponse_;
  tcclientconnectresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandTcClientConnectResponse* BaseCommand::_internal_mutable_tcclientconnectresponse() {
  _has_bits_[1] |= 0x00100000u;
  if (tcclientconnectresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandTcClientConnectResponse>(GetArenaForAllocation());
    tcclientconnectresponse_ = p;
  }
  return tcclientconnectresponse_;
}
inline ::pulsar::proto::CommandTcClientConnectResponse* BaseCommand::mutable_tcclientconnectresponse() {
  ::pulsar::proto::CommandTcClientConnectResponse* _msg = _internal_mutable_tcclientconnectresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.tcClientConnectResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_tcclientconnectresponse(::pulsar::proto::CommandTcClientConnectResponse* tcclientconnectresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tcclientconnectresponse_;
  }
  if (tcclientconnectresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandTcClientConnectResponse>::GetOwningArena(tcclientconnectresponse);
    if (message_arena != submessage_arena) {
      tcclientconnectresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tcclientconnectresponse, submessage_arena);
    }
    _has_bits_[1] |= 0x00100000u;
  } else {
    _has_bits_[1] &= ~0x00100000u;
  }
  tcclientconnectresponse_ = tcclientconnectresponse;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.tcClientConnectResponse)
}

// optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
inline bool BaseCommand::_internal_has_watchtopiclist() const {
  bool value = (_has_bits_[1] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || watchtopiclist_ != nullptr);
  return value;
}
inline bool BaseCommand::has_watchtopiclist() const {
  return _internal_has_watchtopiclist();
}
inline void BaseCommand::clear_watchtopiclist() {
  if (watchtopiclist_ != nullptr) watchtopiclist_->Clear();
  _has_bits_[1] &= ~0x00200000u;
}
inline const ::pulsar::proto::CommandWatchTopicList& BaseCommand::_internal_watchtopiclist() const {
  const ::pulsar::proto::CommandWatchTopicList* p = watchtopiclist_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandWatchTopicList&>(
      ::pulsar::proto::_CommandWatchTopicList_default_instance_);
}
inline const ::pulsar::proto::CommandWatchTopicList& BaseCommand::watchtopiclist() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.watchTopicList)
  return _internal_watchtopiclist();
}
inline void BaseCommand::unsafe_arena_set_allocated_watchtopiclist(
    ::pulsar::proto::CommandWatchTopicList* watchtopiclist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(watchtopiclist_);
  }
  watchtopiclist_ = watchtopiclist;
  if (watchtopiclist) {
    _has_bits_[1] |= 0x00200000u;
  } else {
    _has_bits_[1] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.watchTopicList)
}
inline ::pulsar::proto::CommandWatchTopicList* BaseCommand::release_watchtopiclist() {
  _has_bits_[1] &= ~0x00200000u;
  ::pulsar::proto::CommandWatchTopicList* temp = watchtopiclist_;
  watchtopiclist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicList* BaseCommand::unsafe_arena_release_watchtopiclist() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.watchTopicList)
  _has_bits_[1] &= ~0x00200000u;
  ::pulsar::proto::CommandWatchTopicList* temp = watchtopiclist_;
  watchtopiclist_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicList* BaseCommand::_internal_mutable_watchtopiclist() {
  _has_bits_[1] |= 0x00200000u;
  if (watchtopiclist_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandWatchTopicList>(GetArenaForAllocation());
    watchtopiclist_ = p;
  }
  return watchtopiclist_;
}
inline ::pulsar::proto::CommandWatchTopicList* BaseCommand::mutable_watchtopiclist() {
  ::pulsar::proto::CommandWatchTopicList* _msg = _internal_mutable_watchtopiclist();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.watchTopicList)
  return _msg;
}
inline void BaseCommand::set_allocated_watchtopiclist(::pulsar::proto::CommandWatchTopicList* watchtopiclist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete watchtopiclist_;
  }
  if (watchtopiclist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandWatchTopicList>::GetOwningArena(watchtopiclist);
    if (message_arena != submessage_arena) {
      watchtopiclist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, watchtopiclist, submessage_arena);
    }
    _has_bits_[1] |= 0x00200000u;
  } else {
    _has_bits_[1] &= ~0x00200000u;
  }
  watchtopiclist_ = watchtopiclist;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.watchTopicList)
}

// optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
inline bool BaseCommand::_internal_has_watchtopiclistsuccess() const {
  bool value = (_has_bits_[1] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || watchtopiclistsuccess_ != nullptr);
  return value;
}
inline bool BaseCommand::has_watchtopiclistsuccess() const {
  return _internal_has_watchtopiclistsuccess();
}
inline void BaseCommand::clear_watchtopiclistsuccess() {
  if (watchtopiclistsuccess_ != nullptr) watchtopiclistsuccess_->Clear();
  _has_bits_[1] &= ~0x00400000u;
}
inline const ::pulsar::proto::CommandWatchTopicListSuccess& BaseCommand::_internal_watchtopiclistsuccess() const {
  const ::pulsar::proto::CommandWatchTopicListSuccess* p = watchtopiclistsuccess_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandWatchTopicListSuccess&>(
      ::pulsar::proto::_CommandWatchTopicListSuccess_default_instance_);
}
inline const ::pulsar::proto::CommandWatchTopicListSuccess& BaseCommand::watchtopiclistsuccess() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.watchTopicListSuccess)
  return _internal_watchtopiclistsuccess();
}
inline void BaseCommand::unsafe_arena_set_allocated_watchtopiclistsuccess(
    ::pulsar::proto::CommandWatchTopicListSuccess* watchtopiclistsuccess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(watchtopiclistsuccess_);
  }
  watchtopiclistsuccess_ = watchtopiclistsuccess;
  if (watchtopiclistsuccess) {
    _has_bits_[1] |= 0x00400000u;
  } else {
    _has_bits_[1] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.watchTopicListSuccess)
}
inline ::pulsar::proto::CommandWatchTopicListSuccess* BaseCommand::release_watchtopiclistsuccess() {
  _has_bits_[1] &= ~0x00400000u;
  ::pulsar::proto::CommandWatchTopicListSuccess* temp = watchtopiclistsuccess_;
  watchtopiclistsuccess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicListSuccess* BaseCommand::unsafe_arena_release_watchtopiclistsuccess() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.watchTopicListSuccess)
  _has_bits_[1] &= ~0x00400000u;
  ::pulsar::proto::CommandWatchTopicListSuccess* temp = watchtopiclistsuccess_;
  watchtopiclistsuccess_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicListSuccess* BaseCommand::_internal_mutable_watchtopiclistsuccess() {
  _has_bits_[1] |= 0x00400000u;
  if (watchtopiclistsuccess_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandWatchTopicListSuccess>(GetArenaForAllocation());
    watchtopiclistsuccess_ = p;
  }
  return watchtopiclistsuccess_;
}
inline ::pulsar::proto::CommandWatchTopicListSuccess* BaseCommand::mutable_watchtopiclistsuccess() {
  ::pulsar::proto::CommandWatchTopicListSuccess* _msg = _internal_mutable_watchtopiclistsuccess();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.watchTopicListSuccess)
  return _msg;
}
inline void BaseCommand::set_allocated_watchtopiclistsuccess(::pulsar::proto::CommandWatchTopicListSuccess* watchtopiclistsuccess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete watchtopiclistsuccess_;
  }
  if (watchtopiclistsuccess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandWatchTopicListSuccess>::GetOwningArena(watchtopiclistsuccess);
    if (message_arena != submessage_arena) {
      watchtopiclistsuccess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, watchtopiclistsuccess, submessage_arena);
    }
    _has_bits_[1] |= 0x00400000u;
  } else {
    _has_bits_[1] &= ~0x00400000u;
  }
  watchtopiclistsuccess_ = watchtopiclistsuccess;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.watchTopicListSuccess)
}

// optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
inline bool BaseCommand::_internal_has_watchtopicupdate() const {
  bool value = (_has_bits_[1] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || watchtopicupdate_ != nullptr);
  return value;
}
inline bool BaseCommand::has_watchtopicupdate() const {
  return _internal_has_watchtopicupdate();
}
inline void BaseCommand::clear_watchtopicupdate() {
  if (watchtopicupdate_ != nullptr) watchtopicupdate_->Clear();
  _has_bits_[1] &= ~0x00800000u;
}
inline const ::pulsar::proto::CommandWatchTopicUpdate& BaseCommand::_internal_watchtopicupdate() const {
  const ::pulsar::proto::CommandWatchTopicUpdate* p = watchtopicupdate_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandWatchTopicUpdate&>(
      ::pulsar::proto::_CommandWatchTopicUpdate_default_instance_);
}
inline const ::pulsar::proto::CommandWatchTopicUpdate& BaseCommand::watchtopicupdate() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.watchTopicUpdate)
  return _internal_watchtopicupdate();
}
inline void BaseCommand::unsafe_arena_set_allocated_watchtopicupdate(
    ::pulsar::proto::CommandWatchTopicUpdate* watchtopicupdate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(watchtopicupdate_);
  }
  watchtopicupdate_ = watchtopicupdate;
  if (watchtopicupdate) {
    _has_bits_[1] |= 0x00800000u;
  } else {
    _has_bits_[1] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.watchTopicUpdate)
}
inline ::pulsar::proto::CommandWatchTopicUpdate* BaseCommand::release_watchtopicupdate() {
  _has_bits_[1] &= ~0x00800000u;
  ::pulsar::proto::CommandWatchTopicUpdate* temp = watchtopicupdate_;
  watchtopicupdate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicUpdate* BaseCommand::unsafe_arena_release_watchtopicupdate() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.watchTopicUpdate)
  _has_bits_[1] &= ~0x00800000u;
  ::pulsar::proto::CommandWatchTopicUpdate* temp = watchtopicupdate_;
  watchtopicupdate_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicUpdate* BaseCommand::_internal_mutable_watchtopicupdate() {
  _has_bits_[1] |= 0x00800000u;
  if (watchtopicupdate_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandWatchTopicUpdate>(GetArenaForAllocation());
    watchtopicupdate_ = p;
  }
  return watchtopicupdate_;
}
inline ::pulsar::proto::CommandWatchTopicUpdate* BaseCommand::mutable_watchtopicupdate() {
  ::pulsar::proto::CommandWatchTopicUpdate* _msg = _internal_mutable_watchtopicupdate();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.watchTopicUpdate)
  return _msg;
}
inline void BaseCommand::set_allocated_watchtopicupdate(::pulsar::proto::CommandWatchTopicUpdate* watchtopicupdate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete watchtopicupdate_;
  }
  if (watchtopicupdate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandWatchTopicUpdate>::GetOwningArena(watchtopicupdate);
    if (message_arena != submessage_arena) {
      watchtopicupdate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, watchtopicupdate, submessage_arena);
    }
    _has_bits_[1] |= 0x00800000u;
  } else {
    _has_bits_[1] &= ~0x00800000u;
  }
  watchtopicupdate_ = watchtopicupdate;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.watchTopicUpdate)
}

// optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
inline bool BaseCommand::_internal_has_watchtopiclistclose() const {
  bool value = (_has_bits_[1] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || watchtopiclistclose_ != nullptr);
  return value;
}
inline bool BaseCommand::has_watchtopiclistclose() const {
  return _internal_has_watchtopiclistclose();
}
inline void BaseCommand::clear_watchtopiclistclose() {
  if (watchtopiclistclose_ != nullptr) watchtopiclistclose_->Clear();
  _has_bits_[1] &= ~0x01000000u;
}
inline const ::pulsar::proto::CommandWatchTopicListClose& BaseCommand::_internal_watchtopiclistclose() const {
  const ::pulsar::proto::CommandWatchTopicListClose* p = watchtopiclistclose_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandWatchTopicListClose&>(
      ::pulsar::proto::_CommandWatchTopicListClose_default_instance_);
}
inline const ::pulsar::proto::CommandWatchTopicListClose& BaseCommand::watchtopiclistclose() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.watchTopicListClose)
  return _internal_watchtopiclistclose();
}
inline void BaseCommand::unsafe_arena_set_allocated_watchtopiclistclose(
    ::pulsar::proto::CommandWatchTopicListClose* watchtopiclistclose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(watchtopiclistclose_);
  }
  watchtopiclistclose_ = watchtopiclistclose;
  if (watchtopiclistclose) {
    _has_bits_[1] |= 0x01000000u;
  } else {
    _has_bits_[1] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.watchTopicListClose)
}
inline ::pulsar::proto::CommandWatchTopicListClose* BaseCommand::release_watchtopiclistclose() {
  _has_bits_[1] &= ~0x01000000u;
  ::pulsar::proto::CommandWatchTopicListClose* temp = watchtopiclistclose_;
  watchtopiclistclose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicListClose* BaseCommand::unsafe_arena_release_watchtopiclistclose() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.watchTopicListClose)
  _has_bits_[1] &= ~0x01000000u;
  ::pulsar::proto::CommandWatchTopicListClose* temp = watchtopiclistclose_;
  watchtopiclistclose_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicListClose* BaseCommand::_internal_mutable_watchtopiclistclose() {
  _has_bits_[1] |= 0x01000000u;
  if (watchtopiclistclose_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandWatchTopicListClose>(GetArenaForAllocation());
    watchtopiclistclose_ = p;
  }
  return watchtopiclistclose_;
}
inline ::pulsar::proto::CommandWatchTopicListClose* BaseCommand::mutable_watchtopiclistclose() {
  ::pulsar::proto::CommandWatchTopicListClose* _msg = _internal_mutable_watchtopiclistclose();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.watchTopicListClose)
  return _msg;
}
inline void BaseCommand::set_allocated_watchtopiclistclose(::pulsar::proto::CommandWatchTopicListClose* watchtopiclistclose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete watchtopiclistclose_;
  }
  if (watchtopiclistclose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandWatchTopicListClose>::GetOwningArena(watchtopiclistclose);
    if (message_arena != submessage_arena) {
      watchtopiclistclose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, watchtopiclistclose, submessage_arena);
    }
    _has_bits_[1] |= 0x01000000u;
  } else {
    _has_bits_[1] &= ~0x01000000u;
  }
  watchtopiclistclose_ = watchtopiclistclose;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.watchTopicListClose)
}

// optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
inline bool BaseCommand::_internal_has_topicmigrated() const {
  bool value = (_has_bits_[1] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || topicmigrated_ != nullptr);
  return value;
}
inline bool BaseCommand::has_topicmigrated() const {
  return _internal_has_topicmigrated();
}
inline void BaseCommand::clear_topicmigrated() {
  if (topicmigrated_ != nullptr) topicmigrated_->Clear();
  _has_bits_[1] &= ~0x02000000u;
}
inline const ::pulsar::proto::CommandTopicMigrated& BaseCommand::_internal_topicmigrated() const {
  const ::pulsar::proto::CommandTopicMigrated* p = topicmigrated_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandTopicMigrated&>(
      ::pulsar::proto::_CommandTopicMigrated_default_instance_);
}
inline const ::pulsar::proto::CommandTopicMigrated& BaseCommand::topicmigrated() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.topicMigrated)
  return _internal_topicmigrated();
}
inline void BaseCommand::unsafe_arena_set_allocated_topicmigrated(
    ::pulsar::proto::CommandTopicMigrated* topicmigrated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topicmigrated_);
  }
  topicmigrated_ = topicmigrated;
  if (topicmigrated) {
    _has_bits_[1] |= 0x02000000u;
  } else {
    _has_bits_[1] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.topicMigrated)
}
inline ::pulsar::proto::CommandTopicMigrated* BaseCommand::release_topicmigrated() {
  _has_bits_[1] &= ~0x02000000u;
  ::pulsar::proto::CommandTopicMigrated* temp = topicmigrated_;
  topicmigrated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pulsar::proto::CommandTopicMigrated* BaseCommand::unsafe_arena_release_topicmigrated() {
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.topicMigrated)
  _has_bits_[1] &= ~0x02000000u;
  ::pulsar::proto::CommandTopicMigrated* temp = topicmigrated_;
  topicmigrated_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandTopicMigrated* BaseCommand::_internal_mutable_topicmigrated() {
  _has_bits_[1] |= 0x02000000u;
  if (topicmigrated_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandTopicMigrated>(GetArenaForAllocation());
    topicmigrated_ = p;
  }
  return topicmigrated_;
}
inline ::pulsar::proto::CommandTopicMigrated* BaseCommand::mutable_topicmigrated() {
  ::pulsar::proto::CommandTopicMigrated* _msg = _internal_mutable_topicmigrated();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.topicMigrated)
  return _msg;
}
inline void BaseCommand::set_allocated_topicmigrated(::pulsar::proto::CommandTopicMigrated* topicmigrated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete topicmigrated_;
  }
  if (topicmigrated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pulsar::proto::CommandTopicMigrated>::GetOwningArena(topicmigrated);
    if (message_arena != submessage_arena) {
      topicmigrated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topicmigrated, submessage_arena);
    }
    _has_bits_[1] |= 0x02000000u;
  } else {
    _has_bits_[1] &= ~0x02000000u;
  }
  topicmigrated_ = topicmigrated;
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.topicMigrated)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace pulsar

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pulsar::proto::Schema_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::CommandSubscribe_SubType> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::CommandSubscribe_InitialPosition> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::CommandLookupTopicResponse_LookupType> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::CommandAck_AckType> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::CommandAck_ValidationError> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::CommandTopicMigrated_ResourceType> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::CommandGetTopicsOfNamespace_Mode> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::BaseCommand_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::CompressionType> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::ProducerAccessMode> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::ServerError> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::AuthMethod> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::ProtocolVersion> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::KeySharedMode> : ::std::true_type {};
template <> struct is_proto_enum< ::pulsar::proto::TxnAction> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_PulsarApi_2eproto
