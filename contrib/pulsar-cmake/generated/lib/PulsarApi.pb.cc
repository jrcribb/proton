// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PulsarApi.proto

#include "PulsarApi.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace pulsar {
namespace proto {
constexpr Schema::Schema(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : properties_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(0)
{}
struct SchemaDefaultTypeInternal {
  constexpr SchemaDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SchemaDefaultTypeInternal() {}
  union {
    Schema _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SchemaDefaultTypeInternal _Schema_default_instance_;
constexpr MessageIdData::MessageIdData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ack_set_()
  , first_chunk_message_id_(nullptr)
  , ledgerid_(uint64_t{0u})
  , entryid_(uint64_t{0u})
  , batch_size_(0)
  , partition_(-1)
  , batch_index_(-1){}
struct MessageIdDataDefaultTypeInternal {
  constexpr MessageIdDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MessageIdDataDefaultTypeInternal() {}
  union {
    MessageIdData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MessageIdDataDefaultTypeInternal _MessageIdData_default_instance_;
constexpr KeyValue::KeyValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct KeyValueDefaultTypeInternal {
  constexpr KeyValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyValueDefaultTypeInternal() {}
  union {
    KeyValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyValueDefaultTypeInternal _KeyValue_default_instance_;
constexpr KeyLongValue::KeyLongValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(uint64_t{0u}){}
struct KeyLongValueDefaultTypeInternal {
  constexpr KeyLongValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyLongValueDefaultTypeInternal() {}
  union {
    KeyLongValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyLongValueDefaultTypeInternal _KeyLongValue_default_instance_;
constexpr IntRange::IntRange(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : start_(0)
  , end_(0){}
struct IntRangeDefaultTypeInternal {
  constexpr IntRangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IntRangeDefaultTypeInternal() {}
  union {
    IntRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IntRangeDefaultTypeInternal _IntRange_default_instance_;
constexpr EncryptionKeys::EncryptionKeys(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : metadata_()
  , key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct EncryptionKeysDefaultTypeInternal {
  constexpr EncryptionKeysDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EncryptionKeysDefaultTypeInternal() {}
  union {
    EncryptionKeys _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EncryptionKeysDefaultTypeInternal _EncryptionKeys_default_instance_;
constexpr MessageMetadata::MessageMetadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : properties_()
  , replicate_to_()
  , encryption_keys_()
  , producer_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , replicated_from_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , partition_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , encryption_algo_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , encryption_param_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ordering_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , uuid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sequence_id_(uint64_t{0u})
  , publish_time_(uint64_t{0u})
  , compression_(0)

  , uncompressed_size_(0u)
  , event_time_(uint64_t{0u})
  , deliver_at_time_(int64_t{0})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , marker_type_(0)
  , partition_key_b64_encoded_(false)
  , null_value_(false)
  , null_partition_key_(false)
  , highest_sequence_id_(uint64_t{0u})
  , num_chunks_from_msg_(0)
  , total_chunk_msg_size_(0)
  , chunk_id_(0)
  , num_messages_in_batch_(1){}
struct MessageMetadataDefaultTypeInternal {
  constexpr MessageMetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MessageMetadataDefaultTypeInternal() {}
  union {
    MessageMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MessageMetadataDefaultTypeInternal _MessageMetadata_default_instance_;
constexpr SingleMessageMetadata::SingleMessageMetadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : properties_()
  , partition_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ordering_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , event_time_(uint64_t{0u})
  , payload_size_(0)
  , compacted_out_(false)
  , partition_key_b64_encoded_(false)
  , null_value_(false)
  , null_partition_key_(false)
  , sequence_id_(uint64_t{0u}){}
struct SingleMessageMetadataDefaultTypeInternal {
  constexpr SingleMessageMetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SingleMessageMetadataDefaultTypeInternal() {}
  union {
    SingleMessageMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SingleMessageMetadataDefaultTypeInternal _SingleMessageMetadata_default_instance_;
constexpr BrokerEntryMetadata::BrokerEntryMetadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : broker_timestamp_(uint64_t{0u})
  , index_(uint64_t{0u}){}
struct BrokerEntryMetadataDefaultTypeInternal {
  constexpr BrokerEntryMetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BrokerEntryMetadataDefaultTypeInternal() {}
  union {
    BrokerEntryMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BrokerEntryMetadataDefaultTypeInternal _BrokerEntryMetadata_default_instance_;
constexpr CommandConnect::CommandConnect(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : client_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , auth_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , auth_method_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , proxy_to_broker_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_principal_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_auth_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_auth_method_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , feature_flags_(nullptr)
  , auth_method_(0)

  , protocol_version_(0){}
struct CommandConnectDefaultTypeInternal {
  constexpr CommandConnectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandConnectDefaultTypeInternal() {}
  union {
    CommandConnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandConnectDefaultTypeInternal _CommandConnect_default_instance_;
constexpr FeatureFlags::FeatureFlags(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : supports_auth_refresh_(false)
  , supports_broker_entry_metadata_(false)
  , supports_partial_producer_(false)
  , supports_topic_watchers_(false){}
struct FeatureFlagsDefaultTypeInternal {
  constexpr FeatureFlagsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FeatureFlagsDefaultTypeInternal() {}
  union {
    FeatureFlags _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FeatureFlagsDefaultTypeInternal _FeatureFlags_default_instance_;
constexpr CommandConnected::CommandConnected(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : server_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , feature_flags_(nullptr)
  , protocol_version_(0)
  , max_message_size_(0){}
struct CommandConnectedDefaultTypeInternal {
  constexpr CommandConnectedDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandConnectedDefaultTypeInternal() {}
  union {
    CommandConnected _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandConnectedDefaultTypeInternal _CommandConnected_default_instance_;
constexpr CommandAuthResponse::CommandAuthResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : client_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , response_(nullptr)
  , protocol_version_(0){}
struct CommandAuthResponseDefaultTypeInternal {
  constexpr CommandAuthResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandAuthResponseDefaultTypeInternal() {}
  union {
    CommandAuthResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandAuthResponseDefaultTypeInternal _CommandAuthResponse_default_instance_;
constexpr CommandAuthChallenge::CommandAuthChallenge(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : server_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , challenge_(nullptr)
  , protocol_version_(0){}
struct CommandAuthChallengeDefaultTypeInternal {
  constexpr CommandAuthChallengeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandAuthChallengeDefaultTypeInternal() {}
  union {
    CommandAuthChallenge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandAuthChallengeDefaultTypeInternal _CommandAuthChallenge_default_instance_;
constexpr AuthData::AuthData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : auth_method_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , auth_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AuthDataDefaultTypeInternal {
  constexpr AuthDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AuthDataDefaultTypeInternal() {}
  union {
    AuthData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AuthDataDefaultTypeInternal _AuthData_default_instance_;
constexpr KeySharedMeta::KeySharedMeta(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hashranges_()
  , keysharedmode_(0)

  , allowoutoforderdelivery_(false){}
struct KeySharedMetaDefaultTypeInternal {
  constexpr KeySharedMetaDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeySharedMetaDefaultTypeInternal() {}
  union {
    KeySharedMeta _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeySharedMetaDefaultTypeInternal _KeySharedMeta_default_instance_;
constexpr CommandSubscribe::CommandSubscribe(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : metadata_()
  , subscription_properties_()
  , topic_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , subscription_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , consumer_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , start_message_id_(nullptr)
  , schema_(nullptr)
  , keysharedmeta_(nullptr)
  , consumer_id_(uint64_t{0u})
  , request_id_(uint64_t{0u})
  , subtype_(0)

  , priority_level_(0)
  , read_compacted_(false)
  , replicate_subscription_state_(false)
  , initialposition_(0)

  , start_message_rollback_duration_sec_(uint64_t{0u})
  , consumer_epoch_(uint64_t{0u})
  , durable_(true)
  , force_topic_creation_(true){}
struct CommandSubscribeDefaultTypeInternal {
  constexpr CommandSubscribeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandSubscribeDefaultTypeInternal() {}
  union {
    CommandSubscribe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandSubscribeDefaultTypeInternal _CommandSubscribe_default_instance_;
constexpr CommandPartitionedTopicMetadata::CommandPartitionedTopicMetadata(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : topic_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_principal_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_auth_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_auth_method_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u}){}
struct CommandPartitionedTopicMetadataDefaultTypeInternal {
  constexpr CommandPartitionedTopicMetadataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandPartitionedTopicMetadataDefaultTypeInternal() {}
  union {
    CommandPartitionedTopicMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandPartitionedTopicMetadataDefaultTypeInternal _CommandPartitionedTopicMetadata_default_instance_;
constexpr CommandPartitionedTopicMetadataResponse::CommandPartitionedTopicMetadataResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , partitions_(0u)
  , response_(0)

  , error_(0)
{}
struct CommandPartitionedTopicMetadataResponseDefaultTypeInternal {
  constexpr CommandPartitionedTopicMetadataResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandPartitionedTopicMetadataResponseDefaultTypeInternal() {}
  union {
    CommandPartitionedTopicMetadataResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandPartitionedTopicMetadataResponseDefaultTypeInternal _CommandPartitionedTopicMetadataResponse_default_instance_;
constexpr CommandLookupTopic::CommandLookupTopic(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : topic_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_principal_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_auth_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , original_auth_method_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , advertised_listener_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , authoritative_(false){}
struct CommandLookupTopicDefaultTypeInternal {
  constexpr CommandLookupTopicDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandLookupTopicDefaultTypeInternal() {}
  union {
    CommandLookupTopic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandLookupTopicDefaultTypeInternal _CommandLookupTopic_default_instance_;
constexpr CommandLookupTopicResponse::CommandLookupTopicResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : brokerserviceurl_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , brokerserviceurltls_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , response_(0)

  , error_(0)

  , authoritative_(false)
  , proxy_through_service_url_(false){}
struct CommandLookupTopicResponseDefaultTypeInternal {
  constexpr CommandLookupTopicResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandLookupTopicResponseDefaultTypeInternal() {}
  union {
    CommandLookupTopicResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandLookupTopicResponseDefaultTypeInternal _CommandLookupTopicResponse_default_instance_;
constexpr CommandProducer::CommandProducer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : metadata_()
  , topic_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , producer_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , initial_subscription_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_(nullptr)
  , producer_id_(uint64_t{0u})
  , request_id_(uint64_t{0u})
  , epoch_(uint64_t{0u})
  , encrypted_(false)
  , txn_enabled_(false)
  , producer_access_mode_(0)

  , topic_epoch_(uint64_t{0u})
  , user_provided_producer_name_(true){}
struct CommandProducerDefaultTypeInternal {
  constexpr CommandProducerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandProducerDefaultTypeInternal() {}
  union {
    CommandProducer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandProducerDefaultTypeInternal _CommandProducer_default_instance_;
constexpr CommandSend::CommandSend(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_id_(nullptr)
  , producer_id_(uint64_t{0u})
  , sequence_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , highest_sequence_id_(uint64_t{0u})
  , is_chunk_(false)
  , marker_(false)
  , num_messages_(1){}
struct CommandSendDefaultTypeInternal {
  constexpr CommandSendDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandSendDefaultTypeInternal() {}
  union {
    CommandSend _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandSendDefaultTypeInternal _CommandSend_default_instance_;
constexpr CommandSendReceipt::CommandSendReceipt(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_id_(nullptr)
  , producer_id_(uint64_t{0u})
  , sequence_id_(uint64_t{0u})
  , highest_sequence_id_(uint64_t{0u}){}
struct CommandSendReceiptDefaultTypeInternal {
  constexpr CommandSendReceiptDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandSendReceiptDefaultTypeInternal() {}
  union {
    CommandSendReceipt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandSendReceiptDefaultTypeInternal _CommandSendReceipt_default_instance_;
constexpr CommandSendError::CommandSendError(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , producer_id_(uint64_t{0u})
  , sequence_id_(uint64_t{0u})
  , error_(0)
{}
struct CommandSendErrorDefaultTypeInternal {
  constexpr CommandSendErrorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandSendErrorDefaultTypeInternal() {}
  union {
    CommandSendError _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandSendErrorDefaultTypeInternal _CommandSendError_default_instance_;
constexpr CommandMessage::CommandMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ack_set_()
  , message_id_(nullptr)
  , consumer_id_(uint64_t{0u})
  , consumer_epoch_(uint64_t{0u})
  , redelivery_count_(0u){}
struct CommandMessageDefaultTypeInternal {
  constexpr CommandMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandMessageDefaultTypeInternal() {}
  union {
    CommandMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandMessageDefaultTypeInternal _CommandMessage_default_instance_;
constexpr CommandAck::CommandAck(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_id_()
  , properties_()
  , consumer_id_(uint64_t{0u})
  , ack_type_(0)

  , validation_error_(0)

  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , request_id_(uint64_t{0u}){}
struct CommandAckDefaultTypeInternal {
  constexpr CommandAckDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandAckDefaultTypeInternal() {}
  union {
    CommandAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandAckDefaultTypeInternal _CommandAck_default_instance_;
constexpr CommandAckResponse::CommandAckResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , consumer_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , request_id_(uint64_t{0u})
  , error_(0)
{}
struct CommandAckResponseDefaultTypeInternal {
  constexpr CommandAckResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandAckResponseDefaultTypeInternal() {}
  union {
    CommandAckResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandAckResponseDefaultTypeInternal _CommandAckResponse_default_instance_;
constexpr CommandActiveConsumerChange::CommandActiveConsumerChange(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : consumer_id_(uint64_t{0u})
  , is_active_(false){}
struct CommandActiveConsumerChangeDefaultTypeInternal {
  constexpr CommandActiveConsumerChangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandActiveConsumerChangeDefaultTypeInternal() {}
  union {
    CommandActiveConsumerChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandActiveConsumerChangeDefaultTypeInternal _CommandActiveConsumerChange_default_instance_;
constexpr CommandFlow::CommandFlow(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : consumer_id_(uint64_t{0u})
  , messagepermits_(0u){}
struct CommandFlowDefaultTypeInternal {
  constexpr CommandFlowDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandFlowDefaultTypeInternal() {}
  union {
    CommandFlow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandFlowDefaultTypeInternal _CommandFlow_default_instance_;
constexpr CommandUnsubscribe::CommandUnsubscribe(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : consumer_id_(uint64_t{0u})
  , request_id_(uint64_t{0u}){}
struct CommandUnsubscribeDefaultTypeInternal {
  constexpr CommandUnsubscribeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandUnsubscribeDefaultTypeInternal() {}
  union {
    CommandUnsubscribe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandUnsubscribeDefaultTypeInternal _CommandUnsubscribe_default_instance_;
constexpr CommandSeek::CommandSeek(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_id_(nullptr)
  , consumer_id_(uint64_t{0u})
  , request_id_(uint64_t{0u})
  , message_publish_time_(uint64_t{0u}){}
struct CommandSeekDefaultTypeInternal {
  constexpr CommandSeekDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandSeekDefaultTypeInternal() {}
  union {
    CommandSeek _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandSeekDefaultTypeInternal _CommandSeek_default_instance_;
constexpr CommandReachedEndOfTopic::CommandReachedEndOfTopic(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : consumer_id_(uint64_t{0u}){}
struct CommandReachedEndOfTopicDefaultTypeInternal {
  constexpr CommandReachedEndOfTopicDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandReachedEndOfTopicDefaultTypeInternal() {}
  union {
    CommandReachedEndOfTopic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandReachedEndOfTopicDefaultTypeInternal _CommandReachedEndOfTopic_default_instance_;
constexpr CommandTopicMigrated::CommandTopicMigrated(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : brokerserviceurl_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , brokerserviceurltls_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , resource_id_(uint64_t{0u})
  , resource_type_(0)
{}
struct CommandTopicMigratedDefaultTypeInternal {
  constexpr CommandTopicMigratedDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandTopicMigratedDefaultTypeInternal() {}
  union {
    CommandTopicMigrated _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandTopicMigratedDefaultTypeInternal _CommandTopicMigrated_default_instance_;
constexpr CommandCloseProducer::CommandCloseProducer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : assignedbrokerserviceurl_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , assignedbrokerserviceurltls_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , producer_id_(uint64_t{0u})
  , request_id_(uint64_t{0u}){}
struct CommandCloseProducerDefaultTypeInternal {
  constexpr CommandCloseProducerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandCloseProducerDefaultTypeInternal() {}
  union {
    CommandCloseProducer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandCloseProducerDefaultTypeInternal _CommandCloseProducer_default_instance_;
constexpr CommandCloseConsumer::CommandCloseConsumer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : assignedbrokerserviceurl_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , assignedbrokerserviceurltls_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , consumer_id_(uint64_t{0u})
  , request_id_(uint64_t{0u}){}
struct CommandCloseConsumerDefaultTypeInternal {
  constexpr CommandCloseConsumerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandCloseConsumerDefaultTypeInternal() {}
  union {
    CommandCloseConsumer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandCloseConsumerDefaultTypeInternal _CommandCloseConsumer_default_instance_;
constexpr CommandRedeliverUnacknowledgedMessages::CommandRedeliverUnacknowledgedMessages(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_ids_()
  , consumer_id_(uint64_t{0u})
  , consumer_epoch_(uint64_t{0u}){}
struct CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal {
  constexpr CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal() {}
  union {
    CommandRedeliverUnacknowledgedMessages _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal _CommandRedeliverUnacknowledgedMessages_default_instance_;
constexpr CommandSuccess::CommandSuccess(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : schema_(nullptr)
  , request_id_(uint64_t{0u}){}
struct CommandSuccessDefaultTypeInternal {
  constexpr CommandSuccessDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandSuccessDefaultTypeInternal() {}
  union {
    CommandSuccess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandSuccessDefaultTypeInternal _CommandSuccess_default_instance_;
constexpr CommandProducerSuccess::CommandProducerSuccess(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : producer_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , topic_epoch_(uint64_t{0u})
  , producer_ready_(true)
  , last_sequence_id_(int64_t{-1}){}
struct CommandProducerSuccessDefaultTypeInternal {
  constexpr CommandProducerSuccessDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandProducerSuccessDefaultTypeInternal() {}
  union {
    CommandProducerSuccess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandProducerSuccessDefaultTypeInternal _CommandProducerSuccess_default_instance_;
constexpr CommandError::CommandError(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , error_(0)
{}
struct CommandErrorDefaultTypeInternal {
  constexpr CommandErrorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandErrorDefaultTypeInternal() {}
  union {
    CommandError _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandErrorDefaultTypeInternal _CommandError_default_instance_;
constexpr CommandPing::CommandPing(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CommandPingDefaultTypeInternal {
  constexpr CommandPingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandPingDefaultTypeInternal() {}
  union {
    CommandPing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandPingDefaultTypeInternal _CommandPing_default_instance_;
constexpr CommandPong::CommandPong(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CommandPongDefaultTypeInternal {
  constexpr CommandPongDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandPongDefaultTypeInternal() {}
  union {
    CommandPong _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandPongDefaultTypeInternal _CommandPong_default_instance_;
constexpr CommandConsumerStats::CommandConsumerStats(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_id_(uint64_t{0u})
  , consumer_id_(uint64_t{0u}){}
struct CommandConsumerStatsDefaultTypeInternal {
  constexpr CommandConsumerStatsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandConsumerStatsDefaultTypeInternal() {}
  union {
    CommandConsumerStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandConsumerStatsDefaultTypeInternal _CommandConsumerStats_default_instance_;
constexpr CommandConsumerStatsResponse::CommandConsumerStatsResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , consumername_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , connectedsince_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , msgrateout_(0)
  , msgthroughputout_(0)
  , msgrateredeliver_(0)
  , error_code_(0)

  , blockedconsumeronunackedmsgs_(false)
  , availablepermits_(uint64_t{0u})
  , unackedmessages_(uint64_t{0u})
  , msgrateexpired_(0)
  , msgbacklog_(uint64_t{0u})
  , messageackrate_(0){}
struct CommandConsumerStatsResponseDefaultTypeInternal {
  constexpr CommandConsumerStatsResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandConsumerStatsResponseDefaultTypeInternal() {}
  union {
    CommandConsumerStatsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandConsumerStatsResponseDefaultTypeInternal _CommandConsumerStatsResponse_default_instance_;
constexpr CommandGetLastMessageId::CommandGetLastMessageId(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : consumer_id_(uint64_t{0u})
  , request_id_(uint64_t{0u}){}
struct CommandGetLastMessageIdDefaultTypeInternal {
  constexpr CommandGetLastMessageIdDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandGetLastMessageIdDefaultTypeInternal() {}
  union {
    CommandGetLastMessageId _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandGetLastMessageIdDefaultTypeInternal _CommandGetLastMessageId_default_instance_;
constexpr CommandGetLastMessageIdResponse::CommandGetLastMessageIdResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : last_message_id_(nullptr)
  , consumer_mark_delete_position_(nullptr)
  , request_id_(uint64_t{0u}){}
struct CommandGetLastMessageIdResponseDefaultTypeInternal {
  constexpr CommandGetLastMessageIdResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandGetLastMessageIdResponseDefaultTypeInternal() {}
  union {
    CommandGetLastMessageIdResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandGetLastMessageIdResponseDefaultTypeInternal _CommandGetLastMessageIdResponse_default_instance_;
constexpr CommandGetTopicsOfNamespace::CommandGetTopicsOfNamespace(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , topics_pattern_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , topics_hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , mode_(0)
{}
struct CommandGetTopicsOfNamespaceDefaultTypeInternal {
  constexpr CommandGetTopicsOfNamespaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandGetTopicsOfNamespaceDefaultTypeInternal() {}
  union {
    CommandGetTopicsOfNamespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandGetTopicsOfNamespaceDefaultTypeInternal _CommandGetTopicsOfNamespace_default_instance_;
constexpr CommandGetTopicsOfNamespaceResponse::CommandGetTopicsOfNamespaceResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : topics_()
  , topics_hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , filtered_(false)
  , changed_(true){}
struct CommandGetTopicsOfNamespaceResponseDefaultTypeInternal {
  constexpr CommandGetTopicsOfNamespaceResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandGetTopicsOfNamespaceResponseDefaultTypeInternal() {}
  union {
    CommandGetTopicsOfNamespaceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandGetTopicsOfNamespaceResponseDefaultTypeInternal _CommandGetTopicsOfNamespaceResponse_default_instance_;
constexpr CommandWatchTopicList::CommandWatchTopicList(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : namespace__(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , topics_pattern_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , topics_hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , watcher_id_(uint64_t{0u}){}
struct CommandWatchTopicListDefaultTypeInternal {
  constexpr CommandWatchTopicListDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandWatchTopicListDefaultTypeInternal() {}
  union {
    CommandWatchTopicList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandWatchTopicListDefaultTypeInternal _CommandWatchTopicList_default_instance_;
constexpr CommandWatchTopicListSuccess::CommandWatchTopicListSuccess(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : topic_()
  , topics_hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , watcher_id_(uint64_t{0u}){}
struct CommandWatchTopicListSuccessDefaultTypeInternal {
  constexpr CommandWatchTopicListSuccessDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandWatchTopicListSuccessDefaultTypeInternal() {}
  union {
    CommandWatchTopicListSuccess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandWatchTopicListSuccessDefaultTypeInternal _CommandWatchTopicListSuccess_default_instance_;
constexpr CommandWatchTopicUpdate::CommandWatchTopicUpdate(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : new_topics_()
  , deleted_topics_()
  , topics_hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , watcher_id_(uint64_t{0u}){}
struct CommandWatchTopicUpdateDefaultTypeInternal {
  constexpr CommandWatchTopicUpdateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandWatchTopicUpdateDefaultTypeInternal() {}
  union {
    CommandWatchTopicUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandWatchTopicUpdateDefaultTypeInternal _CommandWatchTopicUpdate_default_instance_;
constexpr CommandWatchTopicListClose::CommandWatchTopicListClose(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_id_(uint64_t{0u})
  , watcher_id_(uint64_t{0u}){}
struct CommandWatchTopicListCloseDefaultTypeInternal {
  constexpr CommandWatchTopicListCloseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandWatchTopicListCloseDefaultTypeInternal() {}
  union {
    CommandWatchTopicListClose _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandWatchTopicListCloseDefaultTypeInternal _CommandWatchTopicListClose_default_instance_;
constexpr CommandGetSchema::CommandGetSchema(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : topic_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u}){}
struct CommandGetSchemaDefaultTypeInternal {
  constexpr CommandGetSchemaDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandGetSchemaDefaultTypeInternal() {}
  union {
    CommandGetSchema _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandGetSchemaDefaultTypeInternal _CommandGetSchema_default_instance_;
constexpr CommandGetSchemaResponse::CommandGetSchemaResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_(nullptr)
  , request_id_(uint64_t{0u})
  , error_code_(0)
{}
struct CommandGetSchemaResponseDefaultTypeInternal {
  constexpr CommandGetSchemaResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandGetSchemaResponseDefaultTypeInternal() {}
  union {
    CommandGetSchemaResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandGetSchemaResponseDefaultTypeInternal _CommandGetSchemaResponse_default_instance_;
constexpr CommandGetOrCreateSchema::CommandGetOrCreateSchema(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : topic_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_(nullptr)
  , request_id_(uint64_t{0u}){}
struct CommandGetOrCreateSchemaDefaultTypeInternal {
  constexpr CommandGetOrCreateSchemaDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandGetOrCreateSchemaDefaultTypeInternal() {}
  union {
    CommandGetOrCreateSchema _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandGetOrCreateSchemaDefaultTypeInternal _CommandGetOrCreateSchema_default_instance_;
constexpr CommandGetOrCreateSchemaResponse::CommandGetOrCreateSchemaResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , schema_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , error_code_(0)
{}
struct CommandGetOrCreateSchemaResponseDefaultTypeInternal {
  constexpr CommandGetOrCreateSchemaResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandGetOrCreateSchemaResponseDefaultTypeInternal() {}
  union {
    CommandGetOrCreateSchemaResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandGetOrCreateSchemaResponseDefaultTypeInternal _CommandGetOrCreateSchemaResponse_default_instance_;
constexpr CommandTcClientConnectRequest::CommandTcClientConnectRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_id_(uint64_t{0u})
  , tc_id_(uint64_t{0u}){}
struct CommandTcClientConnectRequestDefaultTypeInternal {
  constexpr CommandTcClientConnectRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandTcClientConnectRequestDefaultTypeInternal() {}
  union {
    CommandTcClientConnectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandTcClientConnectRequestDefaultTypeInternal _CommandTcClientConnectRequest_default_instance_;
constexpr CommandTcClientConnectResponse::CommandTcClientConnectResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , error_(0)
{}
struct CommandTcClientConnectResponseDefaultTypeInternal {
  constexpr CommandTcClientConnectResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandTcClientConnectResponseDefaultTypeInternal() {}
  union {
    CommandTcClientConnectResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandTcClientConnectResponseDefaultTypeInternal _CommandTcClientConnectResponse_default_instance_;
constexpr CommandNewTxn::CommandNewTxn(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_id_(uint64_t{0u})
  , txn_ttl_seconds_(uint64_t{0u})
  , tc_id_(uint64_t{0u}){}
struct CommandNewTxnDefaultTypeInternal {
  constexpr CommandNewTxnDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandNewTxnDefaultTypeInternal() {}
  union {
    CommandNewTxn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandNewTxnDefaultTypeInternal _CommandNewTxn_default_instance_;
constexpr CommandNewTxnResponse::CommandNewTxnResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , error_(0)
{}
struct CommandNewTxnResponseDefaultTypeInternal {
  constexpr CommandNewTxnResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandNewTxnResponseDefaultTypeInternal() {}
  union {
    CommandNewTxnResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandNewTxnResponseDefaultTypeInternal _CommandNewTxnResponse_default_instance_;
constexpr CommandAddPartitionToTxn::CommandAddPartitionToTxn(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : partitions_()
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u}){}
struct CommandAddPartitionToTxnDefaultTypeInternal {
  constexpr CommandAddPartitionToTxnDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandAddPartitionToTxnDefaultTypeInternal() {}
  union {
    CommandAddPartitionToTxn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandAddPartitionToTxnDefaultTypeInternal _CommandAddPartitionToTxn_default_instance_;
constexpr CommandAddPartitionToTxnResponse::CommandAddPartitionToTxnResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , error_(0)
{}
struct CommandAddPartitionToTxnResponseDefaultTypeInternal {
  constexpr CommandAddPartitionToTxnResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandAddPartitionToTxnResponseDefaultTypeInternal() {}
  union {
    CommandAddPartitionToTxnResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandAddPartitionToTxnResponseDefaultTypeInternal _CommandAddPartitionToTxnResponse_default_instance_;
constexpr Subscription::Subscription(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : topic_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , subscription_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct SubscriptionDefaultTypeInternal {
  constexpr SubscriptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SubscriptionDefaultTypeInternal() {}
  union {
    Subscription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SubscriptionDefaultTypeInternal _Subscription_default_instance_;
constexpr CommandAddSubscriptionToTxn::CommandAddSubscriptionToTxn(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subscription_()
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u}){}
struct CommandAddSubscriptionToTxnDefaultTypeInternal {
  constexpr CommandAddSubscriptionToTxnDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandAddSubscriptionToTxnDefaultTypeInternal() {}
  union {
    CommandAddSubscriptionToTxn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandAddSubscriptionToTxnDefaultTypeInternal _CommandAddSubscriptionToTxn_default_instance_;
constexpr CommandAddSubscriptionToTxnResponse::CommandAddSubscriptionToTxnResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , error_(0)
{}
struct CommandAddSubscriptionToTxnResponseDefaultTypeInternal {
  constexpr CommandAddSubscriptionToTxnResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandAddSubscriptionToTxnResponseDefaultTypeInternal() {}
  union {
    CommandAddSubscriptionToTxnResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandAddSubscriptionToTxnResponseDefaultTypeInternal _CommandAddSubscriptionToTxnResponse_default_instance_;
constexpr CommandEndTxn::CommandEndTxn(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , txn_action_(0)
{}
struct CommandEndTxnDefaultTypeInternal {
  constexpr CommandEndTxnDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandEndTxnDefaultTypeInternal() {}
  union {
    CommandEndTxn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandEndTxnDefaultTypeInternal _CommandEndTxn_default_instance_;
constexpr CommandEndTxnResponse::CommandEndTxnResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , error_(0)
{}
struct CommandEndTxnResponseDefaultTypeInternal {
  constexpr CommandEndTxnResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandEndTxnResponseDefaultTypeInternal() {}
  union {
    CommandEndTxnResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandEndTxnResponseDefaultTypeInternal _CommandEndTxnResponse_default_instance_;
constexpr CommandEndTxnOnPartition::CommandEndTxnOnPartition(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : topic_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , txnid_least_bits_of_low_watermark_(uint64_t{0u})
  , txn_action_(0)
{}
struct CommandEndTxnOnPartitionDefaultTypeInternal {
  constexpr CommandEndTxnOnPartitionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandEndTxnOnPartitionDefaultTypeInternal() {}
  union {
    CommandEndTxnOnPartition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandEndTxnOnPartitionDefaultTypeInternal _CommandEndTxnOnPartition_default_instance_;
constexpr CommandEndTxnOnPartitionResponse::CommandEndTxnOnPartitionResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , error_(0)
{}
struct CommandEndTxnOnPartitionResponseDefaultTypeInternal {
  constexpr CommandEndTxnOnPartitionResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandEndTxnOnPartitionResponseDefaultTypeInternal() {}
  union {
    CommandEndTxnOnPartitionResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandEndTxnOnPartitionResponseDefaultTypeInternal _CommandEndTxnOnPartitionResponse_default_instance_;
constexpr CommandEndTxnOnSubscription::CommandEndTxnOnSubscription(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : subscription_(nullptr)
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , txnid_least_bits_of_low_watermark_(uint64_t{0u})
  , txn_action_(0)
{}
struct CommandEndTxnOnSubscriptionDefaultTypeInternal {
  constexpr CommandEndTxnOnSubscriptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandEndTxnOnSubscriptionDefaultTypeInternal() {}
  union {
    CommandEndTxnOnSubscription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandEndTxnOnSubscriptionDefaultTypeInternal _CommandEndTxnOnSubscription_default_instance_;
constexpr CommandEndTxnOnSubscriptionResponse::CommandEndTxnOnSubscriptionResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(uint64_t{0u})
  , txnid_least_bits_(uint64_t{0u})
  , txnid_most_bits_(uint64_t{0u})
  , error_(0)
{}
struct CommandEndTxnOnSubscriptionResponseDefaultTypeInternal {
  constexpr CommandEndTxnOnSubscriptionResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandEndTxnOnSubscriptionResponseDefaultTypeInternal() {}
  union {
    CommandEndTxnOnSubscriptionResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandEndTxnOnSubscriptionResponseDefaultTypeInternal _CommandEndTxnOnSubscriptionResponse_default_instance_;
constexpr BaseCommand::BaseCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : connect_(nullptr)
  , connected_(nullptr)
  , subscribe_(nullptr)
  , producer_(nullptr)
  , send_(nullptr)
  , send_receipt_(nullptr)
  , send_error_(nullptr)
  , message_(nullptr)
  , ack_(nullptr)
  , flow_(nullptr)
  , unsubscribe_(nullptr)
  , success_(nullptr)
  , error_(nullptr)
  , close_producer_(nullptr)
  , close_consumer_(nullptr)
  , producer_success_(nullptr)
  , ping_(nullptr)
  , pong_(nullptr)
  , redeliverunacknowledgedmessages_(nullptr)
  , partitionmetadata_(nullptr)
  , partitionmetadataresponse_(nullptr)
  , lookuptopic_(nullptr)
  , lookuptopicresponse_(nullptr)
  , consumerstats_(nullptr)
  , consumerstatsresponse_(nullptr)
  , reachedendoftopic_(nullptr)
  , seek_(nullptr)
  , getlastmessageid_(nullptr)
  , getlastmessageidresponse_(nullptr)
  , active_consumer_change_(nullptr)
  , gettopicsofnamespace_(nullptr)
  , gettopicsofnamespaceresponse_(nullptr)
  , getschema_(nullptr)
  , getschemaresponse_(nullptr)
  , authchallenge_(nullptr)
  , authresponse_(nullptr)
  , ackresponse_(nullptr)
  , getorcreateschema_(nullptr)
  , getorcreateschemaresponse_(nullptr)
  , newtxn_(nullptr)
  , newtxnresponse_(nullptr)
  , addpartitiontotxn_(nullptr)
  , addpartitiontotxnresponse_(nullptr)
  , addsubscriptiontotxn_(nullptr)
  , addsubscriptiontotxnresponse_(nullptr)
  , endtxn_(nullptr)
  , endtxnresponse_(nullptr)
  , endtxnonpartition_(nullptr)
  , endtxnonpartitionresponse_(nullptr)
  , endtxnonsubscription_(nullptr)
  , endtxnonsubscriptionresponse_(nullptr)
  , tcclientconnectrequest_(nullptr)
  , tcclientconnectresponse_(nullptr)
  , watchtopiclist_(nullptr)
  , watchtopiclistsuccess_(nullptr)
  , watchtopicupdate_(nullptr)
  , watchtopiclistclose_(nullptr)
  , topicmigrated_(nullptr)
  , type_(2)
{}
struct BaseCommandDefaultTypeInternal {
  constexpr BaseCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BaseCommandDefaultTypeInternal() {}
  union {
    BaseCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BaseCommandDefaultTypeInternal _BaseCommand_default_instance_;
}  // namespace proto
}  // namespace pulsar
namespace pulsar {
namespace proto {
bool Schema_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Schema_Type_strings[21] = {};

static const char Schema_Type_names[] =
  "Avro"
  "Bool"
  "Date"
  "Double"
  "Float"
  "Instant"
  "Int16"
  "Int32"
  "Int64"
  "Int8"
  "Json"
  "KeyValue"
  "LocalDate"
  "LocalDateTime"
  "LocalTime"
  "None"
  "Protobuf"
  "ProtobufNative"
  "String"
  "Time"
  "Timestamp";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Schema_Type_entries[] = {
  { {Schema_Type_names + 0, 4}, 4 },
  { {Schema_Type_names + 4, 4}, 5 },
  { {Schema_Type_names + 8, 4}, 12 },
  { {Schema_Type_names + 12, 6}, 11 },
  { {Schema_Type_names + 18, 5}, 10 },
  { {Schema_Type_names + 23, 7}, 16 },
  { {Schema_Type_names + 30, 5}, 7 },
  { {Schema_Type_names + 35, 5}, 8 },
  { {Schema_Type_names + 40, 5}, 9 },
  { {Schema_Type_names + 45, 4}, 6 },
  { {Schema_Type_names + 49, 4}, 2 },
  { {Schema_Type_names + 53, 8}, 15 },
  { {Schema_Type_names + 61, 9}, 17 },
  { {Schema_Type_names + 70, 13}, 19 },
  { {Schema_Type_names + 83, 9}, 18 },
  { {Schema_Type_names + 92, 4}, 0 },
  { {Schema_Type_names + 96, 8}, 3 },
  { {Schema_Type_names + 104, 14}, 20 },
  { {Schema_Type_names + 118, 6}, 1 },
  { {Schema_Type_names + 124, 4}, 13 },
  { {Schema_Type_names + 128, 9}, 14 },
};

static const int Schema_Type_entries_by_number[] = {
  15, // 0 -> None
  18, // 1 -> String
  10, // 2 -> Json
  16, // 3 -> Protobuf
  0, // 4 -> Avro
  1, // 5 -> Bool
  9, // 6 -> Int8
  6, // 7 -> Int16
  7, // 8 -> Int32
  8, // 9 -> Int64
  4, // 10 -> Float
  3, // 11 -> Double
  2, // 12 -> Date
  19, // 13 -> Time
  20, // 14 -> Timestamp
  11, // 15 -> KeyValue
  5, // 16 -> Instant
  12, // 17 -> LocalDate
  14, // 18 -> LocalTime
  13, // 19 -> LocalDateTime
  17, // 20 -> ProtobufNative
};

const std::string& Schema_Type_Name(
    Schema_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Schema_Type_entries,
          Schema_Type_entries_by_number,
          21, Schema_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Schema_Type_entries,
      Schema_Type_entries_by_number,
      21, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Schema_Type_strings[idx].get();
}
bool Schema_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Schema_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Schema_Type_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<Schema_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Schema_Type Schema::None;
constexpr Schema_Type Schema::String;
constexpr Schema_Type Schema::Json;
constexpr Schema_Type Schema::Protobuf;
constexpr Schema_Type Schema::Avro;
constexpr Schema_Type Schema::Bool;
constexpr Schema_Type Schema::Int8;
constexpr Schema_Type Schema::Int16;
constexpr Schema_Type Schema::Int32;
constexpr Schema_Type Schema::Int64;
constexpr Schema_Type Schema::Float;
constexpr Schema_Type Schema::Double;
constexpr Schema_Type Schema::Date;
constexpr Schema_Type Schema::Time;
constexpr Schema_Type Schema::Timestamp;
constexpr Schema_Type Schema::KeyValue;
constexpr Schema_Type Schema::Instant;
constexpr Schema_Type Schema::LocalDate;
constexpr Schema_Type Schema::LocalTime;
constexpr Schema_Type Schema::LocalDateTime;
constexpr Schema_Type Schema::ProtobufNative;
constexpr Schema_Type Schema::Type_MIN;
constexpr Schema_Type Schema::Type_MAX;
constexpr int Schema::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CommandSubscribe_SubType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommandSubscribe_SubType_strings[4] = {};

static const char CommandSubscribe_SubType_names[] =
  "Exclusive"
  "Failover"
  "Key_Shared"
  "Shared";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandSubscribe_SubType_entries[] = {
  { {CommandSubscribe_SubType_names + 0, 9}, 0 },
  { {CommandSubscribe_SubType_names + 9, 8}, 2 },
  { {CommandSubscribe_SubType_names + 17, 10}, 3 },
  { {CommandSubscribe_SubType_names + 27, 6}, 1 },
};

static const int CommandSubscribe_SubType_entries_by_number[] = {
  0, // 0 -> Exclusive
  3, // 1 -> Shared
  1, // 2 -> Failover
  2, // 3 -> Key_Shared
};

const std::string& CommandSubscribe_SubType_Name(
    CommandSubscribe_SubType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandSubscribe_SubType_entries,
          CommandSubscribe_SubType_entries_by_number,
          4, CommandSubscribe_SubType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandSubscribe_SubType_entries,
      CommandSubscribe_SubType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommandSubscribe_SubType_strings[idx].get();
}
bool CommandSubscribe_SubType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandSubscribe_SubType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandSubscribe_SubType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CommandSubscribe_SubType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CommandSubscribe_SubType CommandSubscribe::Exclusive;
constexpr CommandSubscribe_SubType CommandSubscribe::Shared;
constexpr CommandSubscribe_SubType CommandSubscribe::Failover;
constexpr CommandSubscribe_SubType CommandSubscribe::Key_Shared;
constexpr CommandSubscribe_SubType CommandSubscribe::SubType_MIN;
constexpr CommandSubscribe_SubType CommandSubscribe::SubType_MAX;
constexpr int CommandSubscribe::SubType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CommandSubscribe_InitialPosition_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommandSubscribe_InitialPosition_strings[2] = {};

static const char CommandSubscribe_InitialPosition_names[] =
  "Earliest"
  "Latest";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandSubscribe_InitialPosition_entries[] = {
  { {CommandSubscribe_InitialPosition_names + 0, 8}, 1 },
  { {CommandSubscribe_InitialPosition_names + 8, 6}, 0 },
};

static const int CommandSubscribe_InitialPosition_entries_by_number[] = {
  1, // 0 -> Latest
  0, // 1 -> Earliest
};

const std::string& CommandSubscribe_InitialPosition_Name(
    CommandSubscribe_InitialPosition value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandSubscribe_InitialPosition_entries,
          CommandSubscribe_InitialPosition_entries_by_number,
          2, CommandSubscribe_InitialPosition_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandSubscribe_InitialPosition_entries,
      CommandSubscribe_InitialPosition_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommandSubscribe_InitialPosition_strings[idx].get();
}
bool CommandSubscribe_InitialPosition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandSubscribe_InitialPosition* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandSubscribe_InitialPosition_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CommandSubscribe_InitialPosition>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CommandSubscribe_InitialPosition CommandSubscribe::Latest;
constexpr CommandSubscribe_InitialPosition CommandSubscribe::Earliest;
constexpr CommandSubscribe_InitialPosition CommandSubscribe::InitialPosition_MIN;
constexpr CommandSubscribe_InitialPosition CommandSubscribe::InitialPosition_MAX;
constexpr int CommandSubscribe::InitialPosition_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CommandPartitionedTopicMetadataResponse_LookupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommandPartitionedTopicMetadataResponse_LookupType_strings[2] = {};

static const char CommandPartitionedTopicMetadataResponse_LookupType_names[] =
  "Failed"
  "Success";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandPartitionedTopicMetadataResponse_LookupType_entries[] = {
  { {CommandPartitionedTopicMetadataResponse_LookupType_names + 0, 6}, 1 },
  { {CommandPartitionedTopicMetadataResponse_LookupType_names + 6, 7}, 0 },
};

static const int CommandPartitionedTopicMetadataResponse_LookupType_entries_by_number[] = {
  1, // 0 -> Success
  0, // 1 -> Failed
};

const std::string& CommandPartitionedTopicMetadataResponse_LookupType_Name(
    CommandPartitionedTopicMetadataResponse_LookupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandPartitionedTopicMetadataResponse_LookupType_entries,
          CommandPartitionedTopicMetadataResponse_LookupType_entries_by_number,
          2, CommandPartitionedTopicMetadataResponse_LookupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandPartitionedTopicMetadataResponse_LookupType_entries,
      CommandPartitionedTopicMetadataResponse_LookupType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommandPartitionedTopicMetadataResponse_LookupType_strings[idx].get();
}
bool CommandPartitionedTopicMetadataResponse_LookupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandPartitionedTopicMetadataResponse_LookupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandPartitionedTopicMetadataResponse_LookupType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CommandPartitionedTopicMetadataResponse_LookupType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::Success;
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::Failed;
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::LookupType_MIN;
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::LookupType_MAX;
constexpr int CommandPartitionedTopicMetadataResponse::LookupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CommandLookupTopicResponse_LookupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommandLookupTopicResponse_LookupType_strings[3] = {};

static const char CommandLookupTopicResponse_LookupType_names[] =
  "Connect"
  "Failed"
  "Redirect";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandLookupTopicResponse_LookupType_entries[] = {
  { {CommandLookupTopicResponse_LookupType_names + 0, 7}, 1 },
  { {CommandLookupTopicResponse_LookupType_names + 7, 6}, 2 },
  { {CommandLookupTopicResponse_LookupType_names + 13, 8}, 0 },
};

static const int CommandLookupTopicResponse_LookupType_entries_by_number[] = {
  2, // 0 -> Redirect
  0, // 1 -> Connect
  1, // 2 -> Failed
};

const std::string& CommandLookupTopicResponse_LookupType_Name(
    CommandLookupTopicResponse_LookupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandLookupTopicResponse_LookupType_entries,
          CommandLookupTopicResponse_LookupType_entries_by_number,
          3, CommandLookupTopicResponse_LookupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandLookupTopicResponse_LookupType_entries,
      CommandLookupTopicResponse_LookupType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommandLookupTopicResponse_LookupType_strings[idx].get();
}
bool CommandLookupTopicResponse_LookupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandLookupTopicResponse_LookupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandLookupTopicResponse_LookupType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CommandLookupTopicResponse_LookupType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::Redirect;
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::Connect;
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::Failed;
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::LookupType_MIN;
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::LookupType_MAX;
constexpr int CommandLookupTopicResponse::LookupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CommandAck_AckType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommandAck_AckType_strings[2] = {};

static const char CommandAck_AckType_names[] =
  "Cumulative"
  "Individual";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandAck_AckType_entries[] = {
  { {CommandAck_AckType_names + 0, 10}, 1 },
  { {CommandAck_AckType_names + 10, 10}, 0 },
};

static const int CommandAck_AckType_entries_by_number[] = {
  1, // 0 -> Individual
  0, // 1 -> Cumulative
};

const std::string& CommandAck_AckType_Name(
    CommandAck_AckType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandAck_AckType_entries,
          CommandAck_AckType_entries_by_number,
          2, CommandAck_AckType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandAck_AckType_entries,
      CommandAck_AckType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommandAck_AckType_strings[idx].get();
}
bool CommandAck_AckType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandAck_AckType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandAck_AckType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CommandAck_AckType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CommandAck_AckType CommandAck::Individual;
constexpr CommandAck_AckType CommandAck::Cumulative;
constexpr CommandAck_AckType CommandAck::AckType_MIN;
constexpr CommandAck_AckType CommandAck::AckType_MAX;
constexpr int CommandAck::AckType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CommandAck_ValidationError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommandAck_ValidationError_strings[5] = {};

static const char CommandAck_ValidationError_names[] =
  "BatchDeSerializeError"
  "ChecksumMismatch"
  "DecompressionError"
  "DecryptionError"
  "UncompressedSizeCorruption";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandAck_ValidationError_entries[] = {
  { {CommandAck_ValidationError_names + 0, 21}, 3 },
  { {CommandAck_ValidationError_names + 21, 16}, 2 },
  { {CommandAck_ValidationError_names + 37, 18}, 1 },
  { {CommandAck_ValidationError_names + 55, 15}, 4 },
  { {CommandAck_ValidationError_names + 70, 26}, 0 },
};

static const int CommandAck_ValidationError_entries_by_number[] = {
  4, // 0 -> UncompressedSizeCorruption
  2, // 1 -> DecompressionError
  1, // 2 -> ChecksumMismatch
  0, // 3 -> BatchDeSerializeError
  3, // 4 -> DecryptionError
};

const std::string& CommandAck_ValidationError_Name(
    CommandAck_ValidationError value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandAck_ValidationError_entries,
          CommandAck_ValidationError_entries_by_number,
          5, CommandAck_ValidationError_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandAck_ValidationError_entries,
      CommandAck_ValidationError_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommandAck_ValidationError_strings[idx].get();
}
bool CommandAck_ValidationError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandAck_ValidationError* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandAck_ValidationError_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<CommandAck_ValidationError>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CommandAck_ValidationError CommandAck::UncompressedSizeCorruption;
constexpr CommandAck_ValidationError CommandAck::DecompressionError;
constexpr CommandAck_ValidationError CommandAck::ChecksumMismatch;
constexpr CommandAck_ValidationError CommandAck::BatchDeSerializeError;
constexpr CommandAck_ValidationError CommandAck::DecryptionError;
constexpr CommandAck_ValidationError CommandAck::ValidationError_MIN;
constexpr CommandAck_ValidationError CommandAck::ValidationError_MAX;
constexpr int CommandAck::ValidationError_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CommandTopicMigrated_ResourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommandTopicMigrated_ResourceType_strings[2] = {};

static const char CommandTopicMigrated_ResourceType_names[] =
  "Consumer"
  "Producer";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandTopicMigrated_ResourceType_entries[] = {
  { {CommandTopicMigrated_ResourceType_names + 0, 8}, 1 },
  { {CommandTopicMigrated_ResourceType_names + 8, 8}, 0 },
};

static const int CommandTopicMigrated_ResourceType_entries_by_number[] = {
  1, // 0 -> Producer
  0, // 1 -> Consumer
};

const std::string& CommandTopicMigrated_ResourceType_Name(
    CommandTopicMigrated_ResourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandTopicMigrated_ResourceType_entries,
          CommandTopicMigrated_ResourceType_entries_by_number,
          2, CommandTopicMigrated_ResourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandTopicMigrated_ResourceType_entries,
      CommandTopicMigrated_ResourceType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommandTopicMigrated_ResourceType_strings[idx].get();
}
bool CommandTopicMigrated_ResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandTopicMigrated_ResourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandTopicMigrated_ResourceType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CommandTopicMigrated_ResourceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated::Producer;
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated::Consumer;
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated::ResourceType_MIN;
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated::ResourceType_MAX;
constexpr int CommandTopicMigrated::ResourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CommandGetTopicsOfNamespace_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommandGetTopicsOfNamespace_Mode_strings[3] = {};

static const char CommandGetTopicsOfNamespace_Mode_names[] =
  "ALL"
  "NON_PERSISTENT"
  "PERSISTENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommandGetTopicsOfNamespace_Mode_entries[] = {
  { {CommandGetTopicsOfNamespace_Mode_names + 0, 3}, 2 },
  { {CommandGetTopicsOfNamespace_Mode_names + 3, 14}, 1 },
  { {CommandGetTopicsOfNamespace_Mode_names + 17, 10}, 0 },
};

static const int CommandGetTopicsOfNamespace_Mode_entries_by_number[] = {
  2, // 0 -> PERSISTENT
  1, // 1 -> NON_PERSISTENT
  0, // 2 -> ALL
};

const std::string& CommandGetTopicsOfNamespace_Mode_Name(
    CommandGetTopicsOfNamespace_Mode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommandGetTopicsOfNamespace_Mode_entries,
          CommandGetTopicsOfNamespace_Mode_entries_by_number,
          3, CommandGetTopicsOfNamespace_Mode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommandGetTopicsOfNamespace_Mode_entries,
      CommandGetTopicsOfNamespace_Mode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommandGetTopicsOfNamespace_Mode_strings[idx].get();
}
bool CommandGetTopicsOfNamespace_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandGetTopicsOfNamespace_Mode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommandGetTopicsOfNamespace_Mode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CommandGetTopicsOfNamespace_Mode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::PERSISTENT;
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::NON_PERSISTENT;
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::ALL;
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::Mode_MIN;
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::Mode_MAX;
constexpr int CommandGetTopicsOfNamespace::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool BaseCommand_Type_IsValid(int value) {
  switch (value) {
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BaseCommand_Type_strings[58] = {};

static const char BaseCommand_Type_names[] =
  "ACK"
  "ACK_RESPONSE"
  "ACTIVE_CONSUMER_CHANGE"
  "ADD_PARTITION_TO_TXN"
  "ADD_PARTITION_TO_TXN_RESPONSE"
  "ADD_SUBSCRIPTION_TO_TXN"
  "ADD_SUBSCRIPTION_TO_TXN_RESPONSE"
  "AUTH_CHALLENGE"
  "AUTH_RESPONSE"
  "CLOSE_CONSUMER"
  "CLOSE_PRODUCER"
  "CONNECT"
  "CONNECTED"
  "CONSUMER_STATS"
  "CONSUMER_STATS_RESPONSE"
  "END_TXN"
  "END_TXN_ON_PARTITION"
  "END_TXN_ON_PARTITION_RESPONSE"
  "END_TXN_ON_SUBSCRIPTION"
  "END_TXN_ON_SUBSCRIPTION_RESPONSE"
  "END_TXN_RESPONSE"
  "ERROR"
  "FLOW"
  "GET_LAST_MESSAGE_ID"
  "GET_LAST_MESSAGE_ID_RESPONSE"
  "GET_OR_CREATE_SCHEMA"
  "GET_OR_CREATE_SCHEMA_RESPONSE"
  "GET_SCHEMA"
  "GET_SCHEMA_RESPONSE"
  "GET_TOPICS_OF_NAMESPACE"
  "GET_TOPICS_OF_NAMESPACE_RESPONSE"
  "LOOKUP"
  "LOOKUP_RESPONSE"
  "MESSAGE"
  "NEW_TXN"
  "NEW_TXN_RESPONSE"
  "PARTITIONED_METADATA"
  "PARTITIONED_METADATA_RESPONSE"
  "PING"
  "PONG"
  "PRODUCER"
  "PRODUCER_SUCCESS"
  "REACHED_END_OF_TOPIC"
  "REDELIVER_UNACKNOWLEDGED_MESSAGES"
  "SEEK"
  "SEND"
  "SEND_ERROR"
  "SEND_RECEIPT"
  "SUBSCRIBE"
  "SUCCESS"
  "TC_CLIENT_CONNECT_REQUEST"
  "TC_CLIENT_CONNECT_RESPONSE"
  "TOPIC_MIGRATED"
  "UNSUBSCRIBE"
  "WATCH_TOPIC_LIST"
  "WATCH_TOPIC_LIST_CLOSE"
  "WATCH_TOPIC_LIST_SUCCESS"
  "WATCH_TOPIC_UPDATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BaseCommand_Type_entries[] = {
  { {BaseCommand_Type_names + 0, 3}, 10 },
  { {BaseCommand_Type_names + 3, 12}, 38 },
  { {BaseCommand_Type_names + 15, 22}, 31 },
  { {BaseCommand_Type_names + 37, 20}, 52 },
  { {BaseCommand_Type_names + 57, 29}, 53 },
  { {BaseCommand_Type_names + 86, 23}, 54 },
  { {BaseCommand_Type_names + 109, 32}, 55 },
  { {BaseCommand_Type_names + 141, 14}, 36 },
  { {BaseCommand_Type_names + 155, 13}, 37 },
  { {BaseCommand_Type_names + 168, 14}, 16 },
  { {BaseCommand_Type_names + 182, 14}, 15 },
  { {BaseCommand_Type_names + 196, 7}, 2 },
  { {BaseCommand_Type_names + 203, 9}, 3 },
  { {BaseCommand_Type_names + 212, 14}, 25 },
  { {BaseCommand_Type_names + 226, 23}, 26 },
  { {BaseCommand_Type_names + 249, 7}, 56 },
  { {BaseCommand_Type_names + 256, 20}, 58 },
  { {BaseCommand_Type_names + 276, 29}, 59 },
  { {BaseCommand_Type_names + 305, 23}, 60 },
  { {BaseCommand_Type_names + 328, 32}, 61 },
  { {BaseCommand_Type_names + 360, 16}, 57 },
  { {BaseCommand_Type_names + 376, 5}, 14 },
  { {BaseCommand_Type_names + 381, 4}, 11 },
  { {BaseCommand_Type_names + 385, 19}, 29 },
  { {BaseCommand_Type_names + 404, 28}, 30 },
  { {BaseCommand_Type_names + 432, 20}, 39 },
  { {BaseCommand_Type_names + 452, 29}, 40 },
  { {BaseCommand_Type_names + 481, 10}, 34 },
  { {BaseCommand_Type_names + 491, 19}, 35 },
  { {BaseCommand_Type_names + 510, 23}, 32 },
  { {BaseCommand_Type_names + 533, 32}, 33 },
  { {BaseCommand_Type_names + 565, 6}, 23 },
  { {BaseCommand_Type_names + 571, 15}, 24 },
  { {BaseCommand_Type_names + 586, 7}, 9 },
  { {BaseCommand_Type_names + 593, 7}, 50 },
  { {BaseCommand_Type_names + 600, 16}, 51 },
  { {BaseCommand_Type_names + 616, 20}, 21 },
  { {BaseCommand_Type_names + 636, 29}, 22 },
  { {BaseCommand_Type_names + 665, 4}, 18 },
  { {BaseCommand_Type_names + 669, 4}, 19 },
  { {BaseCommand_Type_names + 673, 8}, 5 },
  { {BaseCommand_Type_names + 681, 16}, 17 },
  { {BaseCommand_Type_names + 697, 20}, 27 },
  { {BaseCommand_Type_names + 717, 33}, 20 },
  { {BaseCommand_Type_names + 750, 4}, 28 },
  { {BaseCommand_Type_names + 754, 4}, 6 },
  { {BaseCommand_Type_names + 758, 10}, 8 },
  { {BaseCommand_Type_names + 768, 12}, 7 },
  { {BaseCommand_Type_names + 780, 9}, 4 },
  { {BaseCommand_Type_names + 789, 7}, 13 },
  { {BaseCommand_Type_names + 796, 25}, 62 },
  { {BaseCommand_Type_names + 821, 26}, 63 },
  { {BaseCommand_Type_names + 847, 14}, 68 },
  { {BaseCommand_Type_names + 861, 11}, 12 },
  { {BaseCommand_Type_names + 872, 16}, 64 },
  { {BaseCommand_Type_names + 888, 22}, 67 },
  { {BaseCommand_Type_names + 910, 24}, 65 },
  { {BaseCommand_Type_names + 934, 18}, 66 },
};

static const int BaseCommand_Type_entries_by_number[] = {
  11, // 2 -> CONNECT
  12, // 3 -> CONNECTED
  48, // 4 -> SUBSCRIBE
  40, // 5 -> PRODUCER
  45, // 6 -> SEND
  47, // 7 -> SEND_RECEIPT
  46, // 8 -> SEND_ERROR
  33, // 9 -> MESSAGE
  0, // 10 -> ACK
  22, // 11 -> FLOW
  53, // 12 -> UNSUBSCRIBE
  49, // 13 -> SUCCESS
  21, // 14 -> ERROR
  10, // 15 -> CLOSE_PRODUCER
  9, // 16 -> CLOSE_CONSUMER
  41, // 17 -> PRODUCER_SUCCESS
  38, // 18 -> PING
  39, // 19 -> PONG
  43, // 20 -> REDELIVER_UNACKNOWLEDGED_MESSAGES
  36, // 21 -> PARTITIONED_METADATA
  37, // 22 -> PARTITIONED_METADATA_RESPONSE
  31, // 23 -> LOOKUP
  32, // 24 -> LOOKUP_RESPONSE
  13, // 25 -> CONSUMER_STATS
  14, // 26 -> CONSUMER_STATS_RESPONSE
  42, // 27 -> REACHED_END_OF_TOPIC
  44, // 28 -> SEEK
  23, // 29 -> GET_LAST_MESSAGE_ID
  24, // 30 -> GET_LAST_MESSAGE_ID_RESPONSE
  2, // 31 -> ACTIVE_CONSUMER_CHANGE
  29, // 32 -> GET_TOPICS_OF_NAMESPACE
  30, // 33 -> GET_TOPICS_OF_NAMESPACE_RESPONSE
  27, // 34 -> GET_SCHEMA
  28, // 35 -> GET_SCHEMA_RESPONSE
  7, // 36 -> AUTH_CHALLENGE
  8, // 37 -> AUTH_RESPONSE
  1, // 38 -> ACK_RESPONSE
  25, // 39 -> GET_OR_CREATE_SCHEMA
  26, // 40 -> GET_OR_CREATE_SCHEMA_RESPONSE
  34, // 50 -> NEW_TXN
  35, // 51 -> NEW_TXN_RESPONSE
  3, // 52 -> ADD_PARTITION_TO_TXN
  4, // 53 -> ADD_PARTITION_TO_TXN_RESPONSE
  5, // 54 -> ADD_SUBSCRIPTION_TO_TXN
  6, // 55 -> ADD_SUBSCRIPTION_TO_TXN_RESPONSE
  15, // 56 -> END_TXN
  20, // 57 -> END_TXN_RESPONSE
  16, // 58 -> END_TXN_ON_PARTITION
  17, // 59 -> END_TXN_ON_PARTITION_RESPONSE
  18, // 60 -> END_TXN_ON_SUBSCRIPTION
  19, // 61 -> END_TXN_ON_SUBSCRIPTION_RESPONSE
  50, // 62 -> TC_CLIENT_CONNECT_REQUEST
  51, // 63 -> TC_CLIENT_CONNECT_RESPONSE
  54, // 64 -> WATCH_TOPIC_LIST
  56, // 65 -> WATCH_TOPIC_LIST_SUCCESS
  57, // 66 -> WATCH_TOPIC_UPDATE
  55, // 67 -> WATCH_TOPIC_LIST_CLOSE
  52, // 68 -> TOPIC_MIGRATED
};

const std::string& BaseCommand_Type_Name(
    BaseCommand_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BaseCommand_Type_entries,
          BaseCommand_Type_entries_by_number,
          58, BaseCommand_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BaseCommand_Type_entries,
      BaseCommand_Type_entries_by_number,
      58, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BaseCommand_Type_strings[idx].get();
}
bool BaseCommand_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BaseCommand_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BaseCommand_Type_entries, 58, name, &int_value);
  if (success) {
    *value = static_cast<BaseCommand_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr BaseCommand_Type BaseCommand::CONNECT;
constexpr BaseCommand_Type BaseCommand::CONNECTED;
constexpr BaseCommand_Type BaseCommand::SUBSCRIBE;
constexpr BaseCommand_Type BaseCommand::PRODUCER;
constexpr BaseCommand_Type BaseCommand::SEND;
constexpr BaseCommand_Type BaseCommand::SEND_RECEIPT;
constexpr BaseCommand_Type BaseCommand::SEND_ERROR;
constexpr BaseCommand_Type BaseCommand::MESSAGE;
constexpr BaseCommand_Type BaseCommand::ACK;
constexpr BaseCommand_Type BaseCommand::FLOW;
constexpr BaseCommand_Type BaseCommand::UNSUBSCRIBE;
constexpr BaseCommand_Type BaseCommand::SUCCESS;
constexpr BaseCommand_Type BaseCommand::ERROR;
constexpr BaseCommand_Type BaseCommand::CLOSE_PRODUCER;
constexpr BaseCommand_Type BaseCommand::CLOSE_CONSUMER;
constexpr BaseCommand_Type BaseCommand::PRODUCER_SUCCESS;
constexpr BaseCommand_Type BaseCommand::PING;
constexpr BaseCommand_Type BaseCommand::PONG;
constexpr BaseCommand_Type BaseCommand::REDELIVER_UNACKNOWLEDGED_MESSAGES;
constexpr BaseCommand_Type BaseCommand::PARTITIONED_METADATA;
constexpr BaseCommand_Type BaseCommand::PARTITIONED_METADATA_RESPONSE;
constexpr BaseCommand_Type BaseCommand::LOOKUP;
constexpr BaseCommand_Type BaseCommand::LOOKUP_RESPONSE;
constexpr BaseCommand_Type BaseCommand::CONSUMER_STATS;
constexpr BaseCommand_Type BaseCommand::CONSUMER_STATS_RESPONSE;
constexpr BaseCommand_Type BaseCommand::REACHED_END_OF_TOPIC;
constexpr BaseCommand_Type BaseCommand::SEEK;
constexpr BaseCommand_Type BaseCommand::GET_LAST_MESSAGE_ID;
constexpr BaseCommand_Type BaseCommand::GET_LAST_MESSAGE_ID_RESPONSE;
constexpr BaseCommand_Type BaseCommand::ACTIVE_CONSUMER_CHANGE;
constexpr BaseCommand_Type BaseCommand::GET_TOPICS_OF_NAMESPACE;
constexpr BaseCommand_Type BaseCommand::GET_TOPICS_OF_NAMESPACE_RESPONSE;
constexpr BaseCommand_Type BaseCommand::GET_SCHEMA;
constexpr BaseCommand_Type BaseCommand::GET_SCHEMA_RESPONSE;
constexpr BaseCommand_Type BaseCommand::AUTH_CHALLENGE;
constexpr BaseCommand_Type BaseCommand::AUTH_RESPONSE;
constexpr BaseCommand_Type BaseCommand::ACK_RESPONSE;
constexpr BaseCommand_Type BaseCommand::GET_OR_CREATE_SCHEMA;
constexpr BaseCommand_Type BaseCommand::GET_OR_CREATE_SCHEMA_RESPONSE;
constexpr BaseCommand_Type BaseCommand::NEW_TXN;
constexpr BaseCommand_Type BaseCommand::NEW_TXN_RESPONSE;
constexpr BaseCommand_Type BaseCommand::ADD_PARTITION_TO_TXN;
constexpr BaseCommand_Type BaseCommand::ADD_PARTITION_TO_TXN_RESPONSE;
constexpr BaseCommand_Type BaseCommand::ADD_SUBSCRIPTION_TO_TXN;
constexpr BaseCommand_Type BaseCommand::ADD_SUBSCRIPTION_TO_TXN_RESPONSE;
constexpr BaseCommand_Type BaseCommand::END_TXN;
constexpr BaseCommand_Type BaseCommand::END_TXN_RESPONSE;
constexpr BaseCommand_Type BaseCommand::END_TXN_ON_PARTITION;
constexpr BaseCommand_Type BaseCommand::END_TXN_ON_PARTITION_RESPONSE;
constexpr BaseCommand_Type BaseCommand::END_TXN_ON_SUBSCRIPTION;
constexpr BaseCommand_Type BaseCommand::END_TXN_ON_SUBSCRIPTION_RESPONSE;
constexpr BaseCommand_Type BaseCommand::TC_CLIENT_CONNECT_REQUEST;
constexpr BaseCommand_Type BaseCommand::TC_CLIENT_CONNECT_RESPONSE;
constexpr BaseCommand_Type BaseCommand::WATCH_TOPIC_LIST;
constexpr BaseCommand_Type BaseCommand::WATCH_TOPIC_LIST_SUCCESS;
constexpr BaseCommand_Type BaseCommand::WATCH_TOPIC_UPDATE;
constexpr BaseCommand_Type BaseCommand::WATCH_TOPIC_LIST_CLOSE;
constexpr BaseCommand_Type BaseCommand::TOPIC_MIGRATED;
constexpr BaseCommand_Type BaseCommand::Type_MIN;
constexpr BaseCommand_Type BaseCommand::Type_MAX;
constexpr int BaseCommand::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool CompressionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CompressionType_strings[5] = {};

static const char CompressionType_names[] =
  "LZ4"
  "NONE"
  "SNAPPY"
  "ZLIB"
  "ZSTD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CompressionType_entries[] = {
  { {CompressionType_names + 0, 3}, 1 },
  { {CompressionType_names + 3, 4}, 0 },
  { {CompressionType_names + 7, 6}, 4 },
  { {CompressionType_names + 13, 4}, 2 },
  { {CompressionType_names + 17, 4}, 3 },
};

static const int CompressionType_entries_by_number[] = {
  1, // 0 -> NONE
  0, // 1 -> LZ4
  3, // 2 -> ZLIB
  4, // 3 -> ZSTD
  2, // 4 -> SNAPPY
};

const std::string& CompressionType_Name(
    CompressionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CompressionType_entries,
          CompressionType_entries_by_number,
          5, CompressionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CompressionType_entries,
      CompressionType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CompressionType_strings[idx].get();
}
bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CompressionType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<CompressionType>(int_value);
  }
  return success;
}
bool ProducerAccessMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProducerAccessMode_strings[4] = {};

static const char ProducerAccessMode_names[] =
  "Exclusive"
  "ExclusiveWithFencing"
  "Shared"
  "WaitForExclusive";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProducerAccessMode_entries[] = {
  { {ProducerAccessMode_names + 0, 9}, 1 },
  { {ProducerAccessMode_names + 9, 20}, 3 },
  { {ProducerAccessMode_names + 29, 6}, 0 },
  { {ProducerAccessMode_names + 35, 16}, 2 },
};

static const int ProducerAccessMode_entries_by_number[] = {
  2, // 0 -> Shared
  0, // 1 -> Exclusive
  3, // 2 -> WaitForExclusive
  1, // 3 -> ExclusiveWithFencing
};

const std::string& ProducerAccessMode_Name(
    ProducerAccessMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProducerAccessMode_entries,
          ProducerAccessMode_entries_by_number,
          4, ProducerAccessMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProducerAccessMode_entries,
      ProducerAccessMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProducerAccessMode_strings[idx].get();
}
bool ProducerAccessMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProducerAccessMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProducerAccessMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ProducerAccessMode>(int_value);
  }
  return success;
}
bool ServerError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServerError_strings[26] = {};

static const char ServerError_names[] =
  "AuthenticationError"
  "AuthorizationError"
  "ChecksumError"
  "ConsumerAssignError"
  "ConsumerBusy"
  "ConsumerNotFound"
  "IncompatibleSchema"
  "InvalidTopicName"
  "InvalidTxnStatus"
  "MetadataError"
  "NotAllowedError"
  "PersistenceError"
  "ProducerBlockedQuotaExceededError"
  "ProducerBlockedQuotaExceededException"
  "ProducerBusy"
  "ProducerFenced"
  "ServiceNotReady"
  "SubscriptionNotFound"
  "TooManyRequests"
  "TopicNotFound"
  "TopicTerminatedError"
  "TransactionConflict"
  "TransactionCoordinatorNotFound"
  "TransactionNotFound"
  "UnknownError"
  "UnsupportedVersionError";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServerError_entries[] = {
  { {ServerError_names + 0, 19}, 3 },
  { {ServerError_names + 19, 18}, 4 },
  { {ServerError_names + 37, 13}, 9 },
  { {ServerError_names + 50, 19}, 19 },
  { {ServerError_names + 69, 12}, 5 },
  { {ServerError_names + 81, 16}, 13 },
  { {ServerError_names + 97, 18}, 18 },
  { {ServerError_names + 115, 16}, 17 },
  { {ServerError_names + 131, 16}, 21 },
  { {ServerError_names + 147, 13}, 1 },
  { {ServerError_names + 160, 15}, 22 },
  { {ServerError_names + 175, 16}, 2 },
  { {ServerError_names + 191, 33}, 7 },
  { {ServerError_names + 224, 37}, 8 },
  { {ServerError_names + 261, 12}, 16 },
  { {ServerError_names + 273, 14}, 25 },
  { {ServerError_names + 287, 15}, 6 },
  { {ServerError_names + 302, 20}, 12 },
  { {ServerError_names + 322, 15}, 14 },
  { {ServerError_names + 337, 13}, 11 },
  { {ServerError_names + 350, 20}, 15 },
  { {ServerError_names + 370, 19}, 23 },
  { {ServerError_names + 389, 30}, 20 },
  { {ServerError_names + 419, 19}, 24 },
  { {ServerError_names + 438, 12}, 0 },
  { {ServerError_names + 450, 23}, 10 },
};

static const int ServerError_entries_by_number[] = {
  24, // 0 -> UnknownError
  9, // 1 -> MetadataError
  11, // 2 -> PersistenceError
  0, // 3 -> AuthenticationError
  1, // 4 -> AuthorizationError
  4, // 5 -> ConsumerBusy
  16, // 6 -> ServiceNotReady
  12, // 7 -> ProducerBlockedQuotaExceededError
  13, // 8 -> ProducerBlockedQuotaExceededException
  2, // 9 -> ChecksumError
  25, // 10 -> UnsupportedVersionError
  19, // 11 -> TopicNotFound
  17, // 12 -> SubscriptionNotFound
  5, // 13 -> ConsumerNotFound
  18, // 14 -> TooManyRequests
  20, // 15 -> TopicTerminatedError
  14, // 16 -> ProducerBusy
  7, // 17 -> InvalidTopicName
  6, // 18 -> IncompatibleSchema
  3, // 19 -> ConsumerAssignError
  22, // 20 -> TransactionCoordinatorNotFound
  8, // 21 -> InvalidTxnStatus
  10, // 22 -> NotAllowedError
  21, // 23 -> TransactionConflict
  23, // 24 -> TransactionNotFound
  15, // 25 -> ProducerFenced
};

const std::string& ServerError_Name(
    ServerError value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServerError_entries,
          ServerError_entries_by_number,
          26, ServerError_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServerError_entries,
      ServerError_entries_by_number,
      26, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServerError_strings[idx].get();
}
bool ServerError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerError* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServerError_entries, 26, name, &int_value);
  if (success) {
    *value = static_cast<ServerError>(int_value);
  }
  return success;
}
bool AuthMethod_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AuthMethod_strings[3] = {};

static const char AuthMethod_names[] =
  "AuthMethodAthens"
  "AuthMethodNone"
  "AuthMethodYcaV1";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AuthMethod_entries[] = {
  { {AuthMethod_names + 0, 16}, 2 },
  { {AuthMethod_names + 16, 14}, 0 },
  { {AuthMethod_names + 30, 15}, 1 },
};

static const int AuthMethod_entries_by_number[] = {
  1, // 0 -> AuthMethodNone
  2, // 1 -> AuthMethodYcaV1
  0, // 2 -> AuthMethodAthens
};

const std::string& AuthMethod_Name(
    AuthMethod value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AuthMethod_entries,
          AuthMethod_entries_by_number,
          3, AuthMethod_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AuthMethod_entries,
      AuthMethod_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AuthMethod_strings[idx].get();
}
bool AuthMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AuthMethod* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AuthMethod_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AuthMethod>(int_value);
  }
  return success;
}
bool ProtocolVersion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProtocolVersion_strings[21] = {};

static const char ProtocolVersion_names[] =
  "v0"
  "v1"
  "v10"
  "v11"
  "v12"
  "v13"
  "v14"
  "v15"
  "v16"
  "v17"
  "v18"
  "v19"
  "v2"
  "v20"
  "v3"
  "v4"
  "v5"
  "v6"
  "v7"
  "v8"
  "v9";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProtocolVersion_entries[] = {
  { {ProtocolVersion_names + 0, 2}, 0 },
  { {ProtocolVersion_names + 2, 2}, 1 },
  { {ProtocolVersion_names + 4, 3}, 10 },
  { {ProtocolVersion_names + 7, 3}, 11 },
  { {ProtocolVersion_names + 10, 3}, 12 },
  { {ProtocolVersion_names + 13, 3}, 13 },
  { {ProtocolVersion_names + 16, 3}, 14 },
  { {ProtocolVersion_names + 19, 3}, 15 },
  { {ProtocolVersion_names + 22, 3}, 16 },
  { {ProtocolVersion_names + 25, 3}, 17 },
  { {ProtocolVersion_names + 28, 3}, 18 },
  { {ProtocolVersion_names + 31, 3}, 19 },
  { {ProtocolVersion_names + 34, 2}, 2 },
  { {ProtocolVersion_names + 36, 3}, 20 },
  { {ProtocolVersion_names + 39, 2}, 3 },
  { {ProtocolVersion_names + 41, 2}, 4 },
  { {ProtocolVersion_names + 43, 2}, 5 },
  { {ProtocolVersion_names + 45, 2}, 6 },
  { {ProtocolVersion_names + 47, 2}, 7 },
  { {ProtocolVersion_names + 49, 2}, 8 },
  { {ProtocolVersion_names + 51, 2}, 9 },
};

static const int ProtocolVersion_entries_by_number[] = {
  0, // 0 -> v0
  1, // 1 -> v1
  12, // 2 -> v2
  14, // 3 -> v3
  15, // 4 -> v4
  16, // 5 -> v5
  17, // 6 -> v6
  18, // 7 -> v7
  19, // 8 -> v8
  20, // 9 -> v9
  2, // 10 -> v10
  3, // 11 -> v11
  4, // 12 -> v12
  5, // 13 -> v13
  6, // 14 -> v14
  7, // 15 -> v15
  8, // 16 -> v16
  9, // 17 -> v17
  10, // 18 -> v18
  11, // 19 -> v19
  13, // 20 -> v20
};

const std::string& ProtocolVersion_Name(
    ProtocolVersion value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProtocolVersion_entries,
          ProtocolVersion_entries_by_number,
          21, ProtocolVersion_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProtocolVersion_entries,
      ProtocolVersion_entries_by_number,
      21, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProtocolVersion_strings[idx].get();
}
bool ProtocolVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProtocolVersion* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProtocolVersion_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<ProtocolVersion>(int_value);
  }
  return success;
}
bool KeySharedMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KeySharedMode_strings[2] = {};

static const char KeySharedMode_names[] =
  "AUTO_SPLIT"
  "STICKY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KeySharedMode_entries[] = {
  { {KeySharedMode_names + 0, 10}, 0 },
  { {KeySharedMode_names + 10, 6}, 1 },
};

static const int KeySharedMode_entries_by_number[] = {
  0, // 0 -> AUTO_SPLIT
  1, // 1 -> STICKY
};

const std::string& KeySharedMode_Name(
    KeySharedMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KeySharedMode_entries,
          KeySharedMode_entries_by_number,
          2, KeySharedMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KeySharedMode_entries,
      KeySharedMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KeySharedMode_strings[idx].get();
}
bool KeySharedMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeySharedMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KeySharedMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<KeySharedMode>(int_value);
  }
  return success;
}
bool TxnAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TxnAction_strings[2] = {};

static const char TxnAction_names[] =
  "ABORT"
  "COMMIT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TxnAction_entries[] = {
  { {TxnAction_names + 0, 5}, 1 },
  { {TxnAction_names + 5, 6}, 0 },
};

static const int TxnAction_entries_by_number[] = {
  1, // 0 -> COMMIT
  0, // 1 -> ABORT
};

const std::string& TxnAction_Name(
    TxnAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TxnAction_entries,
          TxnAction_entries_by_number,
          2, TxnAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TxnAction_entries,
      TxnAction_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TxnAction_strings[idx].get();
}
bool TxnAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TxnAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TxnAction_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<TxnAction>(int_value);
  }
  return success;
}

// ===================================================================

class Schema::_Internal {
 public:
  using HasBits = decltype(std::declval<Schema>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_schema_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Schema::Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  properties_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.Schema)
}
Schema::Schema(const Schema& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      properties_(from.properties_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  schema_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema_data()) {
    schema_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema_data(), 
      GetArenaForAllocation());
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.Schema)
}

inline void Schema::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
schema_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
type_ = 0;
}

Schema::~Schema() {
  // @@protoc_insertion_point(destructor:pulsar.proto.Schema)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Schema::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  schema_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Schema::ArenaDtor(void* object) {
  Schema* _this = reinterpret_cast< Schema* >(object);
  (void)_this;
}
void Schema::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Schema::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Schema::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.Schema)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  properties_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      schema_data_.ClearNonDefaultToEmpty();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Schema::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes schema_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_schema_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pulsar.proto.Schema.Type type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::Schema_Type_IsValid(val))) {
            _internal_set_type(static_cast<::pulsar::proto::Schema_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.KeyValue properties = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Schema::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.Schema)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required bytes schema_data = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_schema_data(), target);
  }

  // required .pulsar.proto.Schema.Type type = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // repeated .pulsar.proto.KeyValue properties = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_properties_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_properties(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.Schema)
  return target;
}

size_t Schema::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.Schema)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_schema_data()) {
    // required bytes schema_data = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_schema_data());
  }

  if (_internal_has_type()) {
    // required .pulsar.proto.Schema.Type type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t Schema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.Schema)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required bytes schema_data = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_schema_data());

    // required .pulsar.proto.Schema.Type type = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue properties = 5;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Schema::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Schema*>(
      &from));
}

void Schema::MergeFrom(const Schema& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.Schema)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  properties_.MergeFrom(from.properties_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_schema_data(from._internal_schema_data());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Schema::CopyFrom(const Schema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.Schema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Schema::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(properties_)) return false;
  return true;
}

void Schema::InternalSwap(Schema* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  properties_.InternalSwap(&other->properties_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, GetArenaForAllocation(),
      &other->name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_data_, GetArenaForAllocation(),
      &other->schema_data_, other->GetArenaForAllocation()
  );
  swap(type_, other->type_);
}

std::string Schema::GetTypeName() const {
  return "pulsar.proto.Schema";
}


// ===================================================================

class MessageIdData::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageIdData>()._has_bits_);
  static void set_has_ledgerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entryid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_partition(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_batch_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_batch_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pulsar::proto::MessageIdData& first_chunk_message_id(const MessageIdData* msg);
  static void set_has_first_chunk_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::pulsar::proto::MessageIdData&
MessageIdData::_Internal::first_chunk_message_id(const MessageIdData* msg) {
  return *msg->first_chunk_message_id_;
}
MessageIdData::MessageIdData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  ack_set_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.MessageIdData)
}
MessageIdData::MessageIdData(const MessageIdData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      ack_set_(from.ack_set_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_first_chunk_message_id()) {
    first_chunk_message_id_ = new ::pulsar::proto::MessageIdData(*from.first_chunk_message_id_);
  } else {
    first_chunk_message_id_ = nullptr;
  }
  ::memcpy(&ledgerid_, &from.ledgerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&batch_index_) -
    reinterpret_cast<char*>(&ledgerid_)) + sizeof(batch_index_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.MessageIdData)
}

inline void MessageIdData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&first_chunk_message_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&batch_size_) -
    reinterpret_cast<char*>(&first_chunk_message_id_)) + sizeof(batch_size_));
partition_ = -1;
batch_index_ = -1;
}

MessageIdData::~MessageIdData() {
  // @@protoc_insertion_point(destructor:pulsar.proto.MessageIdData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MessageIdData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete first_chunk_message_id_;
}

void MessageIdData::ArenaDtor(void* object) {
  MessageIdData* _this = reinterpret_cast< MessageIdData* >(object);
  (void)_this;
}
void MessageIdData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MessageIdData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MessageIdData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.MessageIdData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ack_set_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(first_chunk_message_id_ != nullptr);
    first_chunk_message_id_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&ledgerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&batch_size_) -
        reinterpret_cast<char*>(&ledgerid_)) + sizeof(batch_size_));
    partition_ = -1;
    batch_index_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MessageIdData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 ledgerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_ledgerid(&has_bits);
          ledgerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 entryId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_entryid(&has_bits);
          entryid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 partition = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_partition(&has_bits);
          partition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 batch_index = 4 [default = -1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_batch_index(&has_bits);
          batch_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 ack_set = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ack_set(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_ack_set(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 batch_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_batch_size(&has_bits);
          batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_chunk_message_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MessageIdData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.MessageIdData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 ledgerId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ledgerid(), target);
  }

  // required uint64 entryId = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_entryid(), target);
  }

  // optional int32 partition = 3 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_partition(), target);
  }

  // optional int32 batch_index = 4 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_batch_index(), target);
  }

  // repeated int64 ack_set = 5;
  for (int i = 0, n = this->_internal_ack_set_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_ack_set(i), target);
  }

  // optional int32 batch_size = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_batch_size(), target);
  }

  // optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::first_chunk_message_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.MessageIdData)
  return target;
}

size_t MessageIdData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.MessageIdData)
  size_t total_size = 0;

  if (_internal_has_ledgerid()) {
    // required uint64 ledgerId = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_ledgerid());
  }

  if (_internal_has_entryid()) {
    // required uint64 entryId = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_entryid());
  }

  return total_size;
}
size_t MessageIdData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.MessageIdData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint64 ledgerId = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_ledgerid());

    // required uint64 entryId = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_entryid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 ack_set = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->ack_set_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_ack_set_size());
    total_size += data_size;
  }

  // optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *first_chunk_message_id_);
  }

  if (cached_has_bits & 0x00000038u) {
    // optional int32 batch_size = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_batch_size());
    }

    // optional int32 partition = 3 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_partition());
    }

    // optional int32 batch_index = 4 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_batch_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessageIdData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MessageIdData*>(
      &from));
}

void MessageIdData::MergeFrom(const MessageIdData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.MessageIdData)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  ack_set_.MergeFrom(from.ack_set_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_first_chunk_message_id()->::pulsar::proto::MessageIdData::MergeFrom(from._internal_first_chunk_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerid_ = from.ledgerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      entryid_ = from.entryid_;
    }
    if (cached_has_bits & 0x00000008u) {
      batch_size_ = from.batch_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      partition_ = from.partition_;
    }
    if (cached_has_bits & 0x00000020u) {
      batch_index_ = from.batch_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MessageIdData::CopyFrom(const MessageIdData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.MessageIdData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageIdData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_first_chunk_message_id()) {
    if (!first_chunk_message_id_->IsInitialized()) return false;
  }
  return true;
}

void MessageIdData::InternalSwap(MessageIdData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ack_set_.InternalSwap(&other->ack_set_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageIdData, batch_size_)
      + sizeof(MessageIdData::batch_size_)
      - PROTOBUF_FIELD_OFFSET(MessageIdData, first_chunk_message_id_)>(
          reinterpret_cast<char*>(&first_chunk_message_id_),
          reinterpret_cast<char*>(&other->first_chunk_message_id_));
  swap(partition_, other->partition_);
  swap(batch_index_, other->batch_index_);
}

std::string MessageIdData::GetTypeName() const {
  return "pulsar.proto.MessageIdData";
}


// ===================================================================

class KeyValue::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyValue>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

KeyValue::KeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.KeyValue)
}
KeyValue::KeyValue(const KeyValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.KeyValue)
}

inline void KeyValue::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

KeyValue::~KeyValue() {
  // @@protoc_insertion_point(destructor:pulsar.proto.KeyValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void KeyValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KeyValue::ArenaDtor(void* object) {
  KeyValue* _this = reinterpret_cast< KeyValue* >(object);
  (void)_this;
}
void KeyValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyValue::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.KeyValue)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeyValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KeyValue::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.KeyValue)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.KeyValue)
  return target;
}

size_t KeyValue::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.KeyValue)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  if (_internal_has_value()) {
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return total_size;
}
size_t KeyValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.KeyValue)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());

    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeyValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KeyValue*>(
      &from));
}

void KeyValue::MergeFrom(const KeyValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.KeyValue)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyValue::CopyFrom(const KeyValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.KeyValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyValue::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void KeyValue::InternalSwap(KeyValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, GetArenaForAllocation(),
      &other->key_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, GetArenaForAllocation(),
      &other->value_, other->GetArenaForAllocation()
  );
}

std::string KeyValue::GetTypeName() const {
  return "pulsar.proto.KeyValue";
}


// ===================================================================

class KeyLongValue::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyLongValue>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

KeyLongValue::KeyLongValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.KeyLongValue)
}
KeyLongValue::KeyLongValue(const KeyLongValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.KeyLongValue)
}

inline void KeyLongValue::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
value_ = uint64_t{0u};
}

KeyLongValue::~KeyLongValue() {
  // @@protoc_insertion_point(destructor:pulsar.proto.KeyLongValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void KeyLongValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KeyLongValue::ArenaDtor(void* object) {
  KeyLongValue* _this = reinterpret_cast< KeyLongValue* >(object);
  (void)_this;
}
void KeyLongValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyLongValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyLongValue::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.KeyLongValue)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    key_.ClearNonDefaultToEmpty();
  }
  value_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeyLongValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KeyLongValue::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.KeyLongValue)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required uint64 value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.KeyLongValue)
  return target;
}

size_t KeyLongValue::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.KeyLongValue)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  if (_internal_has_value()) {
    // required uint64 value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_value());
  }

  return total_size;
}
size_t KeyLongValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.KeyLongValue)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());

    // required uint64 value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_value());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeyLongValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KeyLongValue*>(
      &from));
}

void KeyLongValue::MergeFrom(const KeyLongValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.KeyLongValue)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      value_ = from.value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyLongValue::CopyFrom(const KeyLongValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.KeyLongValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyLongValue::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void KeyLongValue::InternalSwap(KeyLongValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, GetArenaForAllocation(),
      &other->key_, other->GetArenaForAllocation()
  );
  swap(value_, other->value_);
}

std::string KeyLongValue::GetTypeName() const {
  return "pulsar.proto.KeyLongValue";
}


// ===================================================================

class IntRange::_Internal {
 public:
  using HasBits = decltype(std::declval<IntRange>()._has_bits_);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

IntRange::IntRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.IntRange)
}
IntRange::IntRange(const IntRange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&start_, &from.start_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_) -
    reinterpret_cast<char*>(&start_)) + sizeof(end_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.IntRange)
}

inline void IntRange::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_) -
    reinterpret_cast<char*>(&start_)) + sizeof(end_));
}

IntRange::~IntRange() {
  // @@protoc_insertion_point(destructor:pulsar.proto.IntRange)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void IntRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IntRange::ArenaDtor(void* object) {
  IntRange* _this = reinterpret_cast< IntRange* >(object);
  (void)_this;
}
void IntRange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IntRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IntRange::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.IntRange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&start_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_) -
        reinterpret_cast<char*>(&start_)) + sizeof(end_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IntRange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_end(&has_bits);
          end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* IntRange::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.IntRange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_start(), target);
  }

  // required int32 end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_end(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.IntRange)
  return target;
}

size_t IntRange::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.IntRange)
  size_t total_size = 0;

  if (_internal_has_start()) {
    // required int32 start = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_start());
  }

  if (_internal_has_end()) {
    // required int32 end = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_end());
  }

  return total_size;
}
size_t IntRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.IntRange)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 start = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_start());

    // required int32 end = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_end());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IntRange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const IntRange*>(
      &from));
}

void IntRange::MergeFrom(const IntRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.IntRange)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000002u) {
      end_ = from.end_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IntRange::CopyFrom(const IntRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.IntRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntRange::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IntRange::InternalSwap(IntRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntRange, end_)
      + sizeof(IntRange::end_)
      - PROTOBUF_FIELD_OFFSET(IntRange, start_)>(
          reinterpret_cast<char*>(&start_),
          reinterpret_cast<char*>(&other->start_));
}

std::string IntRange::GetTypeName() const {
  return "pulsar.proto.IntRange";
}


// ===================================================================

class EncryptionKeys::_Internal {
 public:
  using HasBits = decltype(std::declval<EncryptionKeys>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

EncryptionKeys::EncryptionKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  metadata_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.EncryptionKeys)
}
EncryptionKeys::EncryptionKeys(const EncryptionKeys& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      metadata_(from.metadata_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.EncryptionKeys)
}

inline void EncryptionKeys::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

EncryptionKeys::~EncryptionKeys() {
  // @@protoc_insertion_point(destructor:pulsar.proto.EncryptionKeys)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void EncryptionKeys::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EncryptionKeys::ArenaDtor(void* object) {
  EncryptionKeys* _this = reinterpret_cast< EncryptionKeys* >(object);
  (void)_this;
}
void EncryptionKeys::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EncryptionKeys::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EncryptionKeys::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.EncryptionKeys)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  metadata_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EncryptionKeys::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.KeyValue metadata = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EncryptionKeys::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.EncryptionKeys)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  // repeated .pulsar.proto.KeyValue metadata = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_metadata_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_metadata(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.EncryptionKeys)
  return target;
}

size_t EncryptionKeys::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.EncryptionKeys)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  if (_internal_has_value()) {
    // required bytes value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  return total_size;
}
size_t EncryptionKeys::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.EncryptionKeys)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());

    // required bytes value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue metadata = 3;
  total_size += 1UL * this->_internal_metadata_size();
  for (const auto& msg : this->metadata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EncryptionKeys::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EncryptionKeys*>(
      &from));
}

void EncryptionKeys::MergeFrom(const EncryptionKeys& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.EncryptionKeys)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  metadata_.MergeFrom(from.metadata_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EncryptionKeys::CopyFrom(const EncryptionKeys& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.EncryptionKeys)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptionKeys::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(metadata_)) return false;
  return true;
}

void EncryptionKeys::InternalSwap(EncryptionKeys* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  metadata_.InternalSwap(&other->metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, GetArenaForAllocation(),
      &other->key_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, GetArenaForAllocation(),
      &other->value_, other->GetArenaForAllocation()
  );
}

std::string EncryptionKeys::GetTypeName() const {
  return "pulsar.proto.EncryptionKeys";
}


// ===================================================================

class MessageMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageMetadata>()._has_bits_);
  static void set_has_producer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_publish_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_replicated_from(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_partition_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_compression(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_uncompressed_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_num_messages_in_batch(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_event_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_encryption_algo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_encryption_param(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_partition_key_b64_encoded(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_ordering_key(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_deliver_at_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_marker_type(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_highest_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_null_value(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_chunks_from_msg(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_total_chunk_msg_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_chunk_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_null_partition_key(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000301) ^ 0x00000301) != 0;
  }
};

MessageMetadata::MessageMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  properties_(arena),
  replicate_to_(arena),
  encryption_keys_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.MessageMetadata)
}
MessageMetadata::MessageMetadata(const MessageMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      properties_(from.properties_),
      replicate_to_(from.replicate_to_),
      encryption_keys_(from.encryption_keys_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  producer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_producer_name()) {
    producer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_producer_name(), 
      GetArenaForAllocation());
  }
  replicated_from_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_replicated_from()) {
    replicated_from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_replicated_from(), 
      GetArenaForAllocation());
  }
  partition_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_partition_key()) {
    partition_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_partition_key(), 
      GetArenaForAllocation());
  }
  encryption_algo_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_encryption_algo()) {
    encryption_algo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encryption_algo(), 
      GetArenaForAllocation());
  }
  encryption_param_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_encryption_param()) {
    encryption_param_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encryption_param(), 
      GetArenaForAllocation());
  }
  schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema_version()) {
    schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema_version(), 
      GetArenaForAllocation());
  }
  ordering_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ordering_key()) {
    ordering_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ordering_key(), 
      GetArenaForAllocation());
  }
  uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_uuid()) {
    uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_uuid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&sequence_id_, &from.sequence_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_messages_in_batch_) -
    reinterpret_cast<char*>(&sequence_id_)) + sizeof(num_messages_in_batch_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.MessageMetadata)
}

inline void MessageMetadata::SharedCtor() {
producer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
replicated_from_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
partition_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
encryption_algo_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
encryption_param_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
ordering_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sequence_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&chunk_id_) -
    reinterpret_cast<char*>(&sequence_id_)) + sizeof(chunk_id_));
num_messages_in_batch_ = 1;
}

MessageMetadata::~MessageMetadata() {
  // @@protoc_insertion_point(destructor:pulsar.proto.MessageMetadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void MessageMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  producer_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  replicated_from_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  partition_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encryption_algo_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encryption_param_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  schema_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ordering_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  uuid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MessageMetadata::ArenaDtor(void* object) {
  MessageMetadata* _this = reinterpret_cast< MessageMetadata* >(object);
  (void)_this;
}
void MessageMetadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MessageMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MessageMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.MessageMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  properties_.Clear();
  replicate_to_.Clear();
  encryption_keys_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      producer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      replicated_from_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      partition_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      encryption_algo_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      encryption_param_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      schema_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      ordering_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      uuid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&sequence_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&txnid_most_bits_) -
        reinterpret_cast<char*>(&sequence_id_)) + sizeof(txnid_most_bits_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&marker_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&chunk_id_) -
        reinterpret_cast<char*>(&marker_type_)) + sizeof(chunk_id_));
  }
  num_messages_in_batch_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MessageMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string producer_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_producer_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 sequence_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_sequence_id(&has_bits);
          sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 publish_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_publish_time(&has_bits);
          publish_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.KeyValue properties = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string replicated_from = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_replicated_from();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string partition_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_partition_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string replicate_to = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_replicate_to();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::CompressionType_IsValid(val))) {
            _internal_set_compression(static_cast<::pulsar::proto::CompressionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 uncompressed_size = 9 [default = 0];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_uncompressed_size(&has_bits);
          uncompressed_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_messages_in_batch = 11 [default = 1];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_num_messages_in_batch(&has_bits);
          num_messages_in_batch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 event_time = 12 [default = 0];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_event_time(&has_bits);
          event_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_encryption_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string encryption_algo = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          auto str = _internal_mutable_encryption_algo();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes encryption_param = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          auto str = _internal_mutable_encryption_param();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes schema_version = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          auto str = _internal_mutable_schema_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool partition_key_b64_encoded = 17 [default = false];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_partition_key_b64_encoded(&has_bits);
          partition_key_b64_encoded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ordering_key = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          auto str = _internal_mutable_ordering_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 deliver_at_time = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_deliver_at_time(&has_bits);
          deliver_at_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 marker_type = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_marker_type(&has_bits);
          marker_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 highest_sequence_id = 24 [default = 0];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          _Internal::set_has_highest_sequence_id(&has_bits);
          highest_sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool null_value = 25 [default = false];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          _Internal::set_has_null_value(&has_bits);
          null_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string uuid = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210)) {
          auto str = _internal_mutable_uuid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_chunks_from_msg = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _Internal::set_has_num_chunks_from_msg(&has_bits);
          num_chunks_from_msg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 total_chunk_msg_size = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_total_chunk_msg_size(&has_bits);
          total_chunk_msg_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 chunk_id = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_chunk_id(&has_bits);
          chunk_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool null_partition_key = 30 [default = false];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_null_partition_key(&has_bits);
          null_partition_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MessageMetadata::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.MessageMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string producer_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_producer_name(), target);
  }

  // required uint64 sequence_id = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_sequence_id(), target);
  }

  // required uint64 publish_time = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_publish_time(), target);
  }

  // repeated .pulsar.proto.KeyValue properties = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_properties_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_properties(i), target, stream);
  }

  // optional string replicated_from = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_replicated_from(), target);
  }

  // optional string partition_key = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_partition_key(), target);
  }

  // repeated string replicate_to = 7;
  for (int i = 0, n = this->_internal_replicate_to_size(); i < n; i++) {
    const auto& s = this->_internal_replicate_to(i);
    target = stream->WriteString(7, s, target);
  }

  // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_compression(), target);
  }

  // optional uint32 uncompressed_size = 9 [default = 0];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_uncompressed_size(), target);
  }

  // optional int32 num_messages_in_batch = 11 [default = 1];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_num_messages_in_batch(), target);
  }

  // optional uint64 event_time = 12 [default = 0];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(12, this->_internal_event_time(), target);
  }

  // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_encryption_keys_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, this->_internal_encryption_keys(i), target, stream);
  }

  // optional string encryption_algo = 14;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_encryption_algo(), target);
  }

  // optional bytes encryption_param = 15;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_encryption_param(), target);
  }

  // optional bytes schema_version = 16;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        16, this->_internal_schema_version(), target);
  }

  // optional bool partition_key_b64_encoded = 17 [default = false];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_partition_key_b64_encoded(), target);
  }

  // optional bytes ordering_key = 18;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteBytesMaybeAliased(
        18, this->_internal_ordering_key(), target);
  }

  // optional int64 deliver_at_time = 19;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(19, this->_internal_deliver_at_time(), target);
  }

  // optional int32 marker_type = 20;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(20, this->_internal_marker_type(), target);
  }

  // optional uint64 txnid_least_bits = 22;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(22, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 23;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(23, this->_internal_txnid_most_bits(), target);
  }

  // optional uint64 highest_sequence_id = 24 [default = 0];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(24, this->_internal_highest_sequence_id(), target);
  }

  // optional bool null_value = 25 [default = false];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(25, this->_internal_null_value(), target);
  }

  // optional string uuid = 26;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        26, this->_internal_uuid(), target);
  }

  // optional int32 num_chunks_from_msg = 27;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(27, this->_internal_num_chunks_from_msg(), target);
  }

  // optional int32 total_chunk_msg_size = 28;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(28, this->_internal_total_chunk_msg_size(), target);
  }

  // optional int32 chunk_id = 29;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(29, this->_internal_chunk_id(), target);
  }

  // optional bool null_partition_key = 30 [default = false];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(30, this->_internal_null_partition_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.MessageMetadata)
  return target;
}

size_t MessageMetadata::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.MessageMetadata)
  size_t total_size = 0;

  if (_internal_has_producer_name()) {
    // required string producer_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_producer_name());
  }

  if (_internal_has_sequence_id()) {
    // required uint64 sequence_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sequence_id());
  }

  if (_internal_has_publish_time()) {
    // required uint64 publish_time = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_publish_time());
  }

  return total_size;
}
size_t MessageMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.MessageMetadata)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000301) ^ 0x00000301) == 0) {  // All required fields are present.
    // required string producer_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_producer_name());

    // required uint64 sequence_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sequence_id());

    // required uint64 publish_time = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_publish_time());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue properties = 4;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string replicate_to = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(replicate_to_.size());
  for (int i = 0, n = replicate_to_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      replicate_to_.Get(i));
  }

  // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
  total_size += 1UL * this->_internal_encryption_keys_size();
  for (const auto& msg : this->encryption_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string replicated_from = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_replicated_from());
    }

    // optional string partition_key = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_partition_key());
    }

    // optional string encryption_algo = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_encryption_algo());
    }

    // optional bytes encryption_param = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encryption_param());
    }

    // optional bytes schema_version = 16;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_schema_version());
    }

    // optional bytes ordering_key = 18;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ordering_key());
    }

    // optional string uuid = 26;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_uuid());
    }

  }
  if (cached_has_bits & 0x0000fc00u) {
    // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_compression());
    }

    // optional uint32 uncompressed_size = 9 [default = 0];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_uncompressed_size());
    }

    // optional uint64 event_time = 12 [default = 0];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_event_time());
    }

    // optional int64 deliver_at_time = 19;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_deliver_at_time());
    }

    // optional uint64 txnid_least_bits = 22;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 23;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 marker_type = 20;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_marker_type());
    }

    // optional bool partition_key_b64_encoded = 17 [default = false];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool null_value = 25 [default = false];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool null_partition_key = 30 [default = false];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional uint64 highest_sequence_id = 24 [default = 0];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_highest_sequence_id());
    }

    // optional int32 num_chunks_from_msg = 27;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_chunks_from_msg());
    }

    // optional int32 total_chunk_msg_size = 28;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_total_chunk_msg_size());
    }

    // optional int32 chunk_id = 29;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_chunk_id());
    }

  }
  // optional int32 num_messages_in_batch = 11 [default = 1];
  if (cached_has_bits & 0x01000000u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_num_messages_in_batch());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessageMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const MessageMetadata*>(
      &from));
}

void MessageMetadata::MergeFrom(const MessageMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.MessageMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  properties_.MergeFrom(from.properties_);
  replicate_to_.MergeFrom(from.replicate_to_);
  encryption_keys_.MergeFrom(from.encryption_keys_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_producer_name(from._internal_producer_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_replicated_from(from._internal_replicated_from());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_partition_key(from._internal_partition_key());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_encryption_algo(from._internal_encryption_algo());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_encryption_param(from._internal_encryption_param());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_ordering_key(from._internal_ordering_key());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_uuid(from._internal_uuid());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      sequence_id_ = from.sequence_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      publish_time_ = from.publish_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      compression_ = from.compression_;
    }
    if (cached_has_bits & 0x00000800u) {
      uncompressed_size_ = from.uncompressed_size_;
    }
    if (cached_has_bits & 0x00001000u) {
      event_time_ = from.event_time_;
    }
    if (cached_has_bits & 0x00002000u) {
      deliver_at_time_ = from.deliver_at_time_;
    }
    if (cached_has_bits & 0x00004000u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00008000u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      marker_type_ = from.marker_type_;
    }
    if (cached_has_bits & 0x00020000u) {
      partition_key_b64_encoded_ = from.partition_key_b64_encoded_;
    }
    if (cached_has_bits & 0x00040000u) {
      null_value_ = from.null_value_;
    }
    if (cached_has_bits & 0x00080000u) {
      null_partition_key_ = from.null_partition_key_;
    }
    if (cached_has_bits & 0x00100000u) {
      highest_sequence_id_ = from.highest_sequence_id_;
    }
    if (cached_has_bits & 0x00200000u) {
      num_chunks_from_msg_ = from.num_chunks_from_msg_;
    }
    if (cached_has_bits & 0x00400000u) {
      total_chunk_msg_size_ = from.total_chunk_msg_size_;
    }
    if (cached_has_bits & 0x00800000u) {
      chunk_id_ = from.chunk_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x01000000u) {
    _internal_set_num_messages_in_batch(from._internal_num_messages_in_batch());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MessageMetadata::CopyFrom(const MessageMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.MessageMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageMetadata::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(properties_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(encryption_keys_)) return false;
  return true;
}

void MessageMetadata::InternalSwap(MessageMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  properties_.InternalSwap(&other->properties_);
  replicate_to_.InternalSwap(&other->replicate_to_);
  encryption_keys_.InternalSwap(&other->encryption_keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &producer_name_, GetArenaForAllocation(),
      &other->producer_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &replicated_from_, GetArenaForAllocation(),
      &other->replicated_from_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &partition_key_, GetArenaForAllocation(),
      &other->partition_key_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encryption_algo_, GetArenaForAllocation(),
      &other->encryption_algo_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encryption_param_, GetArenaForAllocation(),
      &other->encryption_param_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_version_, GetArenaForAllocation(),
      &other->schema_version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ordering_key_, GetArenaForAllocation(),
      &other->ordering_key_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &uuid_, GetArenaForAllocation(),
      &other->uuid_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageMetadata, chunk_id_)
      + sizeof(MessageMetadata::chunk_id_)
      - PROTOBUF_FIELD_OFFSET(MessageMetadata, sequence_id_)>(
          reinterpret_cast<char*>(&sequence_id_),
          reinterpret_cast<char*>(&other->sequence_id_));
  swap(num_messages_in_batch_, other->num_messages_in_batch_);
}

std::string MessageMetadata::GetTypeName() const {
  return "pulsar.proto.MessageMetadata";
}


// ===================================================================

class SingleMessageMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<SingleMessageMetadata>()._has_bits_);
  static void set_has_partition_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_payload_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_compacted_out(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_event_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_partition_key_b64_encoded(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ordering_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_null_value(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_null_partition_key(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

SingleMessageMetadata::SingleMessageMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  properties_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.SingleMessageMetadata)
}
SingleMessageMetadata::SingleMessageMetadata(const SingleMessageMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      properties_(from.properties_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  partition_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_partition_key()) {
    partition_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_partition_key(), 
      GetArenaForAllocation());
  }
  ordering_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ordering_key()) {
    ordering_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ordering_key(), 
      GetArenaForAllocation());
  }
  ::memcpy(&event_time_, &from.event_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&sequence_id_) -
    reinterpret_cast<char*>(&event_time_)) + sizeof(sequence_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.SingleMessageMetadata)
}

inline void SingleMessageMetadata::SharedCtor() {
partition_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
ordering_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&event_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sequence_id_) -
    reinterpret_cast<char*>(&event_time_)) + sizeof(sequence_id_));
}

SingleMessageMetadata::~SingleMessageMetadata() {
  // @@protoc_insertion_point(destructor:pulsar.proto.SingleMessageMetadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void SingleMessageMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  partition_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ordering_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SingleMessageMetadata::ArenaDtor(void* object) {
  SingleMessageMetadata* _this = reinterpret_cast< SingleMessageMetadata* >(object);
  (void)_this;
}
void SingleMessageMetadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SingleMessageMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SingleMessageMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.SingleMessageMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  properties_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      partition_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ordering_key_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&event_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&null_partition_key_) -
        reinterpret_cast<char*>(&event_time_)) + sizeof(null_partition_key_));
  }
  sequence_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SingleMessageMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pulsar.proto.KeyValue properties = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string partition_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_partition_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 payload_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_payload_size(&has_bits);
          payload_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool compacted_out = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_compacted_out(&has_bits);
          compacted_out_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 event_time = 5 [default = 0];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_event_time(&has_bits);
          event_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool partition_key_b64_encoded = 6 [default = false];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_partition_key_b64_encoded(&has_bits);
          partition_key_b64_encoded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ordering_key = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_ordering_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 sequence_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_sequence_id(&has_bits);
          sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool null_value = 9 [default = false];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_null_value(&has_bits);
          null_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool null_partition_key = 10 [default = false];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_null_partition_key(&has_bits);
          null_partition_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SingleMessageMetadata::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.SingleMessageMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue properties = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_properties_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_properties(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string partition_key = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_partition_key(), target);
  }

  // required int32 payload_size = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_payload_size(), target);
  }

  // optional bool compacted_out = 4 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_compacted_out(), target);
  }

  // optional uint64 event_time = 5 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_event_time(), target);
  }

  // optional bool partition_key_b64_encoded = 6 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_partition_key_b64_encoded(), target);
  }

  // optional bytes ordering_key = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_ordering_key(), target);
  }

  // optional uint64 sequence_id = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_sequence_id(), target);
  }

  // optional bool null_value = 9 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_null_value(), target);
  }

  // optional bool null_partition_key = 10 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_null_partition_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.SingleMessageMetadata)
  return target;
}

size_t SingleMessageMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.SingleMessageMetadata)
  size_t total_size = 0;

  // required int32 payload_size = 3;
  if (_internal_has_payload_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_payload_size());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue properties = 1;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string partition_key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_partition_key());
    }

    // optional bytes ordering_key = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ordering_key());
    }

    // optional uint64 event_time = 5 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_event_time());
    }

  }
  if (cached_has_bits & 0x000000f0u) {
    // optional bool compacted_out = 4 [default = false];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool partition_key_b64_encoded = 6 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool null_value = 9 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool null_partition_key = 10 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional uint64 sequence_id = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sequence_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SingleMessageMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const SingleMessageMetadata*>(
      &from));
}

void SingleMessageMetadata::MergeFrom(const SingleMessageMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.SingleMessageMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  properties_.MergeFrom(from.properties_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_partition_key(from._internal_partition_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ordering_key(from._internal_ordering_key());
    }
    if (cached_has_bits & 0x00000004u) {
      event_time_ = from.event_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      payload_size_ = from.payload_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      compacted_out_ = from.compacted_out_;
    }
    if (cached_has_bits & 0x00000020u) {
      partition_key_b64_encoded_ = from.partition_key_b64_encoded_;
    }
    if (cached_has_bits & 0x00000040u) {
      null_value_ = from.null_value_;
    }
    if (cached_has_bits & 0x00000080u) {
      null_partition_key_ = from.null_partition_key_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_sequence_id(from._internal_sequence_id());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SingleMessageMetadata::CopyFrom(const SingleMessageMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.SingleMessageMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleMessageMetadata::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(properties_)) return false;
  return true;
}

void SingleMessageMetadata::InternalSwap(SingleMessageMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  properties_.InternalSwap(&other->properties_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &partition_key_, GetArenaForAllocation(),
      &other->partition_key_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ordering_key_, GetArenaForAllocation(),
      &other->ordering_key_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, sequence_id_)
      + sizeof(SingleMessageMetadata::sequence_id_)
      - PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, event_time_)>(
          reinterpret_cast<char*>(&event_time_),
          reinterpret_cast<char*>(&other->event_time_));
}

std::string SingleMessageMetadata::GetTypeName() const {
  return "pulsar.proto.SingleMessageMetadata";
}


// ===================================================================

class BrokerEntryMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<BrokerEntryMetadata>()._has_bits_);
  static void set_has_broker_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BrokerEntryMetadata::BrokerEntryMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.BrokerEntryMetadata)
}
BrokerEntryMetadata::BrokerEntryMetadata(const BrokerEntryMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&broker_timestamp_, &from.broker_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&broker_timestamp_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.BrokerEntryMetadata)
}

inline void BrokerEntryMetadata::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&broker_timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&broker_timestamp_)) + sizeof(index_));
}

BrokerEntryMetadata::~BrokerEntryMetadata() {
  // @@protoc_insertion_point(destructor:pulsar.proto.BrokerEntryMetadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BrokerEntryMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrokerEntryMetadata::ArenaDtor(void* object) {
  BrokerEntryMetadata* _this = reinterpret_cast< BrokerEntryMetadata* >(object);
  (void)_this;
}
void BrokerEntryMetadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BrokerEntryMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrokerEntryMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.BrokerEntryMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&broker_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&broker_timestamp_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BrokerEntryMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 broker_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_broker_timestamp(&has_bits);
          broker_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BrokerEntryMetadata::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.BrokerEntryMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 broker_timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_broker_timestamp(), target);
  }

  // optional uint64 index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.BrokerEntryMetadata)
  return target;
}

size_t BrokerEntryMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.BrokerEntryMetadata)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 broker_timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_broker_timestamp());
    }

    // optional uint64 index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BrokerEntryMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BrokerEntryMetadata*>(
      &from));
}

void BrokerEntryMetadata::MergeFrom(const BrokerEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.BrokerEntryMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      broker_timestamp_ = from.broker_timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BrokerEntryMetadata::CopyFrom(const BrokerEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.BrokerEntryMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrokerEntryMetadata::IsInitialized() const {
  return true;
}

void BrokerEntryMetadata::InternalSwap(BrokerEntryMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, index_)
      + sizeof(BrokerEntryMetadata::index_)
      - PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, broker_timestamp_)>(
          reinterpret_cast<char*>(&broker_timestamp_),
          reinterpret_cast<char*>(&other->broker_timestamp_));
}

std::string BrokerEntryMetadata::GetTypeName() const {
  return "pulsar.proto.BrokerEntryMetadata";
}


// ===================================================================

class CommandConnect::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandConnect>()._has_bits_);
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_method(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_auth_method_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_proxy_to_broker_url(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_original_principal(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_original_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_original_auth_method(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::pulsar::proto::FeatureFlags& feature_flags(const CommandConnect* msg);
  static void set_has_feature_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::pulsar::proto::FeatureFlags&
CommandConnect::_Internal::feature_flags(const CommandConnect* msg) {
  return *msg->feature_flags_;
}
CommandConnect::CommandConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandConnect)
}
CommandConnect::CommandConnect(const CommandConnect& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  client_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_client_version()) {
    client_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_client_version(), 
      GetArenaForAllocation());
  }
  auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_auth_data()) {
    auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auth_data(), 
      GetArenaForAllocation());
  }
  auth_method_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_auth_method_name()) {
    auth_method_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auth_method_name(), 
      GetArenaForAllocation());
  }
  proxy_to_broker_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_proxy_to_broker_url()) {
    proxy_to_broker_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_proxy_to_broker_url(), 
      GetArenaForAllocation());
  }
  original_principal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_original_principal()) {
    original_principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_principal(), 
      GetArenaForAllocation());
  }
  original_auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_original_auth_data()) {
    original_auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_auth_data(), 
      GetArenaForAllocation());
  }
  original_auth_method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_original_auth_method()) {
    original_auth_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_auth_method(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_feature_flags()) {
    feature_flags_ = new ::pulsar::proto::FeatureFlags(*from.feature_flags_);
  } else {
    feature_flags_ = nullptr;
  }
  ::memcpy(&auth_method_, &from.auth_method_,
    static_cast<size_t>(reinterpret_cast<char*>(&protocol_version_) -
    reinterpret_cast<char*>(&auth_method_)) + sizeof(protocol_version_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandConnect)
}

inline void CommandConnect::SharedCtor() {
client_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
auth_method_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
proxy_to_broker_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
original_principal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
original_auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
original_auth_method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&feature_flags_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&protocol_version_) -
    reinterpret_cast<char*>(&feature_flags_)) + sizeof(protocol_version_));
}

CommandConnect::~CommandConnect() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandConnect)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandConnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  client_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  auth_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  auth_method_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  proxy_to_broker_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_principal_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_auth_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_auth_method_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete feature_flags_;
}

void CommandConnect::ArenaDtor(void* object) {
  CommandConnect* _this = reinterpret_cast< CommandConnect* >(object);
  (void)_this;
}
void CommandConnect::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandConnect::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandConnect::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandConnect)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      client_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      auth_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      auth_method_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      proxy_to_broker_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      original_principal_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      original_auth_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      original_auth_method_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(feature_flags_ != nullptr);
      feature_flags_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&auth_method_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&protocol_version_) -
        reinterpret_cast<char*>(&auth_method_)) + sizeof(protocol_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandConnect::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string client_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_client_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.AuthMethod auth_method = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::AuthMethod_IsValid(val))) {
            _internal_set_auth_method(static_cast<::pulsar::proto::AuthMethod>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bytes auth_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_auth_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol_version = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_protocol_version(&has_bits);
          protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string auth_method_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_auth_method_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string proxy_to_broker_url = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_proxy_to_broker_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string original_principal = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_original_principal();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string original_auth_data = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_original_auth_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string original_auth_method = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_original_auth_method();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.FeatureFlags feature_flags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_feature_flags(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandConnect::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandConnect)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string client_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_version(), target);
  }

  // optional .pulsar.proto.AuthMethod auth_method = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_auth_method(), target);
  }

  // optional bytes auth_data = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_auth_data(), target);
  }

  // optional int32 protocol_version = 4 [default = 0];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_protocol_version(), target);
  }

  // optional string auth_method_name = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_auth_method_name(), target);
  }

  // optional string proxy_to_broker_url = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_proxy_to_broker_url(), target);
  }

  // optional string original_principal = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_original_principal(), target);
  }

  // optional string original_auth_data = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_original_auth_data(), target);
  }

  // optional string original_auth_method = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_original_auth_method(), target);
  }

  // optional .pulsar.proto.FeatureFlags feature_flags = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::feature_flags(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandConnect)
  return target;
}

size_t CommandConnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandConnect)
  size_t total_size = 0;

  // required string client_version = 1;
  if (_internal_has_client_version()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_version());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional bytes auth_data = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_auth_data());
    }

    // optional string auth_method_name = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_auth_method_name());
    }

    // optional string proxy_to_broker_url = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_proxy_to_broker_url());
    }

    // optional string original_principal = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_principal());
    }

    // optional string original_auth_data = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_auth_data());
    }

    // optional string original_auth_method = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_auth_method());
    }

    // optional .pulsar.proto.FeatureFlags feature_flags = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *feature_flags_);
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .pulsar.proto.AuthMethod auth_method = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_auth_method());
    }

    // optional int32 protocol_version = 4 [default = 0];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_protocol_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandConnect::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandConnect*>(
      &from));
}

void CommandConnect::MergeFrom(const CommandConnect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandConnect)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_client_version(from._internal_client_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_auth_data(from._internal_auth_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_auth_method_name(from._internal_auth_method_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_proxy_to_broker_url(from._internal_proxy_to_broker_url());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_original_principal(from._internal_original_principal());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_original_auth_data(from._internal_original_auth_data());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_original_auth_method(from._internal_original_auth_method());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_feature_flags()->::pulsar::proto::FeatureFlags::MergeFrom(from._internal_feature_flags());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      auth_method_ = from.auth_method_;
    }
    if (cached_has_bits & 0x00000200u) {
      protocol_version_ = from.protocol_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandConnect::CopyFrom(const CommandConnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandConnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandConnect::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandConnect::InternalSwap(CommandConnect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &client_version_, GetArenaForAllocation(),
      &other->client_version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &auth_data_, GetArenaForAllocation(),
      &other->auth_data_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &auth_method_name_, GetArenaForAllocation(),
      &other->auth_method_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &proxy_to_broker_url_, GetArenaForAllocation(),
      &other->proxy_to_broker_url_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_principal_, GetArenaForAllocation(),
      &other->original_principal_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_auth_data_, GetArenaForAllocation(),
      &other->original_auth_data_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_auth_method_, GetArenaForAllocation(),
      &other->original_auth_method_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandConnect, protocol_version_)
      + sizeof(CommandConnect::protocol_version_)
      - PROTOBUF_FIELD_OFFSET(CommandConnect, feature_flags_)>(
          reinterpret_cast<char*>(&feature_flags_),
          reinterpret_cast<char*>(&other->feature_flags_));
}

std::string CommandConnect::GetTypeName() const {
  return "pulsar.proto.CommandConnect";
}


// ===================================================================

class FeatureFlags::_Internal {
 public:
  using HasBits = decltype(std::declval<FeatureFlags>()._has_bits_);
  static void set_has_supports_auth_refresh(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supports_broker_entry_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_supports_partial_producer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_supports_topic_watchers(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

FeatureFlags::FeatureFlags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.FeatureFlags)
}
FeatureFlags::FeatureFlags(const FeatureFlags& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&supports_auth_refresh_, &from.supports_auth_refresh_,
    static_cast<size_t>(reinterpret_cast<char*>(&supports_topic_watchers_) -
    reinterpret_cast<char*>(&supports_auth_refresh_)) + sizeof(supports_topic_watchers_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.FeatureFlags)
}

inline void FeatureFlags::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&supports_auth_refresh_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&supports_topic_watchers_) -
    reinterpret_cast<char*>(&supports_auth_refresh_)) + sizeof(supports_topic_watchers_));
}

FeatureFlags::~FeatureFlags() {
  // @@protoc_insertion_point(destructor:pulsar.proto.FeatureFlags)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void FeatureFlags::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FeatureFlags::ArenaDtor(void* object) {
  FeatureFlags* _this = reinterpret_cast< FeatureFlags* >(object);
  (void)_this;
}
void FeatureFlags::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FeatureFlags::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FeatureFlags::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.FeatureFlags)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&supports_auth_refresh_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&supports_topic_watchers_) -
      reinterpret_cast<char*>(&supports_auth_refresh_)) + sizeof(supports_topic_watchers_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FeatureFlags::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool supports_auth_refresh = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_supports_auth_refresh(&has_bits);
          supports_auth_refresh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool supports_broker_entry_metadata = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_supports_broker_entry_metadata(&has_bits);
          supports_broker_entry_metadata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool supports_partial_producer = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_supports_partial_producer(&has_bits);
          supports_partial_producer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool supports_topic_watchers = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_supports_topic_watchers(&has_bits);
          supports_topic_watchers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FeatureFlags::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.FeatureFlags)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool supports_auth_refresh = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_supports_auth_refresh(), target);
  }

  // optional bool supports_broker_entry_metadata = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_supports_broker_entry_metadata(), target);
  }

  // optional bool supports_partial_producer = 3 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_supports_partial_producer(), target);
  }

  // optional bool supports_topic_watchers = 4 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_supports_topic_watchers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.FeatureFlags)
  return target;
}

size_t FeatureFlags::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.FeatureFlags)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool supports_auth_refresh = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool supports_broker_entry_metadata = 2 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool supports_partial_producer = 3 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool supports_topic_watchers = 4 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FeatureFlags::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FeatureFlags*>(
      &from));
}

void FeatureFlags::MergeFrom(const FeatureFlags& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.FeatureFlags)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      supports_auth_refresh_ = from.supports_auth_refresh_;
    }
    if (cached_has_bits & 0x00000002u) {
      supports_broker_entry_metadata_ = from.supports_broker_entry_metadata_;
    }
    if (cached_has_bits & 0x00000004u) {
      supports_partial_producer_ = from.supports_partial_producer_;
    }
    if (cached_has_bits & 0x00000008u) {
      supports_topic_watchers_ = from.supports_topic_watchers_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FeatureFlags::CopyFrom(const FeatureFlags& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.FeatureFlags)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureFlags::IsInitialized() const {
  return true;
}

void FeatureFlags::InternalSwap(FeatureFlags* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeatureFlags, supports_topic_watchers_)
      + sizeof(FeatureFlags::supports_topic_watchers_)
      - PROTOBUF_FIELD_OFFSET(FeatureFlags, supports_auth_refresh_)>(
          reinterpret_cast<char*>(&supports_auth_refresh_),
          reinterpret_cast<char*>(&other->supports_auth_refresh_));
}

std::string FeatureFlags::GetTypeName() const {
  return "pulsar.proto.FeatureFlags";
}


// ===================================================================

class CommandConnected::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandConnected>()._has_bits_);
  static void set_has_server_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_message_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pulsar::proto::FeatureFlags& feature_flags(const CommandConnected* msg);
  static void set_has_feature_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::pulsar::proto::FeatureFlags&
CommandConnected::_Internal::feature_flags(const CommandConnected* msg) {
  return *msg->feature_flags_;
}
CommandConnected::CommandConnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandConnected)
}
CommandConnected::CommandConnected(const CommandConnected& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  server_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_server_version()) {
    server_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_server_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_feature_flags()) {
    feature_flags_ = new ::pulsar::proto::FeatureFlags(*from.feature_flags_);
  } else {
    feature_flags_ = nullptr;
  }
  ::memcpy(&protocol_version_, &from.protocol_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_message_size_) -
    reinterpret_cast<char*>(&protocol_version_)) + sizeof(max_message_size_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandConnected)
}

inline void CommandConnected::SharedCtor() {
server_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&feature_flags_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_message_size_) -
    reinterpret_cast<char*>(&feature_flags_)) + sizeof(max_message_size_));
}

CommandConnected::~CommandConnected() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandConnected)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandConnected::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  server_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete feature_flags_;
}

void CommandConnected::ArenaDtor(void* object) {
  CommandConnected* _this = reinterpret_cast< CommandConnected* >(object);
  (void)_this;
}
void CommandConnected::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandConnected::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandConnected::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandConnected)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      server_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(feature_flags_ != nullptr);
      feature_flags_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&protocol_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_message_size_) -
        reinterpret_cast<char*>(&protocol_version_)) + sizeof(max_message_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandConnected::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string server_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_server_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol_version = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_protocol_version(&has_bits);
          protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_message_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_message_size(&has_bits);
          max_message_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.FeatureFlags feature_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_feature_flags(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandConnected::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandConnected)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string server_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_server_version(), target);
  }

  // optional int32 protocol_version = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_protocol_version(), target);
  }

  // optional int32 max_message_size = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_message_size(), target);
  }

  // optional .pulsar.proto.FeatureFlags feature_flags = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::feature_flags(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandConnected)
  return target;
}

size_t CommandConnected::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandConnected)
  size_t total_size = 0;

  // required string server_version = 1;
  if (_internal_has_server_version()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_server_version());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .pulsar.proto.FeatureFlags feature_flags = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *feature_flags_);
    }

    // optional int32 protocol_version = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_protocol_version());
    }

    // optional int32 max_message_size = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_message_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandConnected::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandConnected*>(
      &from));
}

void CommandConnected::MergeFrom(const CommandConnected& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandConnected)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_server_version(from._internal_server_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_feature_flags()->::pulsar::proto::FeatureFlags::MergeFrom(from._internal_feature_flags());
    }
    if (cached_has_bits & 0x00000004u) {
      protocol_version_ = from.protocol_version_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_message_size_ = from.max_message_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandConnected::CopyFrom(const CommandConnected& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandConnected)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandConnected::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandConnected::InternalSwap(CommandConnected* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &server_version_, GetArenaForAllocation(),
      &other->server_version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandConnected, max_message_size_)
      + sizeof(CommandConnected::max_message_size_)
      - PROTOBUF_FIELD_OFFSET(CommandConnected, feature_flags_)>(
          reinterpret_cast<char*>(&feature_flags_),
          reinterpret_cast<char*>(&other->feature_flags_));
}

std::string CommandConnected::GetTypeName() const {
  return "pulsar.proto.CommandConnected";
}


// ===================================================================

class CommandAuthResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAuthResponse>()._has_bits_);
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::AuthData& response(const CommandAuthResponse* msg);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::pulsar::proto::AuthData&
CommandAuthResponse::_Internal::response(const CommandAuthResponse* msg) {
  return *msg->response_;
}
CommandAuthResponse::CommandAuthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAuthResponse)
}
CommandAuthResponse::CommandAuthResponse(const CommandAuthResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  client_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_client_version()) {
    client_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_client_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_response()) {
    response_ = new ::pulsar::proto::AuthData(*from.response_);
  } else {
    response_ = nullptr;
  }
  protocol_version_ = from.protocol_version_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAuthResponse)
}

inline void CommandAuthResponse::SharedCtor() {
client_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&response_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&protocol_version_) -
    reinterpret_cast<char*>(&response_)) + sizeof(protocol_version_));
}

CommandAuthResponse::~CommandAuthResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAuthResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandAuthResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  client_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete response_;
}

void CommandAuthResponse::ArenaDtor(void* object) {
  CommandAuthResponse* _this = reinterpret_cast< CommandAuthResponse* >(object);
  (void)_this;
}
void CommandAuthResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandAuthResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandAuthResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAuthResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      client_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(response_ != nullptr);
      response_->Clear();
    }
  }
  protocol_version_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAuthResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_client_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.AuthData response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol_version = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_protocol_version(&has_bits);
          protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandAuthResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAuthResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_version(), target);
  }

  // optional .pulsar.proto.AuthData response = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::response(this), target, stream);
  }

  // optional int32 protocol_version = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_protocol_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAuthResponse)
  return target;
}

size_t CommandAuthResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAuthResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string client_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_version());
    }

    // optional .pulsar.proto.AuthData response = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *response_);
    }

    // optional int32 protocol_version = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_protocol_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandAuthResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandAuthResponse*>(
      &from));
}

void CommandAuthResponse::MergeFrom(const CommandAuthResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAuthResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_client_version(from._internal_client_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_response()->::pulsar::proto::AuthData::MergeFrom(from._internal_response());
    }
    if (cached_has_bits & 0x00000004u) {
      protocol_version_ = from.protocol_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAuthResponse::CopyFrom(const CommandAuthResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAuthResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandAuthResponse::IsInitialized() const {
  return true;
}

void CommandAuthResponse::InternalSwap(CommandAuthResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &client_version_, GetArenaForAllocation(),
      &other->client_version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAuthResponse, protocol_version_)
      + sizeof(CommandAuthResponse::protocol_version_)
      - PROTOBUF_FIELD_OFFSET(CommandAuthResponse, response_)>(
          reinterpret_cast<char*>(&response_),
          reinterpret_cast<char*>(&other->response_));
}

std::string CommandAuthResponse::GetTypeName() const {
  return "pulsar.proto.CommandAuthResponse";
}


// ===================================================================

class CommandAuthChallenge::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAuthChallenge>()._has_bits_);
  static void set_has_server_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::AuthData& challenge(const CommandAuthChallenge* msg);
  static void set_has_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::pulsar::proto::AuthData&
CommandAuthChallenge::_Internal::challenge(const CommandAuthChallenge* msg) {
  return *msg->challenge_;
}
CommandAuthChallenge::CommandAuthChallenge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAuthChallenge)
}
CommandAuthChallenge::CommandAuthChallenge(const CommandAuthChallenge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  server_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_server_version()) {
    server_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_server_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_challenge()) {
    challenge_ = new ::pulsar::proto::AuthData(*from.challenge_);
  } else {
    challenge_ = nullptr;
  }
  protocol_version_ = from.protocol_version_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAuthChallenge)
}

inline void CommandAuthChallenge::SharedCtor() {
server_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&challenge_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&protocol_version_) -
    reinterpret_cast<char*>(&challenge_)) + sizeof(protocol_version_));
}

CommandAuthChallenge::~CommandAuthChallenge() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAuthChallenge)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandAuthChallenge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  server_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete challenge_;
}

void CommandAuthChallenge::ArenaDtor(void* object) {
  CommandAuthChallenge* _this = reinterpret_cast< CommandAuthChallenge* >(object);
  (void)_this;
}
void CommandAuthChallenge::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandAuthChallenge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandAuthChallenge::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAuthChallenge)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      server_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(challenge_ != nullptr);
      challenge_->Clear();
    }
  }
  protocol_version_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAuthChallenge::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string server_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_server_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.AuthData challenge = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_challenge(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 protocol_version = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_protocol_version(&has_bits);
          protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandAuthChallenge::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAuthChallenge)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string server_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_server_version(), target);
  }

  // optional .pulsar.proto.AuthData challenge = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::challenge(this), target, stream);
  }

  // optional int32 protocol_version = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_protocol_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAuthChallenge)
  return target;
}

size_t CommandAuthChallenge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAuthChallenge)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string server_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_server_version());
    }

    // optional .pulsar.proto.AuthData challenge = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *challenge_);
    }

    // optional int32 protocol_version = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_protocol_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandAuthChallenge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandAuthChallenge*>(
      &from));
}

void CommandAuthChallenge::MergeFrom(const CommandAuthChallenge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAuthChallenge)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_server_version(from._internal_server_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_challenge()->::pulsar::proto::AuthData::MergeFrom(from._internal_challenge());
    }
    if (cached_has_bits & 0x00000004u) {
      protocol_version_ = from.protocol_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAuthChallenge::CopyFrom(const CommandAuthChallenge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAuthChallenge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandAuthChallenge::IsInitialized() const {
  return true;
}

void CommandAuthChallenge::InternalSwap(CommandAuthChallenge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &server_version_, GetArenaForAllocation(),
      &other->server_version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, protocol_version_)
      + sizeof(CommandAuthChallenge::protocol_version_)
      - PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, challenge_)>(
          reinterpret_cast<char*>(&challenge_),
          reinterpret_cast<char*>(&other->challenge_));
}

std::string CommandAuthChallenge::GetTypeName() const {
  return "pulsar.proto.CommandAuthChallenge";
}


// ===================================================================

class AuthData::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthData>()._has_bits_);
  static void set_has_auth_method_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AuthData::AuthData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.AuthData)
}
AuthData::AuthData(const AuthData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  auth_method_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_auth_method_name()) {
    auth_method_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auth_method_name(), 
      GetArenaForAllocation());
  }
  auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_auth_data()) {
    auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auth_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.AuthData)
}

inline void AuthData::SharedCtor() {
auth_method_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AuthData::~AuthData() {
  // @@protoc_insertion_point(destructor:pulsar.proto.AuthData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AuthData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  auth_method_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  auth_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AuthData::ArenaDtor(void* object) {
  AuthData* _this = reinterpret_cast< AuthData* >(object);
  (void)_this;
}
void AuthData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AuthData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AuthData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.AuthData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      auth_method_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      auth_data_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AuthData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string auth_method_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_auth_method_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes auth_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_auth_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AuthData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.AuthData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string auth_method_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_auth_method_name(), target);
  }

  // optional bytes auth_data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_auth_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.AuthData)
  return target;
}

size_t AuthData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.AuthData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string auth_method_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_auth_method_name());
    }

    // optional bytes auth_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_auth_data());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AuthData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AuthData*>(
      &from));
}

void AuthData::MergeFrom(const AuthData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.AuthData)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_auth_method_name(from._internal_auth_method_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_auth_data(from._internal_auth_data());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthData::CopyFrom(const AuthData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.AuthData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthData::IsInitialized() const {
  return true;
}

void AuthData::InternalSwap(AuthData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &auth_method_name_, GetArenaForAllocation(),
      &other->auth_method_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &auth_data_, GetArenaForAllocation(),
      &other->auth_data_, other->GetArenaForAllocation()
  );
}

std::string AuthData::GetTypeName() const {
  return "pulsar.proto.AuthData";
}


// ===================================================================

class KeySharedMeta::_Internal {
 public:
  using HasBits = decltype(std::declval<KeySharedMeta>()._has_bits_);
  static void set_has_keysharedmode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allowoutoforderdelivery(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

KeySharedMeta::KeySharedMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  hashranges_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.KeySharedMeta)
}
KeySharedMeta::KeySharedMeta(const KeySharedMeta& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      hashranges_(from.hashranges_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&keysharedmode_, &from.keysharedmode_,
    static_cast<size_t>(reinterpret_cast<char*>(&allowoutoforderdelivery_) -
    reinterpret_cast<char*>(&keysharedmode_)) + sizeof(allowoutoforderdelivery_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.KeySharedMeta)
}

inline void KeySharedMeta::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&keysharedmode_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allowoutoforderdelivery_) -
    reinterpret_cast<char*>(&keysharedmode_)) + sizeof(allowoutoforderdelivery_));
}

KeySharedMeta::~KeySharedMeta() {
  // @@protoc_insertion_point(destructor:pulsar.proto.KeySharedMeta)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void KeySharedMeta::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KeySharedMeta::ArenaDtor(void* object) {
  KeySharedMeta* _this = reinterpret_cast< KeySharedMeta* >(object);
  (void)_this;
}
void KeySharedMeta::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeySharedMeta::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeySharedMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.KeySharedMeta)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hashranges_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&keysharedmode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&allowoutoforderdelivery_) -
        reinterpret_cast<char*>(&keysharedmode_)) + sizeof(allowoutoforderdelivery_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeySharedMeta::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .pulsar.proto.KeySharedMode keySharedMode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::KeySharedMode_IsValid(val))) {
            _internal_set_keysharedmode(static_cast<::pulsar::proto::KeySharedMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.IntRange hashRanges = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hashranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool allowOutOfOrderDelivery = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_allowoutoforderdelivery(&has_bits);
          allowoutoforderdelivery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KeySharedMeta::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.KeySharedMeta)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pulsar.proto.KeySharedMode keySharedMode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_keysharedmode(), target);
  }

  // repeated .pulsar.proto.IntRange hashRanges = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_hashranges_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_hashranges(i), target, stream);
  }

  // optional bool allowOutOfOrderDelivery = 4 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_allowoutoforderdelivery(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.KeySharedMeta)
  return target;
}

size_t KeySharedMeta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.KeySharedMeta)
  size_t total_size = 0;

  // required .pulsar.proto.KeySharedMode keySharedMode = 1;
  if (_internal_has_keysharedmode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_keysharedmode());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.IntRange hashRanges = 3;
  total_size += 1UL * this->_internal_hashranges_size();
  for (const auto& msg : this->hashranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool allowOutOfOrderDelivery = 4 [default = false];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeySharedMeta::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const KeySharedMeta*>(
      &from));
}

void KeySharedMeta::MergeFrom(const KeySharedMeta& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.KeySharedMeta)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  hashranges_.MergeFrom(from.hashranges_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      keysharedmode_ = from.keysharedmode_;
    }
    if (cached_has_bits & 0x00000002u) {
      allowoutoforderdelivery_ = from.allowoutoforderdelivery_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeySharedMeta::CopyFrom(const KeySharedMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.KeySharedMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeySharedMeta::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(hashranges_)) return false;
  return true;
}

void KeySharedMeta::InternalSwap(KeySharedMeta* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hashranges_.InternalSwap(&other->hashranges_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeySharedMeta, allowoutoforderdelivery_)
      + sizeof(KeySharedMeta::allowoutoforderdelivery_)
      - PROTOBUF_FIELD_OFFSET(KeySharedMeta, keysharedmode_)>(
          reinterpret_cast<char*>(&keysharedmode_),
          reinterpret_cast<char*>(&other->keysharedmode_));
}

std::string KeySharedMeta::GetTypeName() const {
  return "pulsar.proto.KeySharedMeta";
}


// ===================================================================

class CommandSubscribe::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSubscribe>()._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_subscription(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_subtype(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_consumer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_priority_level(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_durable(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::pulsar::proto::MessageIdData& start_message_id(const CommandSubscribe* msg);
  static void set_has_start_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_read_compacted(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandSubscribe* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_initialposition(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_replicate_subscription_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_force_topic_creation(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_start_message_rollback_duration_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::pulsar::proto::KeySharedMeta& keysharedmeta(const CommandSubscribe* msg);
  static void set_has_keysharedmeta(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_consumer_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000001c3) ^ 0x000001c3) != 0;
  }
};

const ::pulsar::proto::MessageIdData&
CommandSubscribe::_Internal::start_message_id(const CommandSubscribe* msg) {
  return *msg->start_message_id_;
}
const ::pulsar::proto::Schema&
CommandSubscribe::_Internal::schema(const CommandSubscribe* msg) {
  return *msg->schema_;
}
const ::pulsar::proto::KeySharedMeta&
CommandSubscribe::_Internal::keysharedmeta(const CommandSubscribe* msg) {
  return *msg->keysharedmeta_;
}
CommandSubscribe::CommandSubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  metadata_(arena),
  subscription_properties_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSubscribe)
}
CommandSubscribe::CommandSubscribe(const CommandSubscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      metadata_(from.metadata_),
      subscription_properties_(from.subscription_properties_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic()) {
    topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topic(), 
      GetArenaForAllocation());
  }
  subscription_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_subscription()) {
    subscription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_subscription(), 
      GetArenaForAllocation());
  }
  consumer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_consumer_name()) {
    consumer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_consumer_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_start_message_id()) {
    start_message_id_ = new ::pulsar::proto::MessageIdData(*from.start_message_id_);
  } else {
    start_message_id_ = nullptr;
  }
  if (from._internal_has_schema()) {
    schema_ = new ::pulsar::proto::Schema(*from.schema_);
  } else {
    schema_ = nullptr;
  }
  if (from._internal_has_keysharedmeta()) {
    keysharedmeta_ = new ::pulsar::proto::KeySharedMeta(*from.keysharedmeta_);
  } else {
    keysharedmeta_ = nullptr;
  }
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&force_topic_creation_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(force_topic_creation_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSubscribe)
}

inline void CommandSubscribe::SharedCtor() {
topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
subscription_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
consumer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_message_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&consumer_epoch_) -
    reinterpret_cast<char*>(&start_message_id_)) + sizeof(consumer_epoch_));
durable_ = true;
force_topic_creation_ = true;
}

CommandSubscribe::~CommandSubscribe() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSubscribe)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandSubscribe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topic_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  subscription_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  consumer_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete start_message_id_;
  if (this != internal_default_instance()) delete schema_;
  if (this != internal_default_instance()) delete keysharedmeta_;
}

void CommandSubscribe::ArenaDtor(void* object) {
  CommandSubscribe* _this = reinterpret_cast< CommandSubscribe* >(object);
  (void)_this;
}
void CommandSubscribe::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandSubscribe::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandSubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSubscribe)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  metadata_.Clear();
  subscription_properties_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      subscription_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      consumer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(start_message_id_ != nullptr);
      start_message_id_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(schema_ != nullptr);
      schema_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(keysharedmeta_ != nullptr);
      keysharedmeta_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&request_id_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&subtype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&consumer_epoch_) -
        reinterpret_cast<char*>(&subtype_)) + sizeof(consumer_epoch_));
    durable_ = true;
  }
  force_topic_creation_ = true;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSubscribe::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string topic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string subscription = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_subscription();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::CommandSubscribe_SubType_IsValid(val))) {
            _internal_set_subtype(static_cast<::pulsar::proto::CommandSubscribe_SubType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required uint64 consumer_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string consumer_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_consumer_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 priority_level = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_priority_level(&has_bits);
          priority_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool durable = 8 [default = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_durable(&has_bits);
          durable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.MessageIdData start_message_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_message_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.KeyValue metadata = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool read_compacted = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_read_compacted(&has_bits);
          read_compacted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.Schema schema = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::CommandSubscribe_InitialPosition_IsValid(val))) {
            _internal_set_initialposition(static_cast<::pulsar::proto::CommandSubscribe_InitialPosition>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool replicate_subscription_state = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_replicate_subscription_state(&has_bits);
          replicate_subscription_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool force_topic_creation = 15 [default = true];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_force_topic_creation(&has_bits);
          force_topic_creation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_start_message_rollback_duration_sec(&has_bits);
          start_message_rollback_duration_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_keysharedmeta(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.KeyValue subscription_properties = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_subscription_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint64 consumer_epoch = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_consumer_epoch(&has_bits);
          consumer_epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandSubscribe::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSubscribe)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic(), target);
  }

  // required string subscription = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_subscription(), target);
  }

  // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_subtype(), target);
  }

  // required uint64 consumer_id = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_request_id(), target);
  }

  // optional string consumer_name = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_consumer_name(), target);
  }

  // optional int32 priority_level = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_priority_level(), target);
  }

  // optional bool durable = 8 [default = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_durable(), target);
  }

  // optional .pulsar.proto.MessageIdData start_message_id = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::start_message_id(this), target, stream);
  }

  // repeated .pulsar.proto.KeyValue metadata = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_metadata_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_metadata(i), target, stream);
  }

  // optional bool read_compacted = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_read_compacted(), target);
  }

  // optional .pulsar.proto.Schema schema = 12;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::schema(this), target, stream);
  }

  // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      13, this->_internal_initialposition(), target);
  }

  // optional bool replicate_subscription_state = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_replicate_subscription_state(), target);
  }

  // optional bool force_topic_creation = 15 [default = true];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_force_topic_creation(), target);
  }

  // optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(16, this->_internal_start_message_rollback_duration_sec(), target);
  }

  // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::keysharedmeta(this), target, stream);
  }

  // repeated .pulsar.proto.KeyValue subscription_properties = 18;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_subscription_properties_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, this->_internal_subscription_properties(i), target, stream);
  }

  // optional uint64 consumer_epoch = 19;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(19, this->_internal_consumer_epoch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSubscribe)
  return target;
}

size_t CommandSubscribe::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandSubscribe)
  size_t total_size = 0;

  if (_internal_has_topic()) {
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  if (_internal_has_subscription()) {
    // required string subscription = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_subscription());
  }

  if (_internal_has_consumer_id()) {
    // required uint64 consumer_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  if (_internal_has_subtype()) {
    // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_subtype());
  }

  return total_size;
}
size_t CommandSubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSubscribe)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000001c3) ^ 0x000001c3) == 0) {  // All required fields are present.
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());

    // required string subscription = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_subscription());

    // required uint64 consumer_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());

    // required uint64 request_id = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

    // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_subtype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue metadata = 10;
  total_size += 1UL * this->_internal_metadata_size();
  for (const auto& msg : this->metadata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulsar.proto.KeyValue subscription_properties = 18;
  total_size += 2UL * this->_internal_subscription_properties_size();
  for (const auto& msg : this->subscription_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003cu) {
    // optional string consumer_name = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_consumer_name());
    }

    // optional .pulsar.proto.MessageIdData start_message_id = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_message_id_);
    }

    // optional .pulsar.proto.Schema schema = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *schema_);
    }

    // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *keysharedmeta_);
    }

  }
  if (cached_has_bits & 0x0000fe00u) {
    // optional int32 priority_level = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_priority_level());
    }

    // optional bool read_compacted = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool replicate_subscription_state = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_initialposition());
    }

    // optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_start_message_rollback_duration_sec());
    }

    // optional uint64 consumer_epoch = 19;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_consumer_epoch());
    }

    // optional bool durable = 8 [default = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  // optional bool force_topic_creation = 15 [default = true];
  if (cached_has_bits & 0x00010000u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandSubscribe::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandSubscribe*>(
      &from));
}

void CommandSubscribe::MergeFrom(const CommandSubscribe& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSubscribe)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  metadata_.MergeFrom(from.metadata_);
  subscription_properties_.MergeFrom(from.subscription_properties_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_subscription(from._internal_subscription());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_consumer_name(from._internal_consumer_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_start_message_id()->::pulsar::proto::MessageIdData::MergeFrom(from._internal_start_message_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(from._internal_schema());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_keysharedmeta()->::pulsar::proto::KeySharedMeta::MergeFrom(from._internal_keysharedmeta());
    }
    if (cached_has_bits & 0x00000040u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      subtype_ = from.subtype_;
    }
    if (cached_has_bits & 0x00000200u) {
      priority_level_ = from.priority_level_;
    }
    if (cached_has_bits & 0x00000400u) {
      read_compacted_ = from.read_compacted_;
    }
    if (cached_has_bits & 0x00000800u) {
      replicate_subscription_state_ = from.replicate_subscription_state_;
    }
    if (cached_has_bits & 0x00001000u) {
      initialposition_ = from.initialposition_;
    }
    if (cached_has_bits & 0x00002000u) {
      start_message_rollback_duration_sec_ = from.start_message_rollback_duration_sec_;
    }
    if (cached_has_bits & 0x00004000u) {
      consumer_epoch_ = from.consumer_epoch_;
    }
    if (cached_has_bits & 0x00008000u) {
      durable_ = from.durable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _internal_set_force_topic_creation(from._internal_force_topic_creation());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSubscribe::CopyFrom(const CommandSubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSubscribe::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(metadata_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(subscription_properties_)) return false;
  if (_internal_has_start_message_id()) {
    if (!start_message_id_->IsInitialized()) return false;
  }
  if (_internal_has_schema()) {
    if (!schema_->IsInitialized()) return false;
  }
  if (_internal_has_keysharedmeta()) {
    if (!keysharedmeta_->IsInitialized()) return false;
  }
  return true;
}

void CommandSubscribe::InternalSwap(CommandSubscribe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  metadata_.InternalSwap(&other->metadata_);
  subscription_properties_.InternalSwap(&other->subscription_properties_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topic_, GetArenaForAllocation(),
      &other->topic_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &subscription_, GetArenaForAllocation(),
      &other->subscription_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &consumer_name_, GetArenaForAllocation(),
      &other->consumer_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSubscribe, consumer_epoch_)
      + sizeof(CommandSubscribe::consumer_epoch_)
      - PROTOBUF_FIELD_OFFSET(CommandSubscribe, start_message_id_)>(
          reinterpret_cast<char*>(&start_message_id_),
          reinterpret_cast<char*>(&other->start_message_id_));
  swap(durable_, other->durable_);
  swap(force_topic_creation_, other->force_topic_creation_);
}

std::string CommandSubscribe::GetTypeName() const {
  return "pulsar.proto.CommandSubscribe";
}


// ===================================================================

class CommandPartitionedTopicMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandPartitionedTopicMetadata>()._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_original_principal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_original_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_auth_method(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000011) ^ 0x00000011) != 0;
  }
};

CommandPartitionedTopicMetadata::CommandPartitionedTopicMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandPartitionedTopicMetadata)
}
CommandPartitionedTopicMetadata::CommandPartitionedTopicMetadata(const CommandPartitionedTopicMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic()) {
    topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topic(), 
      GetArenaForAllocation());
  }
  original_principal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_original_principal()) {
    original_principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_principal(), 
      GetArenaForAllocation());
  }
  original_auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_original_auth_data()) {
    original_auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_auth_data(), 
      GetArenaForAllocation());
  }
  original_auth_method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_original_auth_method()) {
    original_auth_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_auth_method(), 
      GetArenaForAllocation());
  }
  request_id_ = from.request_id_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandPartitionedTopicMetadata)
}

inline void CommandPartitionedTopicMetadata::SharedCtor() {
topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
original_principal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
original_auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
original_auth_method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
request_id_ = uint64_t{0u};
}

CommandPartitionedTopicMetadata::~CommandPartitionedTopicMetadata() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandPartitionedTopicMetadata)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandPartitionedTopicMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topic_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_principal_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_auth_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_auth_method_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandPartitionedTopicMetadata::ArenaDtor(void* object) {
  CommandPartitionedTopicMetadata* _this = reinterpret_cast< CommandPartitionedTopicMetadata* >(object);
  (void)_this;
}
void CommandPartitionedTopicMetadata::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandPartitionedTopicMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandPartitionedTopicMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandPartitionedTopicMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      original_principal_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      original_auth_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      original_auth_method_.ClearNonDefaultToEmpty();
    }
  }
  request_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandPartitionedTopicMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string topic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string original_principal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_original_principal();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string original_auth_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_original_auth_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string original_auth_method = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_original_auth_method();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandPartitionedTopicMetadata::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandPartitionedTopicMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_request_id(), target);
  }

  // optional string original_principal = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_original_principal(), target);
  }

  // optional string original_auth_data = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_original_auth_data(), target);
  }

  // optional string original_auth_method = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_original_auth_method(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandPartitionedTopicMetadata)
  return target;
}

size_t CommandPartitionedTopicMetadata::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandPartitionedTopicMetadata)
  size_t total_size = 0;

  if (_internal_has_topic()) {
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandPartitionedTopicMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandPartitionedTopicMetadata)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000011) ^ 0x00000011) == 0) {  // All required fields are present.
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());

    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional string original_principal = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_principal());
    }

    // optional string original_auth_data = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_auth_data());
    }

    // optional string original_auth_method = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_auth_method());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandPartitionedTopicMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandPartitionedTopicMetadata*>(
      &from));
}

void CommandPartitionedTopicMetadata::MergeFrom(const CommandPartitionedTopicMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandPartitionedTopicMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_original_principal(from._internal_original_principal());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_original_auth_data(from._internal_original_auth_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_original_auth_method(from._internal_original_auth_method());
    }
    if (cached_has_bits & 0x00000010u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandPartitionedTopicMetadata::CopyFrom(const CommandPartitionedTopicMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandPartitionedTopicMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandPartitionedTopicMetadata::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandPartitionedTopicMetadata::InternalSwap(CommandPartitionedTopicMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topic_, GetArenaForAllocation(),
      &other->topic_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_principal_, GetArenaForAllocation(),
      &other->original_principal_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_auth_data_, GetArenaForAllocation(),
      &other->original_auth_data_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_auth_method_, GetArenaForAllocation(),
      &other->original_auth_method_, other->GetArenaForAllocation()
  );
  swap(request_id_, other->request_id_);
}

std::string CommandPartitionedTopicMetadata::GetTypeName() const {
  return "pulsar.proto.CommandPartitionedTopicMetadata";
}


// ===================================================================

class CommandPartitionedTopicMetadataResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandPartitionedTopicMetadataResponse>()._has_bits_);
  static void set_has_partitions(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandPartitionedTopicMetadataResponse::CommandPartitionedTopicMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandPartitionedTopicMetadataResponse)
}
CommandPartitionedTopicMetadataResponse::CommandPartitionedTopicMetadataResponse(const CommandPartitionedTopicMetadataResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandPartitionedTopicMetadataResponse)
}

inline void CommandPartitionedTopicMetadataResponse::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
}

CommandPartitionedTopicMetadataResponse::~CommandPartitionedTopicMetadataResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandPartitionedTopicMetadataResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandPartitionedTopicMetadataResponse::ArenaDtor(void* object) {
  CommandPartitionedTopicMetadataResponse* _this = reinterpret_cast< CommandPartitionedTopicMetadataResponse* >(object);
  (void)_this;
}
void CommandPartitionedTopicMetadataResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandPartitionedTopicMetadataResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandPartitionedTopicMetadataResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandPartitionedTopicMetadataResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 partitions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_partitions(&has_bits);
          partitions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType_IsValid(val))) {
            _internal_set_response(static_cast<::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandPartitionedTopicMetadataResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 partitions = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_partitions(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_response(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  return target;
}

size_t CommandPartitionedTopicMetadataResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  size_t total_size = 0;

  // required uint64 request_id = 2;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint32 partitions = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_partitions());
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_response());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandPartitionedTopicMetadataResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandPartitionedTopicMetadataResponse*>(
      &from));
}

void CommandPartitionedTopicMetadataResponse::MergeFrom(const CommandPartitionedTopicMetadataResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      partitions_ = from.partitions_;
    }
    if (cached_has_bits & 0x00000008u) {
      response_ = from.response_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandPartitionedTopicMetadataResponse::CopyFrom(const CommandPartitionedTopicMetadataResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandPartitionedTopicMetadataResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandPartitionedTopicMetadataResponse::InternalSwap(CommandPartitionedTopicMetadataResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, error_)
      + sizeof(CommandPartitionedTopicMetadataResponse::error_)
      - PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandPartitionedTopicMetadataResponse::GetTypeName() const {
  return "pulsar.proto.CommandPartitionedTopicMetadataResponse";
}


// ===================================================================

class CommandLookupTopic::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandLookupTopic>()._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_authoritative(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_original_principal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_original_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_auth_method(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_advertised_listener_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000021) ^ 0x00000021) != 0;
  }
};

CommandLookupTopic::CommandLookupTopic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandLookupTopic)
}
CommandLookupTopic::CommandLookupTopic(const CommandLookupTopic& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic()) {
    topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topic(), 
      GetArenaForAllocation());
  }
  original_principal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_original_principal()) {
    original_principal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_principal(), 
      GetArenaForAllocation());
  }
  original_auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_original_auth_data()) {
    original_auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_auth_data(), 
      GetArenaForAllocation());
  }
  original_auth_method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_original_auth_method()) {
    original_auth_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_original_auth_method(), 
      GetArenaForAllocation());
  }
  advertised_listener_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_advertised_listener_name()) {
    advertised_listener_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_advertised_listener_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&authoritative_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(authoritative_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandLookupTopic)
}

inline void CommandLookupTopic::SharedCtor() {
topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
original_principal_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
original_auth_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
original_auth_method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
advertised_listener_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&authoritative_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(authoritative_));
}

CommandLookupTopic::~CommandLookupTopic() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandLookupTopic)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandLookupTopic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topic_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_principal_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_auth_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  original_auth_method_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  advertised_listener_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandLookupTopic::ArenaDtor(void* object) {
  CommandLookupTopic* _this = reinterpret_cast< CommandLookupTopic* >(object);
  (void)_this;
}
void CommandLookupTopic::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandLookupTopic::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandLookupTopic::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandLookupTopic)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      original_principal_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      original_auth_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      original_auth_method_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      advertised_listener_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&authoritative_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(authoritative_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandLookupTopic::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string topic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool authoritative = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_authoritative(&has_bits);
          authoritative_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string original_principal = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_original_principal();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string original_auth_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_original_auth_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string original_auth_method = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_original_auth_method();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string advertised_listener_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_advertised_listener_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandLookupTopic::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandLookupTopic)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_request_id(), target);
  }

  // optional bool authoritative = 3 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_authoritative(), target);
  }

  // optional string original_principal = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_original_principal(), target);
  }

  // optional string original_auth_data = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_original_auth_data(), target);
  }

  // optional string original_auth_method = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_original_auth_method(), target);
  }

  // optional string advertised_listener_name = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_advertised_listener_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandLookupTopic)
  return target;
}

size_t CommandLookupTopic::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandLookupTopic)
  size_t total_size = 0;

  if (_internal_has_topic()) {
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandLookupTopic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandLookupTopic)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000021) ^ 0x00000021) == 0) {  // All required fields are present.
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());

    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional string original_principal = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_principal());
    }

    // optional string original_auth_data = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_auth_data());
    }

    // optional string original_auth_method = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_auth_method());
    }

    // optional string advertised_listener_name = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_advertised_listener_name());
    }

  }
  // optional bool authoritative = 3 [default = false];
  if (cached_has_bits & 0x00000040u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandLookupTopic::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandLookupTopic*>(
      &from));
}

void CommandLookupTopic::MergeFrom(const CommandLookupTopic& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandLookupTopic)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_original_principal(from._internal_original_principal());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_original_auth_data(from._internal_original_auth_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_original_auth_method(from._internal_original_auth_method());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_advertised_listener_name(from._internal_advertised_listener_name());
    }
    if (cached_has_bits & 0x00000020u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      authoritative_ = from.authoritative_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandLookupTopic::CopyFrom(const CommandLookupTopic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandLookupTopic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandLookupTopic::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandLookupTopic::InternalSwap(CommandLookupTopic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topic_, GetArenaForAllocation(),
      &other->topic_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_principal_, GetArenaForAllocation(),
      &other->original_principal_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_auth_data_, GetArenaForAllocation(),
      &other->original_auth_data_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &original_auth_method_, GetArenaForAllocation(),
      &other->original_auth_method_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &advertised_listener_name_, GetArenaForAllocation(),
      &other->advertised_listener_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandLookupTopic, authoritative_)
      + sizeof(CommandLookupTopic::authoritative_)
      - PROTOBUF_FIELD_OFFSET(CommandLookupTopic, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandLookupTopic::GetTypeName() const {
  return "pulsar.proto.CommandLookupTopic";
}


// ===================================================================

class CommandLookupTopicResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandLookupTopicResponse>()._has_bits_);
  static void set_has_brokerserviceurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_brokerserviceurltls(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_authoritative(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_proxy_through_service_url(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

CommandLookupTopicResponse::CommandLookupTopicResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandLookupTopicResponse)
}
CommandLookupTopicResponse::CommandLookupTopicResponse(const CommandLookupTopicResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  brokerserviceurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_brokerserviceurl()) {
    brokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_brokerserviceurl(), 
      GetArenaForAllocation());
  }
  brokerserviceurltls_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_brokerserviceurltls()) {
    brokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_brokerserviceurltls(), 
      GetArenaForAllocation());
  }
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&proxy_through_service_url_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(proxy_through_service_url_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandLookupTopicResponse)
}

inline void CommandLookupTopicResponse::SharedCtor() {
brokerserviceurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
brokerserviceurltls_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&proxy_through_service_url_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(proxy_through_service_url_));
}

CommandLookupTopicResponse::~CommandLookupTopicResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandLookupTopicResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandLookupTopicResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  brokerserviceurl_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  brokerserviceurltls_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandLookupTopicResponse::ArenaDtor(void* object) {
  CommandLookupTopicResponse* _this = reinterpret_cast< CommandLookupTopicResponse* >(object);
  (void)_this;
}
void CommandLookupTopicResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandLookupTopicResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandLookupTopicResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandLookupTopicResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      brokerserviceurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      brokerserviceurltls_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&proxy_through_service_url_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(proxy_through_service_url_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandLookupTopicResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string brokerServiceUrl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_brokerserviceurl();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string brokerServiceUrlTls = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_brokerserviceurltls();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::CommandLookupTopicResponse_LookupType_IsValid(val))) {
            _internal_set_response(static_cast<::pulsar::proto::CommandLookupTopicResponse_LookupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool authoritative = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_authoritative(&has_bits);
          authoritative_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool proxy_through_service_url = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_proxy_through_service_url(&has_bits);
          proxy_through_service_url_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandLookupTopicResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandLookupTopicResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string brokerServiceUrl = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_brokerserviceurl(), target);
  }

  // optional string brokerServiceUrlTls = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_brokerserviceurltls(), target);
  }

  // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_response(), target);
  }

  // required uint64 request_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_request_id(), target);
  }

  // optional bool authoritative = 5 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_authoritative(), target);
  }

  // optional .pulsar.proto.ServerError error = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_error(), target);
  }

  // optional string message = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_message(), target);
  }

  // optional bool proxy_through_service_url = 8 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_proxy_through_service_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandLookupTopicResponse)
  return target;
}

size_t CommandLookupTopicResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandLookupTopicResponse)
  size_t total_size = 0;

  // required uint64 request_id = 4;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string brokerServiceUrl = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brokerserviceurl());
    }

    // optional string brokerServiceUrlTls = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brokerserviceurltls());
    }

    // optional string message = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

  }
  if (cached_has_bits & 0x000000f0u) {
    // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_response());
    }

    // optional .pulsar.proto.ServerError error = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

    // optional bool authoritative = 5 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool proxy_through_service_url = 8 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandLookupTopicResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandLookupTopicResponse*>(
      &from));
}

void CommandLookupTopicResponse::MergeFrom(const CommandLookupTopicResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandLookupTopicResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_brokerserviceurl(from._internal_brokerserviceurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_brokerserviceurltls(from._internal_brokerserviceurltls());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000008u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      response_ = from.response_;
    }
    if (cached_has_bits & 0x00000020u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000040u) {
      authoritative_ = from.authoritative_;
    }
    if (cached_has_bits & 0x00000080u) {
      proxy_through_service_url_ = from.proxy_through_service_url_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandLookupTopicResponse::CopyFrom(const CommandLookupTopicResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandLookupTopicResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandLookupTopicResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandLookupTopicResponse::InternalSwap(CommandLookupTopicResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &brokerserviceurl_, GetArenaForAllocation(),
      &other->brokerserviceurl_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &brokerserviceurltls_, GetArenaForAllocation(),
      &other->brokerserviceurltls_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, proxy_through_service_url_)
      + sizeof(CommandLookupTopicResponse::proxy_through_service_url_)
      - PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandLookupTopicResponse::GetTypeName() const {
  return "pulsar.proto.CommandLookupTopicResponse";
}


// ===================================================================

class CommandProducer::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandProducer>()._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_producer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_encrypted(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandProducer* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_user_provided_producer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_producer_access_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_topic_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_txn_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_initial_subscription_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000031) ^ 0x00000031) != 0;
  }
};

const ::pulsar::proto::Schema&
CommandProducer::_Internal::schema(const CommandProducer* msg) {
  return *msg->schema_;
}
CommandProducer::CommandProducer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  metadata_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandProducer)
}
CommandProducer::CommandProducer(const CommandProducer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      metadata_(from.metadata_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic()) {
    topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topic(), 
      GetArenaForAllocation());
  }
  producer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_producer_name()) {
    producer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_producer_name(), 
      GetArenaForAllocation());
  }
  initial_subscription_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_initial_subscription_name()) {
    initial_subscription_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_initial_subscription_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_schema()) {
    schema_ = new ::pulsar::proto::Schema(*from.schema_);
  } else {
    schema_ = nullptr;
  }
  ::memcpy(&producer_id_, &from.producer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&user_provided_producer_name_) -
    reinterpret_cast<char*>(&producer_id_)) + sizeof(user_provided_producer_name_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandProducer)
}

inline void CommandProducer::SharedCtor() {
topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
producer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
initial_subscription_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&schema_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&topic_epoch_) -
    reinterpret_cast<char*>(&schema_)) + sizeof(topic_epoch_));
user_provided_producer_name_ = true;
}

CommandProducer::~CommandProducer() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandProducer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandProducer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topic_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  producer_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  initial_subscription_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete schema_;
}

void CommandProducer::ArenaDtor(void* object) {
  CommandProducer* _this = reinterpret_cast< CommandProducer* >(object);
  (void)_this;
}
void CommandProducer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandProducer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandProducer::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandProducer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  metadata_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      producer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      initial_subscription_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(schema_ != nullptr);
      schema_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&producer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&encrypted_) -
        reinterpret_cast<char*>(&producer_id_)) + sizeof(encrypted_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&txn_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&topic_epoch_) -
        reinterpret_cast<char*>(&txn_enabled_)) + sizeof(topic_epoch_));
    user_provided_producer_name_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandProducer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string topic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 producer_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_producer_id(&has_bits);
          producer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string producer_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_producer_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool encrypted = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_encrypted(&has_bits);
          encrypted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.KeyValue metadata = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.Schema schema = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 epoch = 8 [default = 0];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_epoch(&has_bits);
          epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool user_provided_producer_name = 9 [default = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_user_provided_producer_name(&has_bits);
          user_provided_producer_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ProducerAccessMode_IsValid(val))) {
            _internal_set_producer_access_mode(static_cast<::pulsar::proto::ProducerAccessMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 topic_epoch = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_topic_epoch(&has_bits);
          topic_epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool txn_enabled = 12 [default = false];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_txn_enabled(&has_bits);
          txn_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string initial_subscription_name = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          auto str = _internal_mutable_initial_subscription_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandProducer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandProducer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic(), target);
  }

  // required uint64 producer_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_producer_id(), target);
  }

  // required uint64 request_id = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_request_id(), target);
  }

  // optional string producer_name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_producer_name(), target);
  }

  // optional bool encrypted = 5 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_encrypted(), target);
  }

  // repeated .pulsar.proto.KeyValue metadata = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_metadata_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_metadata(i), target, stream);
  }

  // optional .pulsar.proto.Schema schema = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::schema(this), target, stream);
  }

  // optional uint64 epoch = 8 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_epoch(), target);
  }

  // optional bool user_provided_producer_name = 9 [default = true];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_user_provided_producer_name(), target);
  }

  // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_producer_access_mode(), target);
  }

  // optional uint64 topic_epoch = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(11, this->_internal_topic_epoch(), target);
  }

  // optional bool txn_enabled = 12 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_txn_enabled(), target);
  }

  // optional string initial_subscription_name = 13;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_initial_subscription_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandProducer)
  return target;
}

size_t CommandProducer::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandProducer)
  size_t total_size = 0;

  if (_internal_has_topic()) {
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  if (_internal_has_producer_id()) {
    // required uint64 producer_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandProducer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandProducer)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000031) ^ 0x00000031) == 0) {  // All required fields are present.
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());

    // required uint64 producer_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());

    // required uint64 request_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue metadata = 6;
  total_size += 1UL * this->_internal_metadata_size();
  for (const auto& msg : this->metadata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional string producer_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_producer_name());
    }

    // optional string initial_subscription_name = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_initial_subscription_name());
    }

    // optional .pulsar.proto.Schema schema = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *schema_);
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional uint64 epoch = 8 [default = 0];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_epoch());
    }

    // optional bool encrypted = 5 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool txn_enabled = 12 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_producer_access_mode());
    }

    // optional uint64 topic_epoch = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_topic_epoch());
    }

    // optional bool user_provided_producer_name = 9 [default = true];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandProducer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandProducer*>(
      &from));
}

void CommandProducer::MergeFrom(const CommandProducer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandProducer)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  metadata_.MergeFrom(from.metadata_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_producer_name(from._internal_producer_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_initial_subscription_name(from._internal_initial_subscription_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(from._internal_schema());
    }
    if (cached_has_bits & 0x00000010u) {
      producer_id_ = from.producer_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      epoch_ = from.epoch_;
    }
    if (cached_has_bits & 0x00000080u) {
      encrypted_ = from.encrypted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      txn_enabled_ = from.txn_enabled_;
    }
    if (cached_has_bits & 0x00000200u) {
      producer_access_mode_ = from.producer_access_mode_;
    }
    if (cached_has_bits & 0x00000400u) {
      topic_epoch_ = from.topic_epoch_;
    }
    if (cached_has_bits & 0x00000800u) {
      user_provided_producer_name_ = from.user_provided_producer_name_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandProducer::CopyFrom(const CommandProducer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandProducer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandProducer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(metadata_)) return false;
  if (_internal_has_schema()) {
    if (!schema_->IsInitialized()) return false;
  }
  return true;
}

void CommandProducer::InternalSwap(CommandProducer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  metadata_.InternalSwap(&other->metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topic_, GetArenaForAllocation(),
      &other->topic_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &producer_name_, GetArenaForAllocation(),
      &other->producer_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &initial_subscription_name_, GetArenaForAllocation(),
      &other->initial_subscription_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandProducer, topic_epoch_)
      + sizeof(CommandProducer::topic_epoch_)
      - PROTOBUF_FIELD_OFFSET(CommandProducer, schema_)>(
          reinterpret_cast<char*>(&schema_),
          reinterpret_cast<char*>(&other->schema_));
  swap(user_provided_producer_name_, other->user_provided_producer_name_);
}

std::string CommandProducer::GetTypeName() const {
  return "pulsar.proto.CommandProducer";
}


// ===================================================================

class CommandSend::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSend>()._has_bits_);
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_messages(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_highest_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_chunk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_marker(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::pulsar::proto::MessageIdData& message_id(const CommandSend* msg);
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::pulsar::proto::MessageIdData&
CommandSend::_Internal::message_id(const CommandSend* msg) {
  return *msg->message_id_;
}
CommandSend::CommandSend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSend)
}
CommandSend::CommandSend(const CommandSend& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_message_id()) {
    message_id_ = new ::pulsar::proto::MessageIdData(*from.message_id_);
  } else {
    message_id_ = nullptr;
  }
  ::memcpy(&producer_id_, &from.producer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_messages_) -
    reinterpret_cast<char*>(&producer_id_)) + sizeof(num_messages_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSend)
}

inline void CommandSend::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&message_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&marker_) -
    reinterpret_cast<char*>(&message_id_)) + sizeof(marker_));
num_messages_ = 1;
}

CommandSend::~CommandSend() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSend)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandSend::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete message_id_;
}

void CommandSend::ArenaDtor(void* object) {
  CommandSend* _this = reinterpret_cast< CommandSend* >(object);
  (void)_this;
}
void CommandSend::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandSend::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandSend::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSend)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(message_id_ != nullptr);
    message_id_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&producer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&marker_) -
        reinterpret_cast<char*>(&producer_id_)) + sizeof(marker_));
  }
  num_messages_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSend::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 producer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_producer_id(&has_bits);
          producer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 sequence_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_sequence_id(&has_bits);
          sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_messages = 3 [default = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_messages(&has_bits);
          num_messages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 5 [default = 0];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 highest_sequence_id = 6 [default = 0];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_highest_sequence_id(&has_bits);
          highest_sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_chunk = 7 [default = false];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_is_chunk(&has_bits);
          is_chunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool marker = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_marker(&has_bits);
          marker_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.MessageIdData message_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_message_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandSend::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSend)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 producer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_producer_id(), target);
  }

  // required uint64 sequence_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_sequence_id(), target);
  }

  // optional int32 num_messages = 3 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_messages(), target);
  }

  // optional uint64 txnid_least_bits = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 5 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_txnid_most_bits(), target);
  }

  // optional uint64 highest_sequence_id = 6 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_highest_sequence_id(), target);
  }

  // optional bool is_chunk = 7 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_is_chunk(), target);
  }

  // optional bool marker = 8 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_marker(), target);
  }

  // optional .pulsar.proto.MessageIdData message_id = 9;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::message_id(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSend)
  return target;
}

size_t CommandSend::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandSend)
  size_t total_size = 0;

  if (_internal_has_producer_id()) {
    // required uint64 producer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());
  }

  if (_internal_has_sequence_id()) {
    // required uint64 sequence_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sequence_id());
  }

  return total_size;
}
size_t CommandSend::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSend)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint64 producer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());

    // required uint64 sequence_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sequence_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.MessageIdData message_id = 9;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *message_id_);
  }

  if (cached_has_bits & 0x000000f8u) {
    // optional uint64 txnid_least_bits = 4 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 5 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 highest_sequence_id = 6 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_highest_sequence_id());
    }

    // optional bool is_chunk = 7 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool marker = 8 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional int32 num_messages = 3 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_num_messages());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandSend::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandSend*>(
      &from));
}

void CommandSend::MergeFrom(const CommandSend& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSend)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_message_id()->::pulsar::proto::MessageIdData::MergeFrom(from._internal_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      producer_id_ = from.producer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      sequence_id_ = from.sequence_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000020u) {
      highest_sequence_id_ = from.highest_sequence_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_chunk_ = from.is_chunk_;
    }
    if (cached_has_bits & 0x00000080u) {
      marker_ = from.marker_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_num_messages(from._internal_num_messages());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSend::CopyFrom(const CommandSend& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSend)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSend::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_message_id()) {
    if (!message_id_->IsInitialized()) return false;
  }
  return true;
}

void CommandSend::InternalSwap(CommandSend* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSend, marker_)
      + sizeof(CommandSend::marker_)
      - PROTOBUF_FIELD_OFFSET(CommandSend, message_id_)>(
          reinterpret_cast<char*>(&message_id_),
          reinterpret_cast<char*>(&other->message_id_));
  swap(num_messages_, other->num_messages_);
}

std::string CommandSend::GetTypeName() const {
  return "pulsar.proto.CommandSend";
}


// ===================================================================

class CommandSendReceipt::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSendReceipt>()._has_bits_);
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pulsar::proto::MessageIdData& message_id(const CommandSendReceipt* msg);
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_highest_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::pulsar::proto::MessageIdData&
CommandSendReceipt::_Internal::message_id(const CommandSendReceipt* msg) {
  return *msg->message_id_;
}
CommandSendReceipt::CommandSendReceipt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSendReceipt)
}
CommandSendReceipt::CommandSendReceipt(const CommandSendReceipt& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_message_id()) {
    message_id_ = new ::pulsar::proto::MessageIdData(*from.message_id_);
  } else {
    message_id_ = nullptr;
  }
  ::memcpy(&producer_id_, &from.producer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&highest_sequence_id_) -
    reinterpret_cast<char*>(&producer_id_)) + sizeof(highest_sequence_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSendReceipt)
}

inline void CommandSendReceipt::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&message_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&highest_sequence_id_) -
    reinterpret_cast<char*>(&message_id_)) + sizeof(highest_sequence_id_));
}

CommandSendReceipt::~CommandSendReceipt() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSendReceipt)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandSendReceipt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete message_id_;
}

void CommandSendReceipt::ArenaDtor(void* object) {
  CommandSendReceipt* _this = reinterpret_cast< CommandSendReceipt* >(object);
  (void)_this;
}
void CommandSendReceipt::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandSendReceipt::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandSendReceipt::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSendReceipt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(message_id_ != nullptr);
    message_id_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&producer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&highest_sequence_id_) -
        reinterpret_cast<char*>(&producer_id_)) + sizeof(highest_sequence_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSendReceipt::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 producer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_producer_id(&has_bits);
          producer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 sequence_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_sequence_id(&has_bits);
          sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.MessageIdData message_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_message_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 highest_sequence_id = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_highest_sequence_id(&has_bits);
          highest_sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandSendReceipt::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSendReceipt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 producer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_producer_id(), target);
  }

  // required uint64 sequence_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_sequence_id(), target);
  }

  // optional .pulsar.proto.MessageIdData message_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::message_id(this), target, stream);
  }

  // optional uint64 highest_sequence_id = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_highest_sequence_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSendReceipt)
  return target;
}

size_t CommandSendReceipt::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandSendReceipt)
  size_t total_size = 0;

  if (_internal_has_producer_id()) {
    // required uint64 producer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());
  }

  if (_internal_has_sequence_id()) {
    // required uint64 sequence_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sequence_id());
  }

  return total_size;
}
size_t CommandSendReceipt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSendReceipt)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint64 producer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());

    // required uint64 sequence_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sequence_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.MessageIdData message_id = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *message_id_);
  }

  // optional uint64 highest_sequence_id = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_highest_sequence_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandSendReceipt::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandSendReceipt*>(
      &from));
}

void CommandSendReceipt::MergeFrom(const CommandSendReceipt& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSendReceipt)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_message_id()->::pulsar::proto::MessageIdData::MergeFrom(from._internal_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      producer_id_ = from.producer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      sequence_id_ = from.sequence_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      highest_sequence_id_ = from.highest_sequence_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSendReceipt::CopyFrom(const CommandSendReceipt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSendReceipt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSendReceipt::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_message_id()) {
    if (!message_id_->IsInitialized()) return false;
  }
  return true;
}

void CommandSendReceipt::InternalSwap(CommandSendReceipt* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSendReceipt, highest_sequence_id_)
      + sizeof(CommandSendReceipt::highest_sequence_id_)
      - PROTOBUF_FIELD_OFFSET(CommandSendReceipt, message_id_)>(
          reinterpret_cast<char*>(&message_id_),
          reinterpret_cast<char*>(&other->message_id_));
}

std::string CommandSendReceipt::GetTypeName() const {
  return "pulsar.proto.CommandSendReceipt";
}


// ===================================================================

class CommandSendError::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSendError>()._has_bits_);
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

CommandSendError::CommandSendError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSendError)
}
CommandSendError::CommandSendError(const CommandSendError& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&producer_id_, &from.producer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&producer_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSendError)
}

inline void CommandSendError::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&producer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&producer_id_)) + sizeof(error_));
}

CommandSendError::~CommandSendError() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSendError)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandSendError::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandSendError::ArenaDtor(void* object) {
  CommandSendError* _this = reinterpret_cast< CommandSendError* >(object);
  (void)_this;
}
void CommandSendError::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandSendError::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandSendError::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSendError)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&producer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&producer_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSendError::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 producer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_producer_id(&has_bits);
          producer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 sequence_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_sequence_id(&has_bits);
          sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pulsar.proto.ServerError error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required string message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandSendError::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSendError)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 producer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_producer_id(), target);
  }

  // required uint64 sequence_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_sequence_id(), target);
  }

  // required .pulsar.proto.ServerError error = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error(), target);
  }

  // required string message = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSendError)
  return target;
}

size_t CommandSendError::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandSendError)
  size_t total_size = 0;

  if (_internal_has_message()) {
    // required string message = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (_internal_has_producer_id()) {
    // required uint64 producer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());
  }

  if (_internal_has_sequence_id()) {
    // required uint64 sequence_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sequence_id());
  }

  if (_internal_has_error()) {
    // required .pulsar.proto.ServerError error = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
  }

  return total_size;
}
size_t CommandSendError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSendError)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string message = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());

    // required uint64 producer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());

    // required uint64 sequence_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_sequence_id());

    // required .pulsar.proto.ServerError error = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandSendError::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandSendError*>(
      &from));
}

void CommandSendError::MergeFrom(const CommandSendError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSendError)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      producer_id_ = from.producer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      sequence_id_ = from.sequence_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSendError::CopyFrom(const CommandSendError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSendError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSendError::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandSendError::InternalSwap(CommandSendError* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSendError, error_)
      + sizeof(CommandSendError::error_)
      - PROTOBUF_FIELD_OFFSET(CommandSendError, producer_id_)>(
          reinterpret_cast<char*>(&producer_id_),
          reinterpret_cast<char*>(&other->producer_id_));
}

std::string CommandSendError::GetTypeName() const {
  return "pulsar.proto.CommandSendError";
}


// ===================================================================

class CommandMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandMessage>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pulsar::proto::MessageIdData& message_id(const CommandMessage* msg);
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_redelivery_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_consumer_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::pulsar::proto::MessageIdData&
CommandMessage::_Internal::message_id(const CommandMessage* msg) {
  return *msg->message_id_;
}
CommandMessage::CommandMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  ack_set_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandMessage)
}
CommandMessage::CommandMessage(const CommandMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      ack_set_(from.ack_set_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_message_id()) {
    message_id_ = new ::pulsar::proto::MessageIdData(*from.message_id_);
  } else {
    message_id_ = nullptr;
  }
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&redelivery_count_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(redelivery_count_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandMessage)
}

inline void CommandMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&message_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&redelivery_count_) -
    reinterpret_cast<char*>(&message_id_)) + sizeof(redelivery_count_));
}

CommandMessage::~CommandMessage() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete message_id_;
}

void CommandMessage::ArenaDtor(void* object) {
  CommandMessage* _this = reinterpret_cast< CommandMessage* >(object);
  (void)_this;
}
void CommandMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ack_set_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(message_id_ != nullptr);
    message_id_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&redelivery_count_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(redelivery_count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pulsar.proto.MessageIdData message_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_message_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 redelivery_count = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_redelivery_count(&has_bits);
          redelivery_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 ack_set = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ack_set(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_ack_set(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 consumer_epoch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_consumer_epoch(&has_bits);
          consumer_epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandMessage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // required .pulsar.proto.MessageIdData message_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::message_id(this), target, stream);
  }

  // optional uint32 redelivery_count = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_redelivery_count(), target);
  }

  // repeated int64 ack_set = 4;
  for (int i = 0, n = this->_internal_ack_set_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_ack_set(i), target);
  }

  // optional uint64 consumer_epoch = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_consumer_epoch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandMessage)
  return target;
}

size_t CommandMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandMessage)
  size_t total_size = 0;

  if (_internal_has_message_id()) {
    // required .pulsar.proto.MessageIdData message_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *message_id_);
  }

  if (_internal_has_consumer_id()) {
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }

  return total_size;
}
size_t CommandMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .pulsar.proto.MessageIdData message_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *message_id_);

    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 ack_set = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->ack_set_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_ack_set_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional uint64 consumer_epoch = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_consumer_epoch());
    }

    // optional uint32 redelivery_count = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_redelivery_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandMessage*>(
      &from));
}

void CommandMessage::MergeFrom(const CommandMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandMessage)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  ack_set_.MergeFrom(from.ack_set_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_message_id()->::pulsar::proto::MessageIdData::MergeFrom(from._internal_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      consumer_epoch_ = from.consumer_epoch_;
    }
    if (cached_has_bits & 0x00000008u) {
      redelivery_count_ = from.redelivery_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandMessage::CopyFrom(const CommandMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_message_id()) {
    if (!message_id_->IsInitialized()) return false;
  }
  return true;
}

void CommandMessage::InternalSwap(CommandMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ack_set_.InternalSwap(&other->ack_set_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandMessage, redelivery_count_)
      + sizeof(CommandMessage::redelivery_count_)
      - PROTOBUF_FIELD_OFFSET(CommandMessage, message_id_)>(
          reinterpret_cast<char*>(&message_id_),
          reinterpret_cast<char*>(&other->message_id_));
}

std::string CommandMessage::GetTypeName() const {
  return "pulsar.proto.CommandMessage";
}


// ===================================================================

class CommandAck::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAck>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ack_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_validation_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandAck::CommandAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  message_id_(arena),
  properties_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAck)
}
CommandAck::CommandAck(const CommandAck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      message_id_(from.message_id_),
      properties_(from.properties_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAck)
}

inline void CommandAck::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&consumer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
}

CommandAck::~CommandAck() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAck)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandAck::ArenaDtor(void* object) {
  CommandAck* _this = reinterpret_cast< CommandAck* >(object);
  (void)_this;
}
void CommandAck::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandAck::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  message_id_.Clear();
  properties_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&request_id_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAck::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pulsar.proto.CommandAck.AckType ack_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::CommandAck_AckType_IsValid(val))) {
            _internal_set_ack_type(static_cast<::pulsar::proto::CommandAck_AckType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.MessageIdData message_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_message_id(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::CommandAck_ValidationError_IsValid(val))) {
            _internal_set_validation_error(static_cast<::pulsar::proto::CommandAck_ValidationError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.KeyLongValue properties = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 6 [default = 0];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 7 [default = 0];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 request_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandAck::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAck)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // required .pulsar.proto.CommandAck.AckType ack_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_ack_type(), target);
  }

  // repeated .pulsar.proto.MessageIdData message_id = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_message_id_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_message_id(i), target, stream);
  }

  // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_validation_error(), target);
  }

  // repeated .pulsar.proto.KeyLongValue properties = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_properties_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_properties(i), target, stream);
  }

  // optional uint64 txnid_least_bits = 6 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 7 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_txnid_most_bits(), target);
  }

  // optional uint64 request_id = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAck)
  return target;
}

size_t CommandAck::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandAck)
  size_t total_size = 0;

  if (_internal_has_consumer_id()) {
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }

  if (_internal_has_ack_type()) {
    // required .pulsar.proto.CommandAck.AckType ack_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ack_type());
  }

  return total_size;
}
size_t CommandAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAck)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());

    // required .pulsar.proto.CommandAck.AckType ack_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ack_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.MessageIdData message_id = 3;
  total_size += 1UL * this->_internal_message_id_size();
  for (const auto& msg : this->message_id_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulsar.proto.KeyLongValue properties = 5;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003cu) {
    // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_validation_error());
    }

    // optional uint64 txnid_least_bits = 6 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 7 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 request_id = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_request_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandAck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandAck*>(
      &from));
}

void CommandAck::MergeFrom(const CommandAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAck)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  message_id_.MergeFrom(from.message_id_);
  properties_.MergeFrom(from.properties_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      ack_type_ = from.ack_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      validation_error_ = from.validation_error_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000020u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAck::CopyFrom(const CommandAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandAck::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(message_id_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(properties_)) return false;
  return true;
}

void CommandAck::InternalSwap(CommandAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  message_id_.InternalSwap(&other->message_id_);
  properties_.InternalSwap(&other->properties_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAck, request_id_)
      + sizeof(CommandAck::request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandAck, consumer_id_)>(
          reinterpret_cast<char*>(&consumer_id_),
          reinterpret_cast<char*>(&other->consumer_id_));
}

std::string CommandAck::GetTypeName() const {
  return "pulsar.proto.CommandAck";
}


// ===================================================================

class CommandAckResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAckResponse>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandAckResponse::CommandAckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAckResponse)
}
CommandAckResponse::CommandAckResponse(const CommandAckResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAckResponse)
}

inline void CommandAckResponse::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&consumer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(error_));
}

CommandAckResponse::~CommandAckResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAckResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandAckResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandAckResponse::ArenaDtor(void* object) {
  CommandAckResponse* _this = reinterpret_cast< CommandAckResponse* >(object);
  (void)_this;
}
void CommandAckResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandAckResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandAckResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAckResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAckResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 request_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandAckResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAckResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_message(), target);
  }

  // optional uint64 request_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAckResponse)
  return target;
}

size_t CommandAckResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAckResponse)
  size_t total_size = 0;

  // required uint64 consumer_id = 1;
  if (_internal_has_consumer_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (cached_has_bits & 0x0000003cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 request_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_request_id());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandAckResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandAckResponse*>(
      &from));
}

void CommandAckResponse::MergeFrom(const CommandAckResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAckResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAckResponse::CopyFrom(const CommandAckResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAckResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandAckResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandAckResponse::InternalSwap(CommandAckResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAckResponse, error_)
      + sizeof(CommandAckResponse::error_)
      - PROTOBUF_FIELD_OFFSET(CommandAckResponse, consumer_id_)>(
          reinterpret_cast<char*>(&consumer_id_),
          reinterpret_cast<char*>(&other->consumer_id_));
}

std::string CommandAckResponse::GetTypeName() const {
  return "pulsar.proto.CommandAckResponse";
}


// ===================================================================

class CommandActiveConsumerChange::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandActiveConsumerChange>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandActiveConsumerChange::CommandActiveConsumerChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandActiveConsumerChange)
}
CommandActiveConsumerChange::CommandActiveConsumerChange(const CommandActiveConsumerChange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_active_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(is_active_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandActiveConsumerChange)
}

inline void CommandActiveConsumerChange::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&consumer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_active_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(is_active_));
}

CommandActiveConsumerChange::~CommandActiveConsumerChange() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandActiveConsumerChange)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandActiveConsumerChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandActiveConsumerChange::ArenaDtor(void* object) {
  CommandActiveConsumerChange* _this = reinterpret_cast< CommandActiveConsumerChange* >(object);
  (void)_this;
}
void CommandActiveConsumerChange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandActiveConsumerChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandActiveConsumerChange::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandActiveConsumerChange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_active_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(is_active_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandActiveConsumerChange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_active = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_is_active(&has_bits);
          is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandActiveConsumerChange::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandActiveConsumerChange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // optional bool is_active = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_active(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandActiveConsumerChange)
  return target;
}

size_t CommandActiveConsumerChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandActiveConsumerChange)
  size_t total_size = 0;

  // required uint64 consumer_id = 1;
  if (_internal_has_consumer_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool is_active = 2 [default = false];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandActiveConsumerChange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandActiveConsumerChange*>(
      &from));
}

void CommandActiveConsumerChange::MergeFrom(const CommandActiveConsumerChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandActiveConsumerChange)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_active_ = from.is_active_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandActiveConsumerChange::CopyFrom(const CommandActiveConsumerChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandActiveConsumerChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandActiveConsumerChange::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandActiveConsumerChange::InternalSwap(CommandActiveConsumerChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, is_active_)
      + sizeof(CommandActiveConsumerChange::is_active_)
      - PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, consumer_id_)>(
          reinterpret_cast<char*>(&consumer_id_),
          reinterpret_cast<char*>(&other->consumer_id_));
}

std::string CommandActiveConsumerChange::GetTypeName() const {
  return "pulsar.proto.CommandActiveConsumerChange";
}


// ===================================================================

class CommandFlow::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandFlow>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_messagepermits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandFlow::CommandFlow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandFlow)
}
CommandFlow::CommandFlow(const CommandFlow& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&messagepermits_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(messagepermits_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandFlow)
}

inline void CommandFlow::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&consumer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&messagepermits_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(messagepermits_));
}

CommandFlow::~CommandFlow() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandFlow)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandFlow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandFlow::ArenaDtor(void* object) {
  CommandFlow* _this = reinterpret_cast< CommandFlow* >(object);
  (void)_this;
}
void CommandFlow::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandFlow::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandFlow::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandFlow)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&messagepermits_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(messagepermits_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandFlow::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 messagePermits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_messagepermits(&has_bits);
          messagepermits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandFlow::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandFlow)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // required uint32 messagePermits = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_messagepermits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandFlow)
  return target;
}

size_t CommandFlow::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandFlow)
  size_t total_size = 0;

  if (_internal_has_consumer_id()) {
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }

  if (_internal_has_messagepermits()) {
    // required uint32 messagePermits = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_messagepermits());
  }

  return total_size;
}
size_t CommandFlow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandFlow)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());

    // required uint32 messagePermits = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_messagepermits());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandFlow::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandFlow*>(
      &from));
}

void CommandFlow::MergeFrom(const CommandFlow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandFlow)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      messagepermits_ = from.messagepermits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandFlow::CopyFrom(const CommandFlow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandFlow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandFlow::InternalSwap(CommandFlow* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandFlow, messagepermits_)
      + sizeof(CommandFlow::messagepermits_)
      - PROTOBUF_FIELD_OFFSET(CommandFlow, consumer_id_)>(
          reinterpret_cast<char*>(&consumer_id_),
          reinterpret_cast<char*>(&other->consumer_id_));
}

std::string CommandFlow::GetTypeName() const {
  return "pulsar.proto.CommandFlow";
}


// ===================================================================

class CommandUnsubscribe::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandUnsubscribe>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandUnsubscribe::CommandUnsubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandUnsubscribe)
}
CommandUnsubscribe::CommandUnsubscribe(const CommandUnsubscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandUnsubscribe)
}

inline void CommandUnsubscribe::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&consumer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
}

CommandUnsubscribe::~CommandUnsubscribe() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandUnsubscribe)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandUnsubscribe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandUnsubscribe::ArenaDtor(void* object) {
  CommandUnsubscribe* _this = reinterpret_cast< CommandUnsubscribe* >(object);
  (void)_this;
}
void CommandUnsubscribe::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandUnsubscribe::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandUnsubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandUnsubscribe)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&request_id_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandUnsubscribe::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandUnsubscribe::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandUnsubscribe)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandUnsubscribe)
  return target;
}

size_t CommandUnsubscribe::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandUnsubscribe)
  size_t total_size = 0;

  if (_internal_has_consumer_id()) {
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandUnsubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandUnsubscribe)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());

    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandUnsubscribe::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandUnsubscribe*>(
      &from));
}

void CommandUnsubscribe::MergeFrom(const CommandUnsubscribe& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandUnsubscribe)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandUnsubscribe::CopyFrom(const CommandUnsubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandUnsubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandUnsubscribe::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandUnsubscribe::InternalSwap(CommandUnsubscribe* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, request_id_)
      + sizeof(CommandUnsubscribe::request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, consumer_id_)>(
          reinterpret_cast<char*>(&consumer_id_),
          reinterpret_cast<char*>(&other->consumer_id_));
}

std::string CommandUnsubscribe::GetTypeName() const {
  return "pulsar.proto.CommandUnsubscribe";
}


// ===================================================================

class CommandSeek::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSeek>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pulsar::proto::MessageIdData& message_id(const CommandSeek* msg);
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message_publish_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::pulsar::proto::MessageIdData&
CommandSeek::_Internal::message_id(const CommandSeek* msg) {
  return *msg->message_id_;
}
CommandSeek::CommandSeek(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSeek)
}
CommandSeek::CommandSeek(const CommandSeek& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_message_id()) {
    message_id_ = new ::pulsar::proto::MessageIdData(*from.message_id_);
  } else {
    message_id_ = nullptr;
  }
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&message_publish_time_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(message_publish_time_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSeek)
}

inline void CommandSeek::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&message_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&message_publish_time_) -
    reinterpret_cast<char*>(&message_id_)) + sizeof(message_publish_time_));
}

CommandSeek::~CommandSeek() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSeek)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandSeek::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete message_id_;
}

void CommandSeek::ArenaDtor(void* object) {
  CommandSeek* _this = reinterpret_cast< CommandSeek* >(object);
  (void)_this;
}
void CommandSeek::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandSeek::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandSeek::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSeek)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(message_id_ != nullptr);
    message_id_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&message_publish_time_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(message_publish_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSeek::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.MessageIdData message_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_message_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 message_publish_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_message_publish_time(&has_bits);
          message_publish_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandSeek::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSeek)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.MessageIdData message_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::message_id(this), target, stream);
  }

  // optional uint64 message_publish_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_message_publish_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSeek)
  return target;
}

size_t CommandSeek::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandSeek)
  size_t total_size = 0;

  if (_internal_has_consumer_id()) {
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandSeek::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSeek)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());

    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.MessageIdData message_id = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *message_id_);
  }

  // optional uint64 message_publish_time = 4;
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_message_publish_time());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandSeek::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandSeek*>(
      &from));
}

void CommandSeek::MergeFrom(const CommandSeek& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSeek)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_message_id()->::pulsar::proto::MessageIdData::MergeFrom(from._internal_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      message_publish_time_ = from.message_publish_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSeek::CopyFrom(const CommandSeek& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSeek)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSeek::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_message_id()) {
    if (!message_id_->IsInitialized()) return false;
  }
  return true;
}

void CommandSeek::InternalSwap(CommandSeek* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSeek, message_publish_time_)
      + sizeof(CommandSeek::message_publish_time_)
      - PROTOBUF_FIELD_OFFSET(CommandSeek, message_id_)>(
          reinterpret_cast<char*>(&message_id_),
          reinterpret_cast<char*>(&other->message_id_));
}

std::string CommandSeek::GetTypeName() const {
  return "pulsar.proto.CommandSeek";
}


// ===================================================================

class CommandReachedEndOfTopic::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandReachedEndOfTopic>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandReachedEndOfTopic::CommandReachedEndOfTopic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandReachedEndOfTopic)
}
CommandReachedEndOfTopic::CommandReachedEndOfTopic(const CommandReachedEndOfTopic& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  consumer_id_ = from.consumer_id_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandReachedEndOfTopic)
}

inline void CommandReachedEndOfTopic::SharedCtor() {
consumer_id_ = uint64_t{0u};
}

CommandReachedEndOfTopic::~CommandReachedEndOfTopic() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandReachedEndOfTopic)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandReachedEndOfTopic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandReachedEndOfTopic::ArenaDtor(void* object) {
  CommandReachedEndOfTopic* _this = reinterpret_cast< CommandReachedEndOfTopic* >(object);
  (void)_this;
}
void CommandReachedEndOfTopic::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandReachedEndOfTopic::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandReachedEndOfTopic::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandReachedEndOfTopic)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  consumer_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandReachedEndOfTopic::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandReachedEndOfTopic::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandReachedEndOfTopic)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandReachedEndOfTopic)
  return target;
}

size_t CommandReachedEndOfTopic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandReachedEndOfTopic)
  size_t total_size = 0;

  // required uint64 consumer_id = 1;
  if (_internal_has_consumer_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandReachedEndOfTopic::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandReachedEndOfTopic*>(
      &from));
}

void CommandReachedEndOfTopic::MergeFrom(const CommandReachedEndOfTopic& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandReachedEndOfTopic)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_consumer_id()) {
    _internal_set_consumer_id(from._internal_consumer_id());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandReachedEndOfTopic::CopyFrom(const CommandReachedEndOfTopic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandReachedEndOfTopic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandReachedEndOfTopic::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandReachedEndOfTopic::InternalSwap(CommandReachedEndOfTopic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(consumer_id_, other->consumer_id_);
}

std::string CommandReachedEndOfTopic::GetTypeName() const {
  return "pulsar.proto.CommandReachedEndOfTopic";
}


// ===================================================================

class CommandTopicMigrated::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandTopicMigrated>()._has_bits_);
  static void set_has_resource_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_resource_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_brokerserviceurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_brokerserviceurltls(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

CommandTopicMigrated::CommandTopicMigrated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandTopicMigrated)
}
CommandTopicMigrated::CommandTopicMigrated(const CommandTopicMigrated& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  brokerserviceurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_brokerserviceurl()) {
    brokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_brokerserviceurl(), 
      GetArenaForAllocation());
  }
  brokerserviceurltls_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_brokerserviceurltls()) {
    brokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_brokerserviceurltls(), 
      GetArenaForAllocation());
  }
  ::memcpy(&resource_id_, &from.resource_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&resource_type_) -
    reinterpret_cast<char*>(&resource_id_)) + sizeof(resource_type_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandTopicMigrated)
}

inline void CommandTopicMigrated::SharedCtor() {
brokerserviceurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
brokerserviceurltls_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&resource_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&resource_type_) -
    reinterpret_cast<char*>(&resource_id_)) + sizeof(resource_type_));
}

CommandTopicMigrated::~CommandTopicMigrated() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandTopicMigrated)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandTopicMigrated::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  brokerserviceurl_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  brokerserviceurltls_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandTopicMigrated::ArenaDtor(void* object) {
  CommandTopicMigrated* _this = reinterpret_cast< CommandTopicMigrated* >(object);
  (void)_this;
}
void CommandTopicMigrated::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandTopicMigrated::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandTopicMigrated::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandTopicMigrated)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      brokerserviceurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      brokerserviceurltls_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&resource_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&resource_type_) -
        reinterpret_cast<char*>(&resource_id_)) + sizeof(resource_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandTopicMigrated::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 resource_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_resource_id(&has_bits);
          resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::CommandTopicMigrated_ResourceType_IsValid(val))) {
            _internal_set_resource_type(static_cast<::pulsar::proto::CommandTopicMigrated_ResourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string brokerServiceUrl = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_brokerserviceurl();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string brokerServiceUrlTls = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_brokerserviceurltls();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandTopicMigrated::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandTopicMigrated)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 resource_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_resource_id(), target);
  }

  // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_resource_type(), target);
  }

  // optional string brokerServiceUrl = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_brokerserviceurl(), target);
  }

  // optional string brokerServiceUrlTls = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_brokerserviceurltls(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandTopicMigrated)
  return target;
}

size_t CommandTopicMigrated::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandTopicMigrated)
  size_t total_size = 0;

  if (_internal_has_resource_id()) {
    // required uint64 resource_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_resource_id());
  }

  if (_internal_has_resource_type()) {
    // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_resource_type());
  }

  return total_size;
}
size_t CommandTopicMigrated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandTopicMigrated)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000c) ^ 0x0000000c) == 0) {  // All required fields are present.
    // required uint64 resource_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_resource_id());

    // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_resource_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string brokerServiceUrl = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brokerserviceurl());
    }

    // optional string brokerServiceUrlTls = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brokerserviceurltls());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandTopicMigrated::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandTopicMigrated*>(
      &from));
}

void CommandTopicMigrated::MergeFrom(const CommandTopicMigrated& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandTopicMigrated)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_brokerserviceurl(from._internal_brokerserviceurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_brokerserviceurltls(from._internal_brokerserviceurltls());
    }
    if (cached_has_bits & 0x00000004u) {
      resource_id_ = from.resource_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      resource_type_ = from.resource_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandTopicMigrated::CopyFrom(const CommandTopicMigrated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandTopicMigrated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandTopicMigrated::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandTopicMigrated::InternalSwap(CommandTopicMigrated* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &brokerserviceurl_, GetArenaForAllocation(),
      &other->brokerserviceurl_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &brokerserviceurltls_, GetArenaForAllocation(),
      &other->brokerserviceurltls_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, resource_type_)
      + sizeof(CommandTopicMigrated::resource_type_)
      - PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, resource_id_)>(
          reinterpret_cast<char*>(&resource_id_),
          reinterpret_cast<char*>(&other->resource_id_));
}

std::string CommandTopicMigrated::GetTypeName() const {
  return "pulsar.proto.CommandTopicMigrated";
}


// ===================================================================

class CommandCloseProducer::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandCloseProducer>()._has_bits_);
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_assignedbrokerserviceurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_assignedbrokerserviceurltls(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

CommandCloseProducer::CommandCloseProducer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandCloseProducer)
}
CommandCloseProducer::CommandCloseProducer(const CommandCloseProducer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  assignedbrokerserviceurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_assignedbrokerserviceurl()) {
    assignedbrokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_assignedbrokerserviceurl(), 
      GetArenaForAllocation());
  }
  assignedbrokerserviceurltls_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_assignedbrokerserviceurltls()) {
    assignedbrokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_assignedbrokerserviceurltls(), 
      GetArenaForAllocation());
  }
  ::memcpy(&producer_id_, &from.producer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&producer_id_)) + sizeof(request_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandCloseProducer)
}

inline void CommandCloseProducer::SharedCtor() {
assignedbrokerserviceurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
assignedbrokerserviceurltls_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&producer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&producer_id_)) + sizeof(request_id_));
}

CommandCloseProducer::~CommandCloseProducer() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandCloseProducer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandCloseProducer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  assignedbrokerserviceurl_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  assignedbrokerserviceurltls_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandCloseProducer::ArenaDtor(void* object) {
  CommandCloseProducer* _this = reinterpret_cast< CommandCloseProducer* >(object);
  (void)_this;
}
void CommandCloseProducer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandCloseProducer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandCloseProducer::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandCloseProducer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      assignedbrokerserviceurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      assignedbrokerserviceurltls_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&producer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&request_id_) -
        reinterpret_cast<char*>(&producer_id_)) + sizeof(request_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandCloseProducer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 producer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_producer_id(&has_bits);
          producer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string assignedBrokerServiceUrl = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_assignedbrokerserviceurl();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string assignedBrokerServiceUrlTls = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_assignedbrokerserviceurltls();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandCloseProducer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandCloseProducer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 producer_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_producer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_request_id(), target);
  }

  // optional string assignedBrokerServiceUrl = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_assignedbrokerserviceurl(), target);
  }

  // optional string assignedBrokerServiceUrlTls = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_assignedbrokerserviceurltls(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandCloseProducer)
  return target;
}

size_t CommandCloseProducer::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandCloseProducer)
  size_t total_size = 0;

  if (_internal_has_producer_id()) {
    // required uint64 producer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandCloseProducer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandCloseProducer)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000c) ^ 0x0000000c) == 0) {  // All required fields are present.
    // required uint64 producer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_producer_id());

    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string assignedBrokerServiceUrl = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_assignedbrokerserviceurl());
    }

    // optional string assignedBrokerServiceUrlTls = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_assignedbrokerserviceurltls());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandCloseProducer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandCloseProducer*>(
      &from));
}

void CommandCloseProducer::MergeFrom(const CommandCloseProducer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandCloseProducer)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_assignedbrokerserviceurl(from._internal_assignedbrokerserviceurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_assignedbrokerserviceurltls(from._internal_assignedbrokerserviceurltls());
    }
    if (cached_has_bits & 0x00000004u) {
      producer_id_ = from.producer_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandCloseProducer::CopyFrom(const CommandCloseProducer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandCloseProducer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandCloseProducer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandCloseProducer::InternalSwap(CommandCloseProducer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &assignedbrokerserviceurl_, GetArenaForAllocation(),
      &other->assignedbrokerserviceurl_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &assignedbrokerserviceurltls_, GetArenaForAllocation(),
      &other->assignedbrokerserviceurltls_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandCloseProducer, request_id_)
      + sizeof(CommandCloseProducer::request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandCloseProducer, producer_id_)>(
          reinterpret_cast<char*>(&producer_id_),
          reinterpret_cast<char*>(&other->producer_id_));
}

std::string CommandCloseProducer::GetTypeName() const {
  return "pulsar.proto.CommandCloseProducer";
}


// ===================================================================

class CommandCloseConsumer::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandCloseConsumer>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_assignedbrokerserviceurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_assignedbrokerserviceurltls(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

CommandCloseConsumer::CommandCloseConsumer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandCloseConsumer)
}
CommandCloseConsumer::CommandCloseConsumer(const CommandCloseConsumer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  assignedbrokerserviceurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_assignedbrokerserviceurl()) {
    assignedbrokerserviceurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_assignedbrokerserviceurl(), 
      GetArenaForAllocation());
  }
  assignedbrokerserviceurltls_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_assignedbrokerserviceurltls()) {
    assignedbrokerserviceurltls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_assignedbrokerserviceurltls(), 
      GetArenaForAllocation());
  }
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandCloseConsumer)
}

inline void CommandCloseConsumer::SharedCtor() {
assignedbrokerserviceurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
assignedbrokerserviceurltls_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&consumer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
}

CommandCloseConsumer::~CommandCloseConsumer() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandCloseConsumer)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandCloseConsumer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  assignedbrokerserviceurl_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  assignedbrokerserviceurltls_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandCloseConsumer::ArenaDtor(void* object) {
  CommandCloseConsumer* _this = reinterpret_cast< CommandCloseConsumer* >(object);
  (void)_this;
}
void CommandCloseConsumer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandCloseConsumer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandCloseConsumer::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandCloseConsumer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      assignedbrokerserviceurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      assignedbrokerserviceurltls_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&request_id_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandCloseConsumer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string assignedBrokerServiceUrl = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_assignedbrokerserviceurl();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string assignedBrokerServiceUrlTls = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_assignedbrokerserviceurltls();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandCloseConsumer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandCloseConsumer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_request_id(), target);
  }

  // optional string assignedBrokerServiceUrl = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_assignedbrokerserviceurl(), target);
  }

  // optional string assignedBrokerServiceUrlTls = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_assignedbrokerserviceurltls(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandCloseConsumer)
  return target;
}

size_t CommandCloseConsumer::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandCloseConsumer)
  size_t total_size = 0;

  if (_internal_has_consumer_id()) {
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandCloseConsumer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandCloseConsumer)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000c) ^ 0x0000000c) == 0) {  // All required fields are present.
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());

    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string assignedBrokerServiceUrl = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_assignedbrokerserviceurl());
    }

    // optional string assignedBrokerServiceUrlTls = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_assignedbrokerserviceurltls());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandCloseConsumer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandCloseConsumer*>(
      &from));
}

void CommandCloseConsumer::MergeFrom(const CommandCloseConsumer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandCloseConsumer)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_assignedbrokerserviceurl(from._internal_assignedbrokerserviceurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_assignedbrokerserviceurltls(from._internal_assignedbrokerserviceurltls());
    }
    if (cached_has_bits & 0x00000004u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandCloseConsumer::CopyFrom(const CommandCloseConsumer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandCloseConsumer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandCloseConsumer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandCloseConsumer::InternalSwap(CommandCloseConsumer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &assignedbrokerserviceurl_, GetArenaForAllocation(),
      &other->assignedbrokerserviceurl_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &assignedbrokerserviceurltls_, GetArenaForAllocation(),
      &other->assignedbrokerserviceurltls_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, request_id_)
      + sizeof(CommandCloseConsumer::request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, consumer_id_)>(
          reinterpret_cast<char*>(&consumer_id_),
          reinterpret_cast<char*>(&other->consumer_id_));
}

std::string CommandCloseConsumer::GetTypeName() const {
  return "pulsar.proto.CommandCloseConsumer";
}


// ===================================================================

class CommandRedeliverUnacknowledgedMessages::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRedeliverUnacknowledgedMessages>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_consumer_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandRedeliverUnacknowledgedMessages::CommandRedeliverUnacknowledgedMessages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  message_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
}
CommandRedeliverUnacknowledgedMessages::CommandRedeliverUnacknowledgedMessages(const CommandRedeliverUnacknowledgedMessages& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      message_ids_(from.message_ids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&consumer_epoch_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(consumer_epoch_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
}

inline void CommandRedeliverUnacknowledgedMessages::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&consumer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&consumer_epoch_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(consumer_epoch_));
}

CommandRedeliverUnacknowledgedMessages::~CommandRedeliverUnacknowledgedMessages() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandRedeliverUnacknowledgedMessages::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandRedeliverUnacknowledgedMessages::ArenaDtor(void* object) {
  CommandRedeliverUnacknowledgedMessages* _this = reinterpret_cast< CommandRedeliverUnacknowledgedMessages* >(object);
  (void)_this;
}
void CommandRedeliverUnacknowledgedMessages::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandRedeliverUnacknowledgedMessages::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandRedeliverUnacknowledgedMessages::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  message_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&consumer_epoch_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(consumer_epoch_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandRedeliverUnacknowledgedMessages::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.MessageIdData message_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_message_ids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint64 consumer_epoch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_consumer_epoch(&has_bits);
          consumer_epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandRedeliverUnacknowledgedMessages::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // repeated .pulsar.proto.MessageIdData message_ids = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_message_ids_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_message_ids(i), target, stream);
  }

  // optional uint64 consumer_epoch = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_consumer_epoch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  return target;
}

size_t CommandRedeliverUnacknowledgedMessages::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  size_t total_size = 0;

  // required uint64 consumer_id = 1;
  if (_internal_has_consumer_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.MessageIdData message_ids = 2;
  total_size += 1UL * this->_internal_message_ids_size();
  for (const auto& msg : this->message_ids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint64 consumer_epoch = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_epoch());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandRedeliverUnacknowledgedMessages::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandRedeliverUnacknowledgedMessages*>(
      &from));
}

void CommandRedeliverUnacknowledgedMessages::MergeFrom(const CommandRedeliverUnacknowledgedMessages& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  message_ids_.MergeFrom(from.message_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      consumer_epoch_ = from.consumer_epoch_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandRedeliverUnacknowledgedMessages::CopyFrom(const CommandRedeliverUnacknowledgedMessages& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRedeliverUnacknowledgedMessages::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(message_ids_)) return false;
  return true;
}

void CommandRedeliverUnacknowledgedMessages::InternalSwap(CommandRedeliverUnacknowledgedMessages* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  message_ids_.InternalSwap(&other->message_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, consumer_epoch_)
      + sizeof(CommandRedeliverUnacknowledgedMessages::consumer_epoch_)
      - PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, consumer_id_)>(
          reinterpret_cast<char*>(&consumer_id_),
          reinterpret_cast<char*>(&other->consumer_id_));
}

std::string CommandRedeliverUnacknowledgedMessages::GetTypeName() const {
  return "pulsar.proto.CommandRedeliverUnacknowledgedMessages";
}


// ===================================================================

class CommandSuccess::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSuccess>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandSuccess* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::pulsar::proto::Schema&
CommandSuccess::_Internal::schema(const CommandSuccess* msg) {
  return *msg->schema_;
}
CommandSuccess::CommandSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSuccess)
}
CommandSuccess::CommandSuccess(const CommandSuccess& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_schema()) {
    schema_ = new ::pulsar::proto::Schema(*from.schema_);
  } else {
    schema_ = nullptr;
  }
  request_id_ = from.request_id_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSuccess)
}

inline void CommandSuccess::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&schema_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&schema_)) + sizeof(request_id_));
}

CommandSuccess::~CommandSuccess() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSuccess)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandSuccess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete schema_;
}

void CommandSuccess::ArenaDtor(void* object) {
  CommandSuccess* _this = reinterpret_cast< CommandSuccess* >(object);
  (void)_this;
}
void CommandSuccess::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandSuccess::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSuccess)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(schema_ != nullptr);
    schema_->Clear();
  }
  request_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSuccess::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.Schema schema = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandSuccess::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSuccess)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.Schema schema = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::schema(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSuccess)
  return target;
}

size_t CommandSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSuccess)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.Schema schema = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *schema_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandSuccess::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandSuccess*>(
      &from));
}

void CommandSuccess::MergeFrom(const CommandSuccess& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSuccess)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(from._internal_schema());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSuccess::CopyFrom(const CommandSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSuccess::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_schema()) {
    if (!schema_->IsInitialized()) return false;
  }
  return true;
}

void CommandSuccess::InternalSwap(CommandSuccess* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSuccess, request_id_)
      + sizeof(CommandSuccess::request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandSuccess, schema_)>(
          reinterpret_cast<char*>(&schema_),
          reinterpret_cast<char*>(&other->schema_));
}

std::string CommandSuccess::GetTypeName() const {
  return "pulsar.proto.CommandSuccess";
}


// ===================================================================

class CommandProducerSuccess::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandProducerSuccess>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_producer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_topic_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_producer_ready(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

CommandProducerSuccess::CommandProducerSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandProducerSuccess)
}
CommandProducerSuccess::CommandProducerSuccess(const CommandProducerSuccess& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  producer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_producer_name()) {
    producer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_producer_name(), 
      GetArenaForAllocation());
  }
  schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema_version()) {
    schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema_version(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_sequence_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(last_sequence_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandProducerSuccess)
}

inline void CommandProducerSuccess::SharedCtor() {
producer_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&topic_epoch_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(topic_epoch_));
producer_ready_ = true;
last_sequence_id_ = int64_t{-1};
}

CommandProducerSuccess::~CommandProducerSuccess() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandProducerSuccess)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandProducerSuccess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  producer_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  schema_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandProducerSuccess::ArenaDtor(void* object) {
  CommandProducerSuccess* _this = reinterpret_cast< CommandProducerSuccess* >(object);
  (void)_this;
}
void CommandProducerSuccess::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandProducerSuccess::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandProducerSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandProducerSuccess)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      producer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      schema_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&topic_epoch_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(topic_epoch_));
    producer_ready_ = true;
    last_sequence_id_ = int64_t{-1};
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandProducerSuccess::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string producer_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_producer_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 last_sequence_id = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_last_sequence_id(&has_bits);
          last_sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes schema_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_schema_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 topic_epoch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_topic_epoch(&has_bits);
          topic_epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool producer_ready = 6 [default = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_producer_ready(&has_bits);
          producer_ready_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandProducerSuccess::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandProducerSuccess)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required string producer_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_producer_name(), target);
  }

  // optional int64 last_sequence_id = 3 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_last_sequence_id(), target);
  }

  // optional bytes schema_version = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_schema_version(), target);
  }

  // optional uint64 topic_epoch = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_topic_epoch(), target);
  }

  // optional bool producer_ready = 6 [default = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_producer_ready(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandProducerSuccess)
  return target;
}

size_t CommandProducerSuccess::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandProducerSuccess)
  size_t total_size = 0;

  if (_internal_has_producer_name()) {
    // required string producer_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_producer_name());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandProducerSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandProducerSuccess)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required string producer_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_producer_name());

    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes schema_version = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_schema_version());
  }

  if (cached_has_bits & 0x00000038u) {
    // optional uint64 topic_epoch = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_topic_epoch());
    }

    // optional bool producer_ready = 6 [default = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int64 last_sequence_id = 3 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_last_sequence_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandProducerSuccess::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandProducerSuccess*>(
      &from));
}

void CommandProducerSuccess::MergeFrom(const CommandProducerSuccess& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandProducerSuccess)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_producer_name(from._internal_producer_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000004u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      topic_epoch_ = from.topic_epoch_;
    }
    if (cached_has_bits & 0x00000010u) {
      producer_ready_ = from.producer_ready_;
    }
    if (cached_has_bits & 0x00000020u) {
      last_sequence_id_ = from.last_sequence_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandProducerSuccess::CopyFrom(const CommandProducerSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandProducerSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandProducerSuccess::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandProducerSuccess::InternalSwap(CommandProducerSuccess* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &producer_name_, GetArenaForAllocation(),
      &other->producer_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_version_, GetArenaForAllocation(),
      &other->schema_version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, topic_epoch_)
      + sizeof(CommandProducerSuccess::topic_epoch_)
      - PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
  swap(producer_ready_, other->producer_ready_);
  swap(last_sequence_id_, other->last_sequence_id_);
}

std::string CommandProducerSuccess::GetTypeName() const {
  return "pulsar.proto.CommandProducerSuccess";
}


// ===================================================================

class CommandError::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandError>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CommandError::CommandError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandError)
}
CommandError::CommandError(const CommandError& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandError)
}

inline void CommandError::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
}

CommandError::~CommandError() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandError)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandError::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandError::ArenaDtor(void* object) {
  CommandError* _this = reinterpret_cast< CommandError* >(object);
  (void)_this;
}
void CommandError::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandError::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandError::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandError)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandError::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pulsar.proto.ServerError error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required string message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandError::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandError)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required .pulsar.proto.ServerError error = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_error(), target);
  }

  // required string message = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandError)
  return target;
}

size_t CommandError::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandError)
  size_t total_size = 0;

  if (_internal_has_message()) {
    // required string message = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  if (_internal_has_error()) {
    // required .pulsar.proto.ServerError error = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
  }

  return total_size;
}
size_t CommandError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandError)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string message = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());

    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

    // required .pulsar.proto.ServerError error = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandError::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandError*>(
      &from));
}

void CommandError::MergeFrom(const CommandError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandError)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandError::CopyFrom(const CommandError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandError::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandError::InternalSwap(CommandError* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandError, error_)
      + sizeof(CommandError::error_)
      - PROTOBUF_FIELD_OFFSET(CommandError, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandError::GetTypeName() const {
  return "pulsar.proto.CommandError";
}


// ===================================================================

class CommandPing::_Internal {
 public:
};

CommandPing::CommandPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandPing)
}
CommandPing::CommandPing(const CommandPing& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandPing)
}

inline void CommandPing::SharedCtor() {
}

CommandPing::~CommandPing() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandPing)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandPing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandPing::ArenaDtor(void* object) {
  CommandPing* _this = reinterpret_cast< CommandPing* >(object);
  (void)_this;
}
void CommandPing::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandPing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandPing::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CommandPing::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandPing::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandPing)
  return target;
}

size_t CommandPing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandPing)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandPing::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandPing*>(
      &from));
}

void CommandPing::MergeFrom(const CommandPing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandPing)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandPing::CopyFrom(const CommandPing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandPing::IsInitialized() const {
  return true;
}

void CommandPing::InternalSwap(CommandPing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CommandPing::GetTypeName() const {
  return "pulsar.proto.CommandPing";
}


// ===================================================================

class CommandPong::_Internal {
 public:
};

CommandPong::CommandPong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandPong)
}
CommandPong::CommandPong(const CommandPong& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandPong)
}

inline void CommandPong::SharedCtor() {
}

CommandPong::~CommandPong() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandPong)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandPong::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandPong::ArenaDtor(void* object) {
  CommandPong* _this = reinterpret_cast< CommandPong* >(object);
  (void)_this;
}
void CommandPong::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandPong::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandPong::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandPong)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CommandPong::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandPong::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandPong)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandPong)
  return target;
}

size_t CommandPong::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandPong)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandPong::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandPong*>(
      &from));
}

void CommandPong::MergeFrom(const CommandPong& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandPong)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandPong::CopyFrom(const CommandPong& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandPong)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandPong::IsInitialized() const {
  return true;
}

void CommandPong::InternalSwap(CommandPong* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CommandPong::GetTypeName() const {
  return "pulsar.proto.CommandPong";
}


// ===================================================================

class CommandConsumerStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandConsumerStats>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandConsumerStats::CommandConsumerStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandConsumerStats)
}
CommandConsumerStats::CommandConsumerStats(const CommandConsumerStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&consumer_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(consumer_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandConsumerStats)
}

inline void CommandConsumerStats::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&consumer_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(consumer_id_));
}

CommandConsumerStats::~CommandConsumerStats() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandConsumerStats)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandConsumerStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandConsumerStats::ArenaDtor(void* object) {
  CommandConsumerStats* _this = reinterpret_cast< CommandConsumerStats* >(object);
  (void)_this;
}
void CommandConsumerStats::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandConsumerStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandConsumerStats::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandConsumerStats)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&consumer_id_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(consumer_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandConsumerStats::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 consumer_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandConsumerStats::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandConsumerStats)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required uint64 consumer_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_consumer_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandConsumerStats)
  return target;
}

size_t CommandConsumerStats::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandConsumerStats)
  size_t total_size = 0;

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  if (_internal_has_consumer_id()) {
    // required uint64 consumer_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }

  return total_size;
}
size_t CommandConsumerStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandConsumerStats)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

    // required uint64 consumer_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandConsumerStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandConsumerStats*>(
      &from));
}

void CommandConsumerStats::MergeFrom(const CommandConsumerStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandConsumerStats)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      consumer_id_ = from.consumer_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandConsumerStats::CopyFrom(const CommandConsumerStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandConsumerStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandConsumerStats::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandConsumerStats::InternalSwap(CommandConsumerStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandConsumerStats, consumer_id_)
      + sizeof(CommandConsumerStats::consumer_id_)
      - PROTOBUF_FIELD_OFFSET(CommandConsumerStats, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandConsumerStats::GetTypeName() const {
  return "pulsar.proto.CommandConsumerStats";
}


// ===================================================================

class CommandConsumerStatsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandConsumerStatsResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_msgrateout(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_msgthroughputout(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_msgrateredeliver(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_consumername(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_availablepermits(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_unackedmessages(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_blockedconsumeronunackedmsgs(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_connectedsince(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_msgrateexpired(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_msgbacklog(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_messageackrate(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000020) ^ 0x00000020) != 0;
  }
};

CommandConsumerStatsResponse::CommandConsumerStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandConsumerStatsResponse)
}
CommandConsumerStatsResponse::CommandConsumerStatsResponse(const CommandConsumerStatsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_error_message()) {
    error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_error_message(), 
      GetArenaForAllocation());
  }
  consumername_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_consumername()) {
    consumername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_consumername(), 
      GetArenaForAllocation());
  }
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_address()) {
    address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_address(), 
      GetArenaForAllocation());
  }
  connectedsince_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_connectedsince()) {
    connectedsince_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_connectedsince(), 
      GetArenaForAllocation());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&messageackrate_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(messageackrate_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandConsumerStatsResponse)
}

inline void CommandConsumerStatsResponse::SharedCtor() {
error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
consumername_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
connectedsince_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&messageackrate_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(messageackrate_));
}

CommandConsumerStatsResponse::~CommandConsumerStatsResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandConsumerStatsResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandConsumerStatsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  consumername_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  connectedsince_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandConsumerStatsResponse::ArenaDtor(void* object) {
  CommandConsumerStatsResponse* _this = reinterpret_cast< CommandConsumerStatsResponse* >(object);
  (void)_this;
}
void CommandConsumerStatsResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandConsumerStatsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandConsumerStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandConsumerStatsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      consumername_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      connectedsince_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      type_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&msgthroughputout_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(msgthroughputout_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&msgrateredeliver_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&messageackrate_) -
        reinterpret_cast<char*>(&msgrateredeliver_)) + sizeof(messageackrate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandConsumerStatsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error_code(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string error_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_error_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double msgRateOut = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_msgrateout(&has_bits);
          msgrateout_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double msgThroughputOut = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_msgthroughputout(&has_bits);
          msgthroughputout_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double msgRateRedeliver = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_msgrateredeliver(&has_bits);
          msgrateredeliver_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional string consumerName = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_consumername();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 availablePermits = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_availablepermits(&has_bits);
          availablepermits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 unackedMessages = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_unackedmessages(&has_bits);
          unackedmessages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool blockedConsumerOnUnackedMsgs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_blockedconsumeronunackedmsgs(&has_bits);
          blockedconsumeronunackedmsgs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string address = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string connectedSince = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          auto str = _internal_mutable_connectedsince();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string type = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double msgRateExpired = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 113)) {
          _Internal::set_has_msgrateexpired(&has_bits);
          msgrateexpired_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional uint64 msgBacklog = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_msgbacklog(&has_bits);
          msgbacklog_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double messageAckRate = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 129)) {
          _Internal::set_has_messageackrate(&has_bits);
          messageackrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandConsumerStatsResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandConsumerStatsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_error_code(), target);
  }

  // optional string error_message = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error_message(), target);
  }

  // optional double msgRateOut = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_msgrateout(), target);
  }

  // optional double msgThroughputOut = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_msgthroughputout(), target);
  }

  // optional double msgRateRedeliver = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_msgrateredeliver(), target);
  }

  // optional string consumerName = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_consumername(), target);
  }

  // optional uint64 availablePermits = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_availablepermits(), target);
  }

  // optional uint64 unackedMessages = 9;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_unackedmessages(), target);
  }

  // optional bool blockedConsumerOnUnackedMsgs = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_blockedconsumeronunackedmsgs(), target);
  }

  // optional string address = 11;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_address(), target);
  }

  // optional string connectedSince = 12;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_connectedsince(), target);
  }

  // optional string type = 13;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_type(), target);
  }

  // optional double msgRateExpired = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(14, this->_internal_msgrateexpired(), target);
  }

  // optional uint64 msgBacklog = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(15, this->_internal_msgbacklog(), target);
  }

  // optional double messageAckRate = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(16, this->_internal_messageackrate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandConsumerStatsResponse)
  return target;
}

size_t CommandConsumerStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandConsumerStatsResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string error_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional string consumerName = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_consumername());
    }

    // optional string address = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address());
    }

    // optional string connectedSince = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_connectedsince());
    }

    // optional string type = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional double msgRateOut = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double msgThroughputOut = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double msgRateRedeliver = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional .pulsar.proto.ServerError error_code = 2;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_code());
    }

    // optional bool blockedConsumerOnUnackedMsgs = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional uint64 availablePermits = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_availablepermits());
    }

    // optional uint64 unackedMessages = 9;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_unackedmessages());
    }

    // optional double msgRateExpired = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional uint64 msgBacklog = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_msgbacklog());
    }

    // optional double messageAckRate = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandConsumerStatsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandConsumerStatsResponse*>(
      &from));
}

void CommandConsumerStatsResponse::MergeFrom(const CommandConsumerStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandConsumerStatsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_consumername(from._internal_consumername());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_connectedsince(from._internal_connectedsince());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000020u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      msgrateout_ = from.msgrateout_;
    }
    if (cached_has_bits & 0x00000080u) {
      msgthroughputout_ = from.msgthroughputout_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      msgrateredeliver_ = from.msgrateredeliver_;
    }
    if (cached_has_bits & 0x00000200u) {
      error_code_ = from.error_code_;
    }
    if (cached_has_bits & 0x00000400u) {
      blockedconsumeronunackedmsgs_ = from.blockedconsumeronunackedmsgs_;
    }
    if (cached_has_bits & 0x00000800u) {
      availablepermits_ = from.availablepermits_;
    }
    if (cached_has_bits & 0x00001000u) {
      unackedmessages_ = from.unackedmessages_;
    }
    if (cached_has_bits & 0x00002000u) {
      msgrateexpired_ = from.msgrateexpired_;
    }
    if (cached_has_bits & 0x00004000u) {
      msgbacklog_ = from.msgbacklog_;
    }
    if (cached_has_bits & 0x00008000u) {
      messageackrate_ = from.messageackrate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandConsumerStatsResponse::CopyFrom(const CommandConsumerStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandConsumerStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandConsumerStatsResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandConsumerStatsResponse::InternalSwap(CommandConsumerStatsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &error_message_, GetArenaForAllocation(),
      &other->error_message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &consumername_, GetArenaForAllocation(),
      &other->consumername_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &address_, GetArenaForAllocation(),
      &other->address_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &connectedsince_, GetArenaForAllocation(),
      &other->connectedsince_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, GetArenaForAllocation(),
      &other->type_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, messageackrate_)
      + sizeof(CommandConsumerStatsResponse::messageackrate_)
      - PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandConsumerStatsResponse::GetTypeName() const {
  return "pulsar.proto.CommandConsumerStatsResponse";
}


// ===================================================================

class CommandGetLastMessageId::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetLastMessageId>()._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandGetLastMessageId::CommandGetLastMessageId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetLastMessageId)
}
CommandGetLastMessageId::CommandGetLastMessageId(const CommandGetLastMessageId& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&consumer_id_, &from.consumer_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetLastMessageId)
}

inline void CommandGetLastMessageId::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&consumer_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
}

CommandGetLastMessageId::~CommandGetLastMessageId() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetLastMessageId)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandGetLastMessageId::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandGetLastMessageId::ArenaDtor(void* object) {
  CommandGetLastMessageId* _this = reinterpret_cast< CommandGetLastMessageId* >(object);
  (void)_this;
}
void CommandGetLastMessageId::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandGetLastMessageId::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandGetLastMessageId::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetLastMessageId)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&consumer_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&request_id_) -
        reinterpret_cast<char*>(&consumer_id_)) + sizeof(request_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetLastMessageId::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 consumer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_consumer_id(&has_bits);
          consumer_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandGetLastMessageId::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetLastMessageId)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetLastMessageId)
  return target;
}

size_t CommandGetLastMessageId::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandGetLastMessageId)
  size_t total_size = 0;

  if (_internal_has_consumer_id()) {
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandGetLastMessageId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetLastMessageId)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 consumer_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_consumer_id());

    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandGetLastMessageId::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandGetLastMessageId*>(
      &from));
}

void CommandGetLastMessageId::MergeFrom(const CommandGetLastMessageId& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetLastMessageId)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      consumer_id_ = from.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetLastMessageId::CopyFrom(const CommandGetLastMessageId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetLastMessageId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandGetLastMessageId::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandGetLastMessageId::InternalSwap(CommandGetLastMessageId* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, request_id_)
      + sizeof(CommandGetLastMessageId::request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, consumer_id_)>(
          reinterpret_cast<char*>(&consumer_id_),
          reinterpret_cast<char*>(&other->consumer_id_));
}

std::string CommandGetLastMessageId::GetTypeName() const {
  return "pulsar.proto.CommandGetLastMessageId";
}


// ===================================================================

class CommandGetLastMessageIdResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetLastMessageIdResponse>()._has_bits_);
  static const ::pulsar::proto::MessageIdData& last_message_id(const CommandGetLastMessageIdResponse* msg);
  static void set_has_last_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pulsar::proto::MessageIdData& consumer_mark_delete_position(const CommandGetLastMessageIdResponse* msg);
  static void set_has_consumer_mark_delete_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

const ::pulsar::proto::MessageIdData&
CommandGetLastMessageIdResponse::_Internal::last_message_id(const CommandGetLastMessageIdResponse* msg) {
  return *msg->last_message_id_;
}
const ::pulsar::proto::MessageIdData&
CommandGetLastMessageIdResponse::_Internal::consumer_mark_delete_position(const CommandGetLastMessageIdResponse* msg) {
  return *msg->consumer_mark_delete_position_;
}
CommandGetLastMessageIdResponse::CommandGetLastMessageIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetLastMessageIdResponse)
}
CommandGetLastMessageIdResponse::CommandGetLastMessageIdResponse(const CommandGetLastMessageIdResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_last_message_id()) {
    last_message_id_ = new ::pulsar::proto::MessageIdData(*from.last_message_id_);
  } else {
    last_message_id_ = nullptr;
  }
  if (from._internal_has_consumer_mark_delete_position()) {
    consumer_mark_delete_position_ = new ::pulsar::proto::MessageIdData(*from.consumer_mark_delete_position_);
  } else {
    consumer_mark_delete_position_ = nullptr;
  }
  request_id_ = from.request_id_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetLastMessageIdResponse)
}

inline void CommandGetLastMessageIdResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&last_message_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&last_message_id_)) + sizeof(request_id_));
}

CommandGetLastMessageIdResponse::~CommandGetLastMessageIdResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetLastMessageIdResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandGetLastMessageIdResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete last_message_id_;
  if (this != internal_default_instance()) delete consumer_mark_delete_position_;
}

void CommandGetLastMessageIdResponse::ArenaDtor(void* object) {
  CommandGetLastMessageIdResponse* _this = reinterpret_cast< CommandGetLastMessageIdResponse* >(object);
  (void)_this;
}
void CommandGetLastMessageIdResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandGetLastMessageIdResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandGetLastMessageIdResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetLastMessageIdResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(last_message_id_ != nullptr);
      last_message_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(consumer_mark_delete_position_ != nullptr);
      consumer_mark_delete_position_->Clear();
    }
  }
  request_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetLastMessageIdResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .pulsar.proto.MessageIdData last_message_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_message_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_consumer_mark_delete_position(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandGetLastMessageIdResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetLastMessageIdResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .pulsar.proto.MessageIdData last_message_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::last_message_id(this), target, stream);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::consumer_mark_delete_position(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetLastMessageIdResponse)
  return target;
}

size_t CommandGetLastMessageIdResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandGetLastMessageIdResponse)
  size_t total_size = 0;

  if (_internal_has_last_message_id()) {
    // required .pulsar.proto.MessageIdData last_message_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *last_message_id_);
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandGetLastMessageIdResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetLastMessageIdResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .pulsar.proto.MessageIdData last_message_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *last_message_id_);

    // required uint64 request_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *consumer_mark_delete_position_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandGetLastMessageIdResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandGetLastMessageIdResponse*>(
      &from));
}

void CommandGetLastMessageIdResponse::MergeFrom(const CommandGetLastMessageIdResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetLastMessageIdResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_last_message_id()->::pulsar::proto::MessageIdData::MergeFrom(from._internal_last_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_consumer_mark_delete_position()->::pulsar::proto::MessageIdData::MergeFrom(from._internal_consumer_mark_delete_position());
    }
    if (cached_has_bits & 0x00000004u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetLastMessageIdResponse::CopyFrom(const CommandGetLastMessageIdResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetLastMessageIdResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandGetLastMessageIdResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_last_message_id()) {
    if (!last_message_id_->IsInitialized()) return false;
  }
  if (_internal_has_consumer_mark_delete_position()) {
    if (!consumer_mark_delete_position_->IsInitialized()) return false;
  }
  return true;
}

void CommandGetLastMessageIdResponse::InternalSwap(CommandGetLastMessageIdResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, request_id_)
      + sizeof(CommandGetLastMessageIdResponse::request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, last_message_id_)>(
          reinterpret_cast<char*>(&last_message_id_),
          reinterpret_cast<char*>(&other->last_message_id_));
}

std::string CommandGetLastMessageIdResponse::GetTypeName() const {
  return "pulsar.proto.CommandGetLastMessageIdResponse";
}


// ===================================================================

class CommandGetTopicsOfNamespace::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetTopicsOfNamespace>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_namespace_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_topics_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
  }
};

CommandGetTopicsOfNamespace::CommandGetTopicsOfNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetTopicsOfNamespace)
}
CommandGetTopicsOfNamespace::CommandGetTopicsOfNamespace(const CommandGetTopicsOfNamespace& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  namespace__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_namespace_()) {
    namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_namespace_(), 
      GetArenaForAllocation());
  }
  topics_pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topics_pattern()) {
    topics_pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topics_pattern(), 
      GetArenaForAllocation());
  }
  topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topics_hash()) {
    topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topics_hash(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetTopicsOfNamespace)
}

inline void CommandGetTopicsOfNamespace::SharedCtor() {
namespace__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
topics_pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(mode_));
}

CommandGetTopicsOfNamespace::~CommandGetTopicsOfNamespace() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetTopicsOfNamespace)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandGetTopicsOfNamespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  namespace__.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  topics_pattern_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  topics_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandGetTopicsOfNamespace::ArenaDtor(void* object) {
  CommandGetTopicsOfNamespace* _this = reinterpret_cast< CommandGetTopicsOfNamespace* >(object);
  (void)_this;
}
void CommandGetTopicsOfNamespace::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandGetTopicsOfNamespace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandGetTopicsOfNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetTopicsOfNamespace)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      namespace__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      topics_pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      topics_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetTopicsOfNamespace::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string namespace = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_namespace_();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::CommandGetTopicsOfNamespace_Mode_IsValid(val))) {
            _internal_set_mode(static_cast<::pulsar::proto::CommandGetTopicsOfNamespace_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string topics_pattern = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_topics_pattern();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string topics_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_topics_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandGetTopicsOfNamespace::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetTopicsOfNamespace)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required string namespace = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_namespace_(), target);
  }

  // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_mode(), target);
  }

  // optional string topics_pattern = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_topics_pattern(), target);
  }

  // optional string topics_hash = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_topics_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetTopicsOfNamespace)
  return target;
}

size_t CommandGetTopicsOfNamespace::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandGetTopicsOfNamespace)
  size_t total_size = 0;

  if (_internal_has_namespace_()) {
    // required string namespace = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_namespace_());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandGetTopicsOfNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetTopicsOfNamespace)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required string namespace = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_namespace_());

    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string topics_pattern = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_topics_pattern());
    }

    // optional string topics_hash = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_topics_hash());
    }

  }
  // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandGetTopicsOfNamespace::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandGetTopicsOfNamespace*>(
      &from));
}

void CommandGetTopicsOfNamespace::MergeFrom(const CommandGetTopicsOfNamespace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetTopicsOfNamespace)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_namespace_(from._internal_namespace_());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_topics_pattern(from._internal_topics_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000008u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetTopicsOfNamespace::CopyFrom(const CommandGetTopicsOfNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetTopicsOfNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandGetTopicsOfNamespace::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandGetTopicsOfNamespace::InternalSwap(CommandGetTopicsOfNamespace* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &namespace__, GetArenaForAllocation(),
      &other->namespace__, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topics_pattern_, GetArenaForAllocation(),
      &other->topics_pattern_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topics_hash_, GetArenaForAllocation(),
      &other->topics_hash_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, mode_)
      + sizeof(CommandGetTopicsOfNamespace::mode_)
      - PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandGetTopicsOfNamespace::GetTypeName() const {
  return "pulsar.proto.CommandGetTopicsOfNamespace";
}


// ===================================================================

class CommandGetTopicsOfNamespaceResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetTopicsOfNamespaceResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filtered(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_changed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandGetTopicsOfNamespaceResponse::CommandGetTopicsOfNamespaceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  topics_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
}
CommandGetTopicsOfNamespaceResponse::CommandGetTopicsOfNamespaceResponse(const CommandGetTopicsOfNamespaceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      topics_(from.topics_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topics_hash()) {
    topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topics_hash(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&changed_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(changed_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
}

inline void CommandGetTopicsOfNamespaceResponse::SharedCtor() {
topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&filtered_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(filtered_));
changed_ = true;
}

CommandGetTopicsOfNamespaceResponse::~CommandGetTopicsOfNamespaceResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandGetTopicsOfNamespaceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topics_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandGetTopicsOfNamespaceResponse::ArenaDtor(void* object) {
  CommandGetTopicsOfNamespaceResponse* _this = reinterpret_cast< CommandGetTopicsOfNamespaceResponse* >(object);
  (void)_this;
}
void CommandGetTopicsOfNamespaceResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandGetTopicsOfNamespaceResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandGetTopicsOfNamespaceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  topics_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topics_hash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&filtered_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(filtered_));
    changed_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetTopicsOfNamespaceResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string topics = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_topics();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool filtered = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_filtered(&has_bits);
          filtered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string topics_hash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_topics_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool changed = 5 [default = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_changed(&has_bits);
          changed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandGetTopicsOfNamespaceResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // repeated string topics = 2;
  for (int i = 0, n = this->_internal_topics_size(); i < n; i++) {
    const auto& s = this->_internal_topics(i);
    target = stream->WriteString(2, s, target);
  }

  // optional bool filtered = 3 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_filtered(), target);
  }

  // optional string topics_hash = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_topics_hash(), target);
  }

  // optional bool changed = 5 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_changed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  return target;
}

size_t CommandGetTopicsOfNamespaceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string topics = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(topics_.size());
  for (int i = 0, n = topics_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      topics_.Get(i));
  }

  // optional string topics_hash = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topics_hash());
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional bool filtered = 3 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool changed = 5 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandGetTopicsOfNamespaceResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandGetTopicsOfNamespaceResponse*>(
      &from));
}

void CommandGetTopicsOfNamespaceResponse::MergeFrom(const CommandGetTopicsOfNamespaceResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  topics_.MergeFrom(from.topics_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      filtered_ = from.filtered_;
    }
    if (cached_has_bits & 0x00000008u) {
      changed_ = from.changed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetTopicsOfNamespaceResponse::CopyFrom(const CommandGetTopicsOfNamespaceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandGetTopicsOfNamespaceResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandGetTopicsOfNamespaceResponse::InternalSwap(CommandGetTopicsOfNamespaceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topics_.InternalSwap(&other->topics_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topics_hash_, GetArenaForAllocation(),
      &other->topics_hash_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, filtered_)
      + sizeof(CommandGetTopicsOfNamespaceResponse::filtered_)
      - PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
  swap(changed_, other->changed_);
}

std::string CommandGetTopicsOfNamespaceResponse::GetTypeName() const {
  return "pulsar.proto.CommandGetTopicsOfNamespaceResponse";
}


// ===================================================================

class CommandWatchTopicList::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandWatchTopicList>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_watcher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_namespace_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_topics_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001b) ^ 0x0000001b) != 0;
  }
};

CommandWatchTopicList::CommandWatchTopicList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandWatchTopicList)
}
CommandWatchTopicList::CommandWatchTopicList(const CommandWatchTopicList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  namespace__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_namespace_()) {
    namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_namespace_(), 
      GetArenaForAllocation());
  }
  topics_pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topics_pattern()) {
    topics_pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topics_pattern(), 
      GetArenaForAllocation());
  }
  topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topics_hash()) {
    topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topics_hash(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&watcher_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(watcher_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandWatchTopicList)
}

inline void CommandWatchTopicList::SharedCtor() {
namespace__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
topics_pattern_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&watcher_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(watcher_id_));
}

CommandWatchTopicList::~CommandWatchTopicList() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandWatchTopicList)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandWatchTopicList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  namespace__.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  topics_pattern_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  topics_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandWatchTopicList::ArenaDtor(void* object) {
  CommandWatchTopicList* _this = reinterpret_cast< CommandWatchTopicList* >(object);
  (void)_this;
}
void CommandWatchTopicList::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandWatchTopicList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandWatchTopicList::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandWatchTopicList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      namespace__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      topics_pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      topics_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&watcher_id_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(watcher_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandWatchTopicList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 watcher_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_watcher_id(&has_bits);
          watcher_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string namespace = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_namespace_();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string topics_pattern = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_topics_pattern();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string topics_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_topics_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandWatchTopicList::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandWatchTopicList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required uint64 watcher_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_watcher_id(), target);
  }

  // required string namespace = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_namespace_(), target);
  }

  // required string topics_pattern = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_topics_pattern(), target);
  }

  // optional string topics_hash = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_topics_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandWatchTopicList)
  return target;
}

size_t CommandWatchTopicList::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandWatchTopicList)
  size_t total_size = 0;

  if (_internal_has_namespace_()) {
    // required string namespace = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_namespace_());
  }

  if (_internal_has_topics_pattern()) {
    // required string topics_pattern = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topics_pattern());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  if (_internal_has_watcher_id()) {
    // required uint64 watcher_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_watcher_id());
  }

  return total_size;
}
size_t CommandWatchTopicList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandWatchTopicList)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001b) ^ 0x0000001b) == 0) {  // All required fields are present.
    // required string namespace = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_namespace_());

    // required string topics_pattern = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topics_pattern());

    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

    // required uint64 watcher_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_watcher_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string topics_hash = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topics_hash());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandWatchTopicList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandWatchTopicList*>(
      &from));
}

void CommandWatchTopicList::MergeFrom(const CommandWatchTopicList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandWatchTopicList)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_namespace_(from._internal_namespace_());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_topics_pattern(from._internal_topics_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000008u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      watcher_id_ = from.watcher_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandWatchTopicList::CopyFrom(const CommandWatchTopicList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandWatchTopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandWatchTopicList::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandWatchTopicList::InternalSwap(CommandWatchTopicList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &namespace__, GetArenaForAllocation(),
      &other->namespace__, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topics_pattern_, GetArenaForAllocation(),
      &other->topics_pattern_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topics_hash_, GetArenaForAllocation(),
      &other->topics_hash_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, watcher_id_)
      + sizeof(CommandWatchTopicList::watcher_id_)
      - PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandWatchTopicList::GetTypeName() const {
  return "pulsar.proto.CommandWatchTopicList";
}


// ===================================================================

class CommandWatchTopicListSuccess::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandWatchTopicListSuccess>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_watcher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CommandWatchTopicListSuccess::CommandWatchTopicListSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  topic_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandWatchTopicListSuccess)
}
CommandWatchTopicListSuccess::CommandWatchTopicListSuccess(const CommandWatchTopicListSuccess& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      topic_(from.topic_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topics_hash()) {
    topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topics_hash(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&watcher_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(watcher_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandWatchTopicListSuccess)
}

inline void CommandWatchTopicListSuccess::SharedCtor() {
topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&watcher_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(watcher_id_));
}

CommandWatchTopicListSuccess::~CommandWatchTopicListSuccess() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandWatchTopicListSuccess)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandWatchTopicListSuccess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topics_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandWatchTopicListSuccess::ArenaDtor(void* object) {
  CommandWatchTopicListSuccess* _this = reinterpret_cast< CommandWatchTopicListSuccess* >(object);
  (void)_this;
}
void CommandWatchTopicListSuccess::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandWatchTopicListSuccess::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandWatchTopicListSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandWatchTopicListSuccess)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  topic_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topics_hash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&watcher_id_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(watcher_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandWatchTopicListSuccess::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 watcher_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_watcher_id(&has_bits);
          watcher_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string topic = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_topic();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // required string topics_hash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_topics_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandWatchTopicListSuccess::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandWatchTopicListSuccess)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required uint64 watcher_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_watcher_id(), target);
  }

  // repeated string topic = 3;
  for (int i = 0, n = this->_internal_topic_size(); i < n; i++) {
    const auto& s = this->_internal_topic(i);
    target = stream->WriteString(3, s, target);
  }

  // required string topics_hash = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_topics_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandWatchTopicListSuccess)
  return target;
}

size_t CommandWatchTopicListSuccess::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandWatchTopicListSuccess)
  size_t total_size = 0;

  if (_internal_has_topics_hash()) {
    // required string topics_hash = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topics_hash());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  if (_internal_has_watcher_id()) {
    // required uint64 watcher_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_watcher_id());
  }

  return total_size;
}
size_t CommandWatchTopicListSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandWatchTopicListSuccess)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string topics_hash = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topics_hash());

    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

    // required uint64 watcher_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_watcher_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string topic = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(topic_.size());
  for (int i = 0, n = topic_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      topic_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandWatchTopicListSuccess::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandWatchTopicListSuccess*>(
      &from));
}

void CommandWatchTopicListSuccess::MergeFrom(const CommandWatchTopicListSuccess& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandWatchTopicListSuccess)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  topic_.MergeFrom(from.topic_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      watcher_id_ = from.watcher_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandWatchTopicListSuccess::CopyFrom(const CommandWatchTopicListSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandWatchTopicListSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandWatchTopicListSuccess::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandWatchTopicListSuccess::InternalSwap(CommandWatchTopicListSuccess* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  topic_.InternalSwap(&other->topic_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topics_hash_, GetArenaForAllocation(),
      &other->topics_hash_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, watcher_id_)
      + sizeof(CommandWatchTopicListSuccess::watcher_id_)
      - PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandWatchTopicListSuccess::GetTypeName() const {
  return "pulsar.proto.CommandWatchTopicListSuccess";
}


// ===================================================================

class CommandWatchTopicUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandWatchTopicUpdate>()._has_bits_);
  static void set_has_watcher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandWatchTopicUpdate::CommandWatchTopicUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  new_topics_(arena),
  deleted_topics_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandWatchTopicUpdate)
}
CommandWatchTopicUpdate::CommandWatchTopicUpdate(const CommandWatchTopicUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      new_topics_(from.new_topics_),
      deleted_topics_(from.deleted_topics_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topics_hash()) {
    topics_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topics_hash(), 
      GetArenaForAllocation());
  }
  watcher_id_ = from.watcher_id_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandWatchTopicUpdate)
}

inline void CommandWatchTopicUpdate::SharedCtor() {
topics_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
watcher_id_ = uint64_t{0u};
}

CommandWatchTopicUpdate::~CommandWatchTopicUpdate() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandWatchTopicUpdate)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandWatchTopicUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topics_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandWatchTopicUpdate::ArenaDtor(void* object) {
  CommandWatchTopicUpdate* _this = reinterpret_cast< CommandWatchTopicUpdate* >(object);
  (void)_this;
}
void CommandWatchTopicUpdate::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandWatchTopicUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandWatchTopicUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandWatchTopicUpdate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  new_topics_.Clear();
  deleted_topics_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topics_hash_.ClearNonDefaultToEmpty();
  }
  watcher_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandWatchTopicUpdate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 watcher_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_watcher_id(&has_bits);
          watcher_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string new_topics = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_new_topics();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string deleted_topics = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_deleted_topics();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // required string topics_hash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_topics_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandWatchTopicUpdate::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandWatchTopicUpdate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 watcher_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_watcher_id(), target);
  }

  // repeated string new_topics = 2;
  for (int i = 0, n = this->_internal_new_topics_size(); i < n; i++) {
    const auto& s = this->_internal_new_topics(i);
    target = stream->WriteString(2, s, target);
  }

  // repeated string deleted_topics = 3;
  for (int i = 0, n = this->_internal_deleted_topics_size(); i < n; i++) {
    const auto& s = this->_internal_deleted_topics(i);
    target = stream->WriteString(3, s, target);
  }

  // required string topics_hash = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_topics_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandWatchTopicUpdate)
  return target;
}

size_t CommandWatchTopicUpdate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandWatchTopicUpdate)
  size_t total_size = 0;

  if (_internal_has_topics_hash()) {
    // required string topics_hash = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topics_hash());
  }

  if (_internal_has_watcher_id()) {
    // required uint64 watcher_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_watcher_id());
  }

  return total_size;
}
size_t CommandWatchTopicUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandWatchTopicUpdate)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string topics_hash = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topics_hash());

    // required uint64 watcher_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_watcher_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string new_topics = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(new_topics_.size());
  for (int i = 0, n = new_topics_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      new_topics_.Get(i));
  }

  // repeated string deleted_topics = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(deleted_topics_.size());
  for (int i = 0, n = deleted_topics_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      deleted_topics_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandWatchTopicUpdate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandWatchTopicUpdate*>(
      &from));
}

void CommandWatchTopicUpdate::MergeFrom(const CommandWatchTopicUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandWatchTopicUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  new_topics_.MergeFrom(from.new_topics_);
  deleted_topics_.MergeFrom(from.deleted_topics_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      watcher_id_ = from.watcher_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandWatchTopicUpdate::CopyFrom(const CommandWatchTopicUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandWatchTopicUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandWatchTopicUpdate::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandWatchTopicUpdate::InternalSwap(CommandWatchTopicUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  new_topics_.InternalSwap(&other->new_topics_);
  deleted_topics_.InternalSwap(&other->deleted_topics_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topics_hash_, GetArenaForAllocation(),
      &other->topics_hash_, other->GetArenaForAllocation()
  );
  swap(watcher_id_, other->watcher_id_);
}

std::string CommandWatchTopicUpdate::GetTypeName() const {
  return "pulsar.proto.CommandWatchTopicUpdate";
}


// ===================================================================

class CommandWatchTopicListClose::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandWatchTopicListClose>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_watcher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandWatchTopicListClose::CommandWatchTopicListClose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandWatchTopicListClose)
}
CommandWatchTopicListClose::CommandWatchTopicListClose(const CommandWatchTopicListClose& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&watcher_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(watcher_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandWatchTopicListClose)
}

inline void CommandWatchTopicListClose::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&watcher_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(watcher_id_));
}

CommandWatchTopicListClose::~CommandWatchTopicListClose() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandWatchTopicListClose)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandWatchTopicListClose::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandWatchTopicListClose::ArenaDtor(void* object) {
  CommandWatchTopicListClose* _this = reinterpret_cast< CommandWatchTopicListClose* >(object);
  (void)_this;
}
void CommandWatchTopicListClose::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandWatchTopicListClose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandWatchTopicListClose::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandWatchTopicListClose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&watcher_id_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(watcher_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandWatchTopicListClose::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 watcher_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_watcher_id(&has_bits);
          watcher_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandWatchTopicListClose::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandWatchTopicListClose)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required uint64 watcher_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_watcher_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandWatchTopicListClose)
  return target;
}

size_t CommandWatchTopicListClose::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandWatchTopicListClose)
  size_t total_size = 0;

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  if (_internal_has_watcher_id()) {
    // required uint64 watcher_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_watcher_id());
  }

  return total_size;
}
size_t CommandWatchTopicListClose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandWatchTopicListClose)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

    // required uint64 watcher_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_watcher_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandWatchTopicListClose::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandWatchTopicListClose*>(
      &from));
}

void CommandWatchTopicListClose::MergeFrom(const CommandWatchTopicListClose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandWatchTopicListClose)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      watcher_id_ = from.watcher_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandWatchTopicListClose::CopyFrom(const CommandWatchTopicListClose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandWatchTopicListClose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandWatchTopicListClose::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandWatchTopicListClose::InternalSwap(CommandWatchTopicListClose* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, watcher_id_)
      + sizeof(CommandWatchTopicListClose::watcher_id_)
      - PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandWatchTopicListClose::GetTypeName() const {
  return "pulsar.proto.CommandWatchTopicListClose";
}


// ===================================================================

class CommandGetSchema::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetSchema>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

CommandGetSchema::CommandGetSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetSchema)
}
CommandGetSchema::CommandGetSchema(const CommandGetSchema& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic()) {
    topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topic(), 
      GetArenaForAllocation());
  }
  schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema_version()) {
    schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema_version(), 
      GetArenaForAllocation());
  }
  request_id_ = from.request_id_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetSchema)
}

inline void CommandGetSchema::SharedCtor() {
topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
request_id_ = uint64_t{0u};
}

CommandGetSchema::~CommandGetSchema() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetSchema)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandGetSchema::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topic_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  schema_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandGetSchema::ArenaDtor(void* object) {
  CommandGetSchema* _this = reinterpret_cast< CommandGetSchema* >(object);
  (void)_this;
}
void CommandGetSchema::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandGetSchema::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandGetSchema::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetSchema)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      schema_version_.ClearNonDefaultToEmpty();
    }
  }
  request_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetSchema::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string topic = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_topic();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes schema_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_schema_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandGetSchema::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetSchema)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required string topic = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_topic(), target);
  }

  // optional bytes schema_version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_schema_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetSchema)
  return target;
}

size_t CommandGetSchema::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandGetSchema)
  size_t total_size = 0;

  if (_internal_has_topic()) {
    // required string topic = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandGetSchema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetSchema)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required string topic = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());

    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes schema_version = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_schema_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandGetSchema::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandGetSchema*>(
      &from));
}

void CommandGetSchema::MergeFrom(const CommandGetSchema& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetSchema)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000004u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetSchema::CopyFrom(const CommandGetSchema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetSchema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandGetSchema::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandGetSchema::InternalSwap(CommandGetSchema* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topic_, GetArenaForAllocation(),
      &other->topic_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_version_, GetArenaForAllocation(),
      &other->schema_version_, other->GetArenaForAllocation()
  );
  swap(request_id_, other->request_id_);
}

std::string CommandGetSchema::GetTypeName() const {
  return "pulsar.proto.CommandGetSchema";
}


// ===================================================================

class CommandGetSchemaResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetSchemaResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandGetSchemaResponse* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

const ::pulsar::proto::Schema&
CommandGetSchemaResponse::_Internal::schema(const CommandGetSchemaResponse* msg) {
  return *msg->schema_;
}
CommandGetSchemaResponse::CommandGetSchemaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetSchemaResponse)
}
CommandGetSchemaResponse::CommandGetSchemaResponse(const CommandGetSchemaResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_error_message()) {
    error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_error_message(), 
      GetArenaForAllocation());
  }
  schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema_version()) {
    schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_schema()) {
    schema_ = new ::pulsar::proto::Schema(*from.schema_);
  } else {
    schema_ = nullptr;
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_code_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_code_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetSchemaResponse)
}

inline void CommandGetSchemaResponse::SharedCtor() {
error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&schema_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_code_) -
    reinterpret_cast<char*>(&schema_)) + sizeof(error_code_));
}

CommandGetSchemaResponse::~CommandGetSchemaResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetSchemaResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandGetSchemaResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  schema_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete schema_;
}

void CommandGetSchemaResponse::ArenaDtor(void* object) {
  CommandGetSchemaResponse* _this = reinterpret_cast< CommandGetSchemaResponse* >(object);
  (void)_this;
}
void CommandGetSchemaResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandGetSchemaResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandGetSchemaResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetSchemaResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      schema_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(schema_ != nullptr);
      schema_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_code_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetSchemaResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error_code(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string error_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_error_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.Schema schema = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes schema_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_schema_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandGetSchemaResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetSchemaResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_error_code(), target);
  }

  // optional string error_message = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error_message(), target);
  }

  // optional .pulsar.proto.Schema schema = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::schema(this), target, stream);
  }

  // optional bytes schema_version = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_schema_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetSchemaResponse)
  return target;
}

size_t CommandGetSchemaResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetSchemaResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string error_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional bytes schema_version = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_schema_version());
    }

    // optional .pulsar.proto.Schema schema = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *schema_);
    }

  }
  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandGetSchemaResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandGetSchemaResponse*>(
      &from));
}

void CommandGetSchemaResponse::MergeFrom(const CommandGetSchemaResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetSchemaResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(from._internal_schema());
    }
    if (cached_has_bits & 0x00000008u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_code_ = from.error_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetSchemaResponse::CopyFrom(const CommandGetSchemaResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetSchemaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandGetSchemaResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_schema()) {
    if (!schema_->IsInitialized()) return false;
  }
  return true;
}

void CommandGetSchemaResponse::InternalSwap(CommandGetSchemaResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &error_message_, GetArenaForAllocation(),
      &other->error_message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_version_, GetArenaForAllocation(),
      &other->schema_version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, error_code_)
      + sizeof(CommandGetSchemaResponse::error_code_)
      - PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, schema_)>(
          reinterpret_cast<char*>(&schema_),
          reinterpret_cast<char*>(&other->schema_));
}

std::string CommandGetSchemaResponse::GetTypeName() const {
  return "pulsar.proto.CommandGetSchemaResponse";
}


// ===================================================================

class CommandGetOrCreateSchema::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetOrCreateSchema>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandGetOrCreateSchema* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::pulsar::proto::Schema&
CommandGetOrCreateSchema::_Internal::schema(const CommandGetOrCreateSchema* msg) {
  return *msg->schema_;
}
CommandGetOrCreateSchema::CommandGetOrCreateSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetOrCreateSchema)
}
CommandGetOrCreateSchema::CommandGetOrCreateSchema(const CommandGetOrCreateSchema& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic()) {
    topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topic(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_schema()) {
    schema_ = new ::pulsar::proto::Schema(*from.schema_);
  } else {
    schema_ = nullptr;
  }
  request_id_ = from.request_id_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetOrCreateSchema)
}

inline void CommandGetOrCreateSchema::SharedCtor() {
topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&schema_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_id_) -
    reinterpret_cast<char*>(&schema_)) + sizeof(request_id_));
}

CommandGetOrCreateSchema::~CommandGetOrCreateSchema() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetOrCreateSchema)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandGetOrCreateSchema::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topic_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete schema_;
}

void CommandGetOrCreateSchema::ArenaDtor(void* object) {
  CommandGetOrCreateSchema* _this = reinterpret_cast< CommandGetOrCreateSchema* >(object);
  (void)_this;
}
void CommandGetOrCreateSchema::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandGetOrCreateSchema::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandGetOrCreateSchema::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetOrCreateSchema)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(schema_ != nullptr);
      schema_->Clear();
    }
  }
  request_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetOrCreateSchema::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string topic = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_topic();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .pulsar.proto.Schema schema = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandGetOrCreateSchema::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetOrCreateSchema)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required string topic = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_topic(), target);
  }

  // required .pulsar.proto.Schema schema = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::schema(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetOrCreateSchema)
  return target;
}

size_t CommandGetOrCreateSchema::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandGetOrCreateSchema)
  size_t total_size = 0;

  if (_internal_has_topic()) {
    // required string topic = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  if (_internal_has_schema()) {
    // required .pulsar.proto.Schema schema = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *schema_);
  }

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  return total_size;
}
size_t CommandGetOrCreateSchema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetOrCreateSchema)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string topic = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());

    // required .pulsar.proto.Schema schema = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *schema_);

    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandGetOrCreateSchema::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandGetOrCreateSchema*>(
      &from));
}

void CommandGetOrCreateSchema::MergeFrom(const CommandGetOrCreateSchema& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetOrCreateSchema)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(from._internal_schema());
    }
    if (cached_has_bits & 0x00000004u) {
      request_id_ = from.request_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetOrCreateSchema::CopyFrom(const CommandGetOrCreateSchema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetOrCreateSchema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandGetOrCreateSchema::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_schema()) {
    if (!schema_->IsInitialized()) return false;
  }
  return true;
}

void CommandGetOrCreateSchema::InternalSwap(CommandGetOrCreateSchema* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topic_, GetArenaForAllocation(),
      &other->topic_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, request_id_)
      + sizeof(CommandGetOrCreateSchema::request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, schema_)>(
          reinterpret_cast<char*>(&schema_),
          reinterpret_cast<char*>(&other->schema_));
}

std::string CommandGetOrCreateSchema::GetTypeName() const {
  return "pulsar.proto.CommandGetOrCreateSchema";
}


// ===================================================================

class CommandGetOrCreateSchemaResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetOrCreateSchemaResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

CommandGetOrCreateSchemaResponse::CommandGetOrCreateSchemaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetOrCreateSchemaResponse)
}
CommandGetOrCreateSchemaResponse::CommandGetOrCreateSchemaResponse(const CommandGetOrCreateSchemaResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_error_message()) {
    error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_error_message(), 
      GetArenaForAllocation());
  }
  schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema_version()) {
    schema_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema_version(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_code_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_code_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetOrCreateSchemaResponse)
}

inline void CommandGetOrCreateSchemaResponse::SharedCtor() {
error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
schema_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_code_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_code_));
}

CommandGetOrCreateSchemaResponse::~CommandGetOrCreateSchemaResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetOrCreateSchemaResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandGetOrCreateSchemaResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  schema_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandGetOrCreateSchemaResponse::ArenaDtor(void* object) {
  CommandGetOrCreateSchemaResponse* _this = reinterpret_cast< CommandGetOrCreateSchemaResponse* >(object);
  (void)_this;
}
void CommandGetOrCreateSchemaResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandGetOrCreateSchemaResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandGetOrCreateSchemaResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      schema_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_code_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetOrCreateSchemaResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error_code(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string error_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_error_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes schema_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_schema_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandGetOrCreateSchemaResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_error_code(), target);
  }

  // optional string error_message = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error_message(), target);
  }

  // optional bytes schema_version = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_schema_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetOrCreateSchemaResponse)
  return target;
}

size_t CommandGetOrCreateSchemaResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string error_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional bytes schema_version = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_schema_version());
    }

  }
  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandGetOrCreateSchemaResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandGetOrCreateSchemaResponse*>(
      &from));
}

void CommandGetOrCreateSchemaResponse::MergeFrom(const CommandGetOrCreateSchemaResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000004u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      error_code_ = from.error_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetOrCreateSchemaResponse::CopyFrom(const CommandGetOrCreateSchemaResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandGetOrCreateSchemaResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandGetOrCreateSchemaResponse::InternalSwap(CommandGetOrCreateSchemaResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &error_message_, GetArenaForAllocation(),
      &other->error_message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_version_, GetArenaForAllocation(),
      &other->schema_version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, error_code_)
      + sizeof(CommandGetOrCreateSchemaResponse::error_code_)
      - PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandGetOrCreateSchemaResponse::GetTypeName() const {
  return "pulsar.proto.CommandGetOrCreateSchemaResponse";
}


// ===================================================================

class CommandTcClientConnectRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandTcClientConnectRequest>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tc_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandTcClientConnectRequest::CommandTcClientConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandTcClientConnectRequest)
}
CommandTcClientConnectRequest::CommandTcClientConnectRequest(const CommandTcClientConnectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&tc_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(tc_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandTcClientConnectRequest)
}

inline void CommandTcClientConnectRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tc_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(tc_id_));
}

CommandTcClientConnectRequest::~CommandTcClientConnectRequest() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandTcClientConnectRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandTcClientConnectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandTcClientConnectRequest::ArenaDtor(void* object) {
  CommandTcClientConnectRequest* _this = reinterpret_cast< CommandTcClientConnectRequest* >(object);
  (void)_this;
}
void CommandTcClientConnectRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandTcClientConnectRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandTcClientConnectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandTcClientConnectRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tc_id_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(tc_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandTcClientConnectRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 tc_id = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_tc_id(&has_bits);
          tc_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandTcClientConnectRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandTcClientConnectRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // required uint64 tc_id = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_tc_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandTcClientConnectRequest)
  return target;
}

size_t CommandTcClientConnectRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.CommandTcClientConnectRequest)
  size_t total_size = 0;

  if (_internal_has_request_id()) {
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }

  if (_internal_has_tc_id()) {
    // required uint64 tc_id = 2 [default = 0];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_tc_id());
  }

  return total_size;
}
size_t CommandTcClientConnectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandTcClientConnectRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 request_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());

    // required uint64 tc_id = 2 [default = 0];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_tc_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandTcClientConnectRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandTcClientConnectRequest*>(
      &from));
}

void CommandTcClientConnectRequest::MergeFrom(const CommandTcClientConnectRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandTcClientConnectRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      tc_id_ = from.tc_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandTcClientConnectRequest::CopyFrom(const CommandTcClientConnectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandTcClientConnectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandTcClientConnectRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandTcClientConnectRequest::InternalSwap(CommandTcClientConnectRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, tc_id_)
      + sizeof(CommandTcClientConnectRequest::tc_id_)
      - PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandTcClientConnectRequest::GetTypeName() const {
  return "pulsar.proto.CommandTcClientConnectRequest";
}


// ===================================================================

class CommandTcClientConnectResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandTcClientConnectResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandTcClientConnectResponse::CommandTcClientConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandTcClientConnectResponse)
}
CommandTcClientConnectResponse::CommandTcClientConnectResponse(const CommandTcClientConnectResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandTcClientConnectResponse)
}

inline void CommandTcClientConnectResponse::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
}

CommandTcClientConnectResponse::~CommandTcClientConnectResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandTcClientConnectResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandTcClientConnectResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandTcClientConnectResponse::ArenaDtor(void* object) {
  CommandTcClientConnectResponse* _this = reinterpret_cast< CommandTcClientConnectResponse* >(object);
  (void)_this;
}
void CommandTcClientConnectResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandTcClientConnectResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandTcClientConnectResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandTcClientConnectResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandTcClientConnectResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandTcClientConnectResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandTcClientConnectResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.ServerError error = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_error(), target);
  }

  // optional string message = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandTcClientConnectResponse)
  return target;
}

size_t CommandTcClientConnectResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandTcClientConnectResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  // optional .pulsar.proto.ServerError error = 2;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandTcClientConnectResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandTcClientConnectResponse*>(
      &from));
}

void CommandTcClientConnectResponse::MergeFrom(const CommandTcClientConnectResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandTcClientConnectResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandTcClientConnectResponse::CopyFrom(const CommandTcClientConnectResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandTcClientConnectResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandTcClientConnectResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandTcClientConnectResponse::InternalSwap(CommandTcClientConnectResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, error_)
      + sizeof(CommandTcClientConnectResponse::error_)
      - PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandTcClientConnectResponse::GetTypeName() const {
  return "pulsar.proto.CommandTcClientConnectResponse";
}


// ===================================================================

class CommandNewTxn::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandNewTxn>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txn_ttl_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tc_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandNewTxn::CommandNewTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandNewTxn)
}
CommandNewTxn::CommandNewTxn(const CommandNewTxn& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&tc_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(tc_id_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandNewTxn)
}

inline void CommandNewTxn::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tc_id_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(tc_id_));
}

CommandNewTxn::~CommandNewTxn() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandNewTxn)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandNewTxn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandNewTxn::ArenaDtor(void* object) {
  CommandNewTxn* _this = reinterpret_cast< CommandNewTxn* >(object);
  (void)_this;
}
void CommandNewTxn::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandNewTxn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandNewTxn::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandNewTxn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tc_id_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(tc_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandNewTxn::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txn_ttl_seconds = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txn_ttl_seconds(&has_bits);
          txn_ttl_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 tc_id = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_tc_id(&has_bits);
          tc_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandNewTxn::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandNewTxn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txn_ttl_seconds = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txn_ttl_seconds(), target);
  }

  // optional uint64 tc_id = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_tc_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandNewTxn)
  return target;
}

size_t CommandNewTxn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandNewTxn)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint64 txn_ttl_seconds = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txn_ttl_seconds());
    }

    // optional uint64 tc_id = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_tc_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandNewTxn::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandNewTxn*>(
      &from));
}

void CommandNewTxn::MergeFrom(const CommandNewTxn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandNewTxn)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      txn_ttl_seconds_ = from.txn_ttl_seconds_;
    }
    if (cached_has_bits & 0x00000004u) {
      tc_id_ = from.tc_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandNewTxn::CopyFrom(const CommandNewTxn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandNewTxn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandNewTxn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandNewTxn::InternalSwap(CommandNewTxn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandNewTxn, tc_id_)
      + sizeof(CommandNewTxn::tc_id_)
      - PROTOBUF_FIELD_OFFSET(CommandNewTxn, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandNewTxn::GetTypeName() const {
  return "pulsar.proto.CommandNewTxn";
}


// ===================================================================

class CommandNewTxnResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandNewTxnResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandNewTxnResponse::CommandNewTxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandNewTxnResponse)
}
CommandNewTxnResponse::CommandNewTxnResponse(const CommandNewTxnResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandNewTxnResponse)
}

inline void CommandNewTxnResponse::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
}

CommandNewTxnResponse::~CommandNewTxnResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandNewTxnResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandNewTxnResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandNewTxnResponse::ArenaDtor(void* object) {
  CommandNewTxnResponse* _this = reinterpret_cast< CommandNewTxnResponse* >(object);
  (void)_this;
}
void CommandNewTxnResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandNewTxnResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandNewTxnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandNewTxnResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandNewTxnResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandNewTxnResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandNewTxnResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandNewTxnResponse)
  return target;
}

size_t CommandNewTxnResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandNewTxnResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandNewTxnResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandNewTxnResponse*>(
      &from));
}

void CommandNewTxnResponse::MergeFrom(const CommandNewTxnResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandNewTxnResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandNewTxnResponse::CopyFrom(const CommandNewTxnResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandNewTxnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandNewTxnResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandNewTxnResponse::InternalSwap(CommandNewTxnResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, error_)
      + sizeof(CommandNewTxnResponse::error_)
      - PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandNewTxnResponse::GetTypeName() const {
  return "pulsar.proto.CommandNewTxnResponse";
}


// ===================================================================

class CommandAddPartitionToTxn::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAddPartitionToTxn>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandAddPartitionToTxn::CommandAddPartitionToTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  partitions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAddPartitionToTxn)
}
CommandAddPartitionToTxn::CommandAddPartitionToTxn(const CommandAddPartitionToTxn& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      partitions_(from.partitions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&txnid_most_bits_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(txnid_most_bits_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAddPartitionToTxn)
}

inline void CommandAddPartitionToTxn::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&txnid_most_bits_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(txnid_most_bits_));
}

CommandAddPartitionToTxn::~CommandAddPartitionToTxn() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAddPartitionToTxn)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandAddPartitionToTxn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandAddPartitionToTxn::ArenaDtor(void* object) {
  CommandAddPartitionToTxn* _this = reinterpret_cast< CommandAddPartitionToTxn* >(object);
  (void)_this;
}
void CommandAddPartitionToTxn::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandAddPartitionToTxn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandAddPartitionToTxn::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAddPartitionToTxn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partitions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&txnid_most_bits_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(txnid_most_bits_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAddPartitionToTxn::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string partitions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_partitions();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandAddPartitionToTxn::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAddPartitionToTxn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // repeated string partitions = 4;
  for (int i = 0, n = this->_internal_partitions_size(); i < n; i++) {
    const auto& s = this->_internal_partitions(i);
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAddPartitionToTxn)
  return target;
}

size_t CommandAddPartitionToTxn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAddPartitionToTxn)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string partitions = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(partitions_.size());
  for (int i = 0, n = partitions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      partitions_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandAddPartitionToTxn::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandAddPartitionToTxn*>(
      &from));
}

void CommandAddPartitionToTxn::MergeFrom(const CommandAddPartitionToTxn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAddPartitionToTxn)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  partitions_.MergeFrom(from.partitions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAddPartitionToTxn::CopyFrom(const CommandAddPartitionToTxn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAddPartitionToTxn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandAddPartitionToTxn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandAddPartitionToTxn::InternalSwap(CommandAddPartitionToTxn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partitions_.InternalSwap(&other->partitions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, txnid_most_bits_)
      + sizeof(CommandAddPartitionToTxn::txnid_most_bits_)
      - PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandAddPartitionToTxn::GetTypeName() const {
  return "pulsar.proto.CommandAddPartitionToTxn";
}


// ===================================================================

class CommandAddPartitionToTxnResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAddPartitionToTxnResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandAddPartitionToTxnResponse::CommandAddPartitionToTxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAddPartitionToTxnResponse)
}
CommandAddPartitionToTxnResponse::CommandAddPartitionToTxnResponse(const CommandAddPartitionToTxnResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAddPartitionToTxnResponse)
}

inline void CommandAddPartitionToTxnResponse::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
}

CommandAddPartitionToTxnResponse::~CommandAddPartitionToTxnResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAddPartitionToTxnResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandAddPartitionToTxnResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandAddPartitionToTxnResponse::ArenaDtor(void* object) {
  CommandAddPartitionToTxnResponse* _this = reinterpret_cast< CommandAddPartitionToTxnResponse* >(object);
  (void)_this;
}
void CommandAddPartitionToTxnResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandAddPartitionToTxnResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandAddPartitionToTxnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAddPartitionToTxnResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandAddPartitionToTxnResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAddPartitionToTxnResponse)
  return target;
}

size_t CommandAddPartitionToTxnResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandAddPartitionToTxnResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandAddPartitionToTxnResponse*>(
      &from));
}

void CommandAddPartitionToTxnResponse::MergeFrom(const CommandAddPartitionToTxnResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAddPartitionToTxnResponse::CopyFrom(const CommandAddPartitionToTxnResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandAddPartitionToTxnResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandAddPartitionToTxnResponse::InternalSwap(CommandAddPartitionToTxnResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, error_)
      + sizeof(CommandAddPartitionToTxnResponse::error_)
      - PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandAddPartitionToTxnResponse::GetTypeName() const {
  return "pulsar.proto.CommandAddPartitionToTxnResponse";
}


// ===================================================================

class Subscription::_Internal {
 public:
  using HasBits = decltype(std::declval<Subscription>()._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_subscription(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Subscription::Subscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.Subscription)
}
Subscription::Subscription(const Subscription& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic()) {
    topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topic(), 
      GetArenaForAllocation());
  }
  subscription_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_subscription()) {
    subscription_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_subscription(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.Subscription)
}

inline void Subscription::SharedCtor() {
topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
subscription_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Subscription::~Subscription() {
  // @@protoc_insertion_point(destructor:pulsar.proto.Subscription)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Subscription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topic_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  subscription_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Subscription::ArenaDtor(void* object) {
  Subscription* _this = reinterpret_cast< Subscription* >(object);
  (void)_this;
}
void Subscription::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Subscription::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Subscription::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.Subscription)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      subscription_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Subscription::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string topic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_topic();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string subscription = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_subscription();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Subscription::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.Subscription)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_topic(), target);
  }

  // required string subscription = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_subscription(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.Subscription)
  return target;
}

size_t Subscription::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:pulsar.proto.Subscription)
  size_t total_size = 0;

  if (_internal_has_topic()) {
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  if (_internal_has_subscription()) {
    // required string subscription = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_subscription());
  }

  return total_size;
}
size_t Subscription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.Subscription)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string topic = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());

    // required string subscription = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_subscription());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Subscription::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Subscription*>(
      &from));
}

void Subscription::MergeFrom(const Subscription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.Subscription)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_subscription(from._internal_subscription());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Subscription::CopyFrom(const Subscription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.Subscription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Subscription::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Subscription::InternalSwap(Subscription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topic_, GetArenaForAllocation(),
      &other->topic_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &subscription_, GetArenaForAllocation(),
      &other->subscription_, other->GetArenaForAllocation()
  );
}

std::string Subscription::GetTypeName() const {
  return "pulsar.proto.Subscription";
}


// ===================================================================

class CommandAddSubscriptionToTxn::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAddSubscriptionToTxn>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandAddSubscriptionToTxn::CommandAddSubscriptionToTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  subscription_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAddSubscriptionToTxn)
}
CommandAddSubscriptionToTxn::CommandAddSubscriptionToTxn(const CommandAddSubscriptionToTxn& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      subscription_(from.subscription_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&txnid_most_bits_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(txnid_most_bits_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAddSubscriptionToTxn)
}

inline void CommandAddSubscriptionToTxn::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&txnid_most_bits_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(txnid_most_bits_));
}

CommandAddSubscriptionToTxn::~CommandAddSubscriptionToTxn() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAddSubscriptionToTxn)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandAddSubscriptionToTxn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandAddSubscriptionToTxn::ArenaDtor(void* object) {
  CommandAddSubscriptionToTxn* _this = reinterpret_cast< CommandAddSubscriptionToTxn* >(object);
  (void)_this;
}
void CommandAddSubscriptionToTxn::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandAddSubscriptionToTxn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandAddSubscriptionToTxn::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAddSubscriptionToTxn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  subscription_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&txnid_most_bits_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(txnid_most_bits_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAddSubscriptionToTxn::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .pulsar.proto.Subscription subscription = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subscription(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandAddSubscriptionToTxn::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAddSubscriptionToTxn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // repeated .pulsar.proto.Subscription subscription = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_subscription_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_subscription(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAddSubscriptionToTxn)
  return target;
}

size_t CommandAddSubscriptionToTxn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAddSubscriptionToTxn)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.Subscription subscription = 4;
  total_size += 1UL * this->_internal_subscription_size();
  for (const auto& msg : this->subscription_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandAddSubscriptionToTxn::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandAddSubscriptionToTxn*>(
      &from));
}

void CommandAddSubscriptionToTxn::MergeFrom(const CommandAddSubscriptionToTxn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAddSubscriptionToTxn)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  subscription_.MergeFrom(from.subscription_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAddSubscriptionToTxn::CopyFrom(const CommandAddSubscriptionToTxn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAddSubscriptionToTxn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandAddSubscriptionToTxn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(subscription_)) return false;
  return true;
}

void CommandAddSubscriptionToTxn::InternalSwap(CommandAddSubscriptionToTxn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  subscription_.InternalSwap(&other->subscription_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, txnid_most_bits_)
      + sizeof(CommandAddSubscriptionToTxn::txnid_most_bits_)
      - PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandAddSubscriptionToTxn::GetTypeName() const {
  return "pulsar.proto.CommandAddSubscriptionToTxn";
}


// ===================================================================

class CommandAddSubscriptionToTxnResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAddSubscriptionToTxnResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandAddSubscriptionToTxnResponse::CommandAddSubscriptionToTxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAddSubscriptionToTxnResponse)
}
CommandAddSubscriptionToTxnResponse::CommandAddSubscriptionToTxnResponse(const CommandAddSubscriptionToTxnResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAddSubscriptionToTxnResponse)
}

inline void CommandAddSubscriptionToTxnResponse::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
}

CommandAddSubscriptionToTxnResponse::~CommandAddSubscriptionToTxnResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandAddSubscriptionToTxnResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandAddSubscriptionToTxnResponse::ArenaDtor(void* object) {
  CommandAddSubscriptionToTxnResponse* _this = reinterpret_cast< CommandAddSubscriptionToTxnResponse* >(object);
  (void)_this;
}
void CommandAddSubscriptionToTxnResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandAddSubscriptionToTxnResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandAddSubscriptionToTxnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAddSubscriptionToTxnResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandAddSubscriptionToTxnResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  return target;
}

size_t CommandAddSubscriptionToTxnResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandAddSubscriptionToTxnResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandAddSubscriptionToTxnResponse*>(
      &from));
}

void CommandAddSubscriptionToTxnResponse::MergeFrom(const CommandAddSubscriptionToTxnResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAddSubscriptionToTxnResponse::CopyFrom(const CommandAddSubscriptionToTxnResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandAddSubscriptionToTxnResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandAddSubscriptionToTxnResponse::InternalSwap(CommandAddSubscriptionToTxnResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, error_)
      + sizeof(CommandAddSubscriptionToTxnResponse::error_)
      - PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandAddSubscriptionToTxnResponse::GetTypeName() const {
  return "pulsar.proto.CommandAddSubscriptionToTxnResponse";
}


// ===================================================================

class CommandEndTxn::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxn>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txn_action(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandEndTxn::CommandEndTxn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxn)
}
CommandEndTxn::CommandEndTxn(const CommandEndTxn& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&txn_action_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(txn_action_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxn)
}

inline void CommandEndTxn::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&txn_action_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(txn_action_));
}

CommandEndTxn::~CommandEndTxn() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxn)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandEndTxn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandEndTxn::ArenaDtor(void* object) {
  CommandEndTxn* _this = reinterpret_cast< CommandEndTxn* >(object);
  (void)_this;
}
void CommandEndTxn::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandEndTxn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandEndTxn::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&txn_action_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(txn_action_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxn::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.TxnAction txn_action = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::TxnAction_IsValid(val))) {
            _internal_set_txn_action(static_cast<::pulsar::proto::TxnAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandEndTxn::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.TxnAction txn_action = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_txn_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxn)
  return target;
}

size_t CommandEndTxn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxn)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.TxnAction txn_action = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_txn_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandEndTxn::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandEndTxn*>(
      &from));
}

void CommandEndTxn::MergeFrom(const CommandEndTxn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxn)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txn_action_ = from.txn_action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxn::CopyFrom(const CommandEndTxn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandEndTxn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandEndTxn::InternalSwap(CommandEndTxn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxn, txn_action_)
      + sizeof(CommandEndTxn::txn_action_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxn, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandEndTxn::GetTypeName() const {
  return "pulsar.proto.CommandEndTxn";
}


// ===================================================================

class CommandEndTxnResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandEndTxnResponse::CommandEndTxnResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnResponse)
}
CommandEndTxnResponse::CommandEndTxnResponse(const CommandEndTxnResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnResponse)
}

inline void CommandEndTxnResponse::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
}

CommandEndTxnResponse::~CommandEndTxnResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandEndTxnResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandEndTxnResponse::ArenaDtor(void* object) {
  CommandEndTxnResponse* _this = reinterpret_cast< CommandEndTxnResponse* >(object);
  (void)_this;
}
void CommandEndTxnResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandEndTxnResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandEndTxnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandEndTxnResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnResponse)
  return target;
}

size_t CommandEndTxnResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandEndTxnResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandEndTxnResponse*>(
      &from));
}

void CommandEndTxnResponse::MergeFrom(const CommandEndTxnResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnResponse::CopyFrom(const CommandEndTxnResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandEndTxnResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandEndTxnResponse::InternalSwap(CommandEndTxnResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, error_)
      + sizeof(CommandEndTxnResponse::error_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandEndTxnResponse::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnResponse";
}


// ===================================================================

class CommandEndTxnOnPartition::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnOnPartition>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txn_action(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_txnid_least_bits_of_low_watermark(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandEndTxnOnPartition::CommandEndTxnOnPartition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnOnPartition)
}
CommandEndTxnOnPartition::CommandEndTxnOnPartition(const CommandEndTxnOnPartition& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_topic()) {
    topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_topic(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&txn_action_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(txn_action_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnOnPartition)
}

inline void CommandEndTxnOnPartition::SharedCtor() {
topic_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&txn_action_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(txn_action_));
}

CommandEndTxnOnPartition::~CommandEndTxnOnPartition() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnOnPartition)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandEndTxnOnPartition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  topic_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandEndTxnOnPartition::ArenaDtor(void* object) {
  CommandEndTxnOnPartition* _this = reinterpret_cast< CommandEndTxnOnPartition* >(object);
  (void)_this;
}
void CommandEndTxnOnPartition::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandEndTxnOnPartition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandEndTxnOnPartition::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnOnPartition)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    topic_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&txn_action_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(txn_action_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnOnPartition::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string topic = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_topic();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.TxnAction txn_action = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::TxnAction_IsValid(val))) {
            _internal_set_txn_action(static_cast<::pulsar::proto::TxnAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits_of_low_watermark = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_txnid_least_bits_of_low_watermark(&has_bits);
          txnid_least_bits_of_low_watermark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandEndTxnOnPartition::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnOnPartition)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional string topic = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_topic(), target);
  }

  // optional .pulsar.proto.TxnAction txn_action = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_txn_action(), target);
  }

  // optional uint64 txnid_least_bits_of_low_watermark = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_txnid_least_bits_of_low_watermark(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnOnPartition)
  return target;
}

size_t CommandEndTxnOnPartition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnOnPartition)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string topic = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  if (cached_has_bits & 0x0000003cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 txnid_least_bits_of_low_watermark = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits_of_low_watermark());
    }

    // optional .pulsar.proto.TxnAction txn_action = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_txn_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandEndTxnOnPartition::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandEndTxnOnPartition*>(
      &from));
}

void CommandEndTxnOnPartition::MergeFrom(const CommandEndTxnOnPartition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnOnPartition)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      txnid_least_bits_of_low_watermark_ = from.txnid_least_bits_of_low_watermark_;
    }
    if (cached_has_bits & 0x00000020u) {
      txn_action_ = from.txn_action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnOnPartition::CopyFrom(const CommandEndTxnOnPartition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnOnPartition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandEndTxnOnPartition::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandEndTxnOnPartition::InternalSwap(CommandEndTxnOnPartition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &topic_, GetArenaForAllocation(),
      &other->topic_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, txn_action_)
      + sizeof(CommandEndTxnOnPartition::txn_action_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandEndTxnOnPartition::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnOnPartition";
}


// ===================================================================

class CommandEndTxnOnPartitionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnOnPartitionResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandEndTxnOnPartitionResponse::CommandEndTxnOnPartitionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnOnPartitionResponse)
}
CommandEndTxnOnPartitionResponse::CommandEndTxnOnPartitionResponse(const CommandEndTxnOnPartitionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnOnPartitionResponse)
}

inline void CommandEndTxnOnPartitionResponse::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
}

CommandEndTxnOnPartitionResponse::~CommandEndTxnOnPartitionResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnOnPartitionResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandEndTxnOnPartitionResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandEndTxnOnPartitionResponse::ArenaDtor(void* object) {
  CommandEndTxnOnPartitionResponse* _this = reinterpret_cast< CommandEndTxnOnPartitionResponse* >(object);
  (void)_this;
}
void CommandEndTxnOnPartitionResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandEndTxnOnPartitionResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandEndTxnOnPartitionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnOnPartitionResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandEndTxnOnPartitionResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnOnPartitionResponse)
  return target;
}

size_t CommandEndTxnOnPartitionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandEndTxnOnPartitionResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandEndTxnOnPartitionResponse*>(
      &from));
}

void CommandEndTxnOnPartitionResponse::MergeFrom(const CommandEndTxnOnPartitionResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnOnPartitionResponse::CopyFrom(const CommandEndTxnOnPartitionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandEndTxnOnPartitionResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandEndTxnOnPartitionResponse::InternalSwap(CommandEndTxnOnPartitionResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, error_)
      + sizeof(CommandEndTxnOnPartitionResponse::error_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandEndTxnOnPartitionResponse::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnOnPartitionResponse";
}


// ===================================================================

class CommandEndTxnOnSubscription::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnOnSubscription>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pulsar::proto::Subscription& subscription(const CommandEndTxnOnSubscription* msg);
  static void set_has_subscription(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txn_action(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_txnid_least_bits_of_low_watermark(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::pulsar::proto::Subscription&
CommandEndTxnOnSubscription::_Internal::subscription(const CommandEndTxnOnSubscription* msg) {
  return *msg->subscription_;
}
CommandEndTxnOnSubscription::CommandEndTxnOnSubscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnOnSubscription)
}
CommandEndTxnOnSubscription::CommandEndTxnOnSubscription(const CommandEndTxnOnSubscription& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_subscription()) {
    subscription_ = new ::pulsar::proto::Subscription(*from.subscription_);
  } else {
    subscription_ = nullptr;
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&txn_action_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(txn_action_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnOnSubscription)
}

inline void CommandEndTxnOnSubscription::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&subscription_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&txn_action_) -
    reinterpret_cast<char*>(&subscription_)) + sizeof(txn_action_));
}

CommandEndTxnOnSubscription::~CommandEndTxnOnSubscription() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnOnSubscription)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandEndTxnOnSubscription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete subscription_;
}

void CommandEndTxnOnSubscription::ArenaDtor(void* object) {
  CommandEndTxnOnSubscription* _this = reinterpret_cast< CommandEndTxnOnSubscription* >(object);
  (void)_this;
}
void CommandEndTxnOnSubscription::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandEndTxnOnSubscription::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandEndTxnOnSubscription::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnOnSubscription)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(subscription_ != nullptr);
    subscription_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&txn_action_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(txn_action_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnOnSubscription::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.Subscription subscription = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscription(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.TxnAction txn_action = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::TxnAction_IsValid(val))) {
            _internal_set_txn_action(static_cast<::pulsar::proto::TxnAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits_of_low_watermark = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_txnid_least_bits_of_low_watermark(&has_bits);
          txnid_least_bits_of_low_watermark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandEndTxnOnSubscription::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnOnSubscription)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.Subscription subscription = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::subscription(this), target, stream);
  }

  // optional .pulsar.proto.TxnAction txn_action = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_txn_action(), target);
  }

  // optional uint64 txnid_least_bits_of_low_watermark = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_txnid_least_bits_of_low_watermark(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnOnSubscription)
  return target;
}

size_t CommandEndTxnOnSubscription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnOnSubscription)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.Subscription subscription = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *subscription_);
  }

  if (cached_has_bits & 0x0000003cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 txnid_least_bits_of_low_watermark = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits_of_low_watermark());
    }

    // optional .pulsar.proto.TxnAction txn_action = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_txn_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandEndTxnOnSubscription::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandEndTxnOnSubscription*>(
      &from));
}

void CommandEndTxnOnSubscription::MergeFrom(const CommandEndTxnOnSubscription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnOnSubscription)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_subscription()->::pulsar::proto::Subscription::MergeFrom(from._internal_subscription());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      txnid_least_bits_of_low_watermark_ = from.txnid_least_bits_of_low_watermark_;
    }
    if (cached_has_bits & 0x00000020u) {
      txn_action_ = from.txn_action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnOnSubscription::CopyFrom(const CommandEndTxnOnSubscription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnOnSubscription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandEndTxnOnSubscription::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_subscription()) {
    if (!subscription_->IsInitialized()) return false;
  }
  return true;
}

void CommandEndTxnOnSubscription::InternalSwap(CommandEndTxnOnSubscription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, txn_action_)
      + sizeof(CommandEndTxnOnSubscription::txn_action_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, subscription_)>(
          reinterpret_cast<char*>(&subscription_),
          reinterpret_cast<char*>(&other->subscription_));
}

std::string CommandEndTxnOnSubscription::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnOnSubscription";
}


// ===================================================================

class CommandEndTxnOnSubscriptionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnOnSubscriptionResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandEndTxnOnSubscriptionResponse::CommandEndTxnOnSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
}
CommandEndTxnOnSubscriptionResponse::CommandEndTxnOnSubscriptionResponse(const CommandEndTxnOnSubscriptionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
}

inline void CommandEndTxnOnSubscriptionResponse::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
}

CommandEndTxnOnSubscriptionResponse::~CommandEndTxnOnSubscriptionResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CommandEndTxnOnSubscriptionResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandEndTxnOnSubscriptionResponse::ArenaDtor(void* object) {
  CommandEndTxnOnSubscriptionResponse* _this = reinterpret_cast< CommandEndTxnOnSubscriptionResponse* >(object);
  (void)_this;
}
void CommandEndTxnOnSubscriptionResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandEndTxnOnSubscriptionResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandEndTxnOnSubscriptionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnOnSubscriptionResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_least_bits = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txnid_least_bits(&has_bits);
          txnid_least_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 txnid_most_bits = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txnid_most_bits(&has_bits);
          txnid_most_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.ServerError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::ServerError_IsValid(val))) {
            _internal_set_error(static_cast<::pulsar::proto::ServerError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CommandEndTxnOnSubscriptionResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  return target;
}

size_t CommandEndTxnOnSubscriptionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  size_t total_size = 0;

  // required uint64 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_request_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommandEndTxnOnSubscriptionResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CommandEndTxnOnSubscriptionResponse*>(
      &from));
}

void CommandEndTxnOnSubscriptionResponse::MergeFrom(const CommandEndTxnOnSubscriptionResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      txnid_least_bits_ = from.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      txnid_most_bits_ = from.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnOnSubscriptionResponse::CopyFrom(const CommandEndTxnOnSubscriptionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandEndTxnOnSubscriptionResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommandEndTxnOnSubscriptionResponse::InternalSwap(CommandEndTxnOnSubscriptionResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, GetArenaForAllocation(),
      &other->message_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, error_)
      + sizeof(CommandEndTxnOnSubscriptionResponse::error_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

std::string CommandEndTxnOnSubscriptionResponse::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnOnSubscriptionResponse";
}


// ===================================================================

class BaseCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<BaseCommand>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static const ::pulsar::proto::CommandConnect& connect(const BaseCommand* msg);
  static void set_has_connect(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::CommandConnected& connected(const BaseCommand* msg);
  static void set_has_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pulsar::proto::CommandSubscribe& subscribe(const BaseCommand* msg);
  static void set_has_subscribe(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pulsar::proto::CommandProducer& producer(const BaseCommand* msg);
  static void set_has_producer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pulsar::proto::CommandSend& send(const BaseCommand* msg);
  static void set_has_send(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::pulsar::proto::CommandSendReceipt& send_receipt(const BaseCommand* msg);
  static void set_has_send_receipt(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::pulsar::proto::CommandSendError& send_error(const BaseCommand* msg);
  static void set_has_send_error(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::pulsar::proto::CommandMessage& message(const BaseCommand* msg);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::pulsar::proto::CommandAck& ack(const BaseCommand* msg);
  static void set_has_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::pulsar::proto::CommandFlow& flow(const BaseCommand* msg);
  static void set_has_flow(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::pulsar::proto::CommandUnsubscribe& unsubscribe(const BaseCommand* msg);
  static void set_has_unsubscribe(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::pulsar::proto::CommandSuccess& success(const BaseCommand* msg);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::pulsar::proto::CommandError& error(const BaseCommand* msg);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::pulsar::proto::CommandCloseProducer& close_producer(const BaseCommand* msg);
  static void set_has_close_producer(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::pulsar::proto::CommandCloseConsumer& close_consumer(const BaseCommand* msg);
  static void set_has_close_consumer(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::pulsar::proto::CommandProducerSuccess& producer_success(const BaseCommand* msg);
  static void set_has_producer_success(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::pulsar::proto::CommandPing& ping(const BaseCommand* msg);
  static void set_has_ping(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::pulsar::proto::CommandPong& pong(const BaseCommand* msg);
  static void set_has_pong(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& redeliverunacknowledgedmessages(const BaseCommand* msg);
  static void set_has_redeliverunacknowledgedmessages(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::pulsar::proto::CommandPartitionedTopicMetadata& partitionmetadata(const BaseCommand* msg);
  static void set_has_partitionmetadata(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& partitionmetadataresponse(const BaseCommand* msg);
  static void set_has_partitionmetadataresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::pulsar::proto::CommandLookupTopic& lookuptopic(const BaseCommand* msg);
  static void set_has_lookuptopic(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::pulsar::proto::CommandLookupTopicResponse& lookuptopicresponse(const BaseCommand* msg);
  static void set_has_lookuptopicresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::pulsar::proto::CommandConsumerStats& consumerstats(const BaseCommand* msg);
  static void set_has_consumerstats(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::pulsar::proto::CommandConsumerStatsResponse& consumerstatsresponse(const BaseCommand* msg);
  static void set_has_consumerstatsresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::pulsar::proto::CommandReachedEndOfTopic& reachedendoftopic(const BaseCommand* msg);
  static void set_has_reachedendoftopic(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::pulsar::proto::CommandSeek& seek(const BaseCommand* msg);
  static void set_has_seek(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::pulsar::proto::CommandGetLastMessageId& getlastmessageid(const BaseCommand* msg);
  static void set_has_getlastmessageid(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::pulsar::proto::CommandGetLastMessageIdResponse& getlastmessageidresponse(const BaseCommand* msg);
  static void set_has_getlastmessageidresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::pulsar::proto::CommandActiveConsumerChange& active_consumer_change(const BaseCommand* msg);
  static void set_has_active_consumer_change(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::pulsar::proto::CommandGetTopicsOfNamespace& gettopicsofnamespace(const BaseCommand* msg);
  static void set_has_gettopicsofnamespace(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& gettopicsofnamespaceresponse(const BaseCommand* msg);
  static void set_has_gettopicsofnamespaceresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::pulsar::proto::CommandGetSchema& getschema(const BaseCommand* msg);
  static void set_has_getschema(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::pulsar::proto::CommandGetSchemaResponse& getschemaresponse(const BaseCommand* msg);
  static void set_has_getschemaresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static const ::pulsar::proto::CommandAuthChallenge& authchallenge(const BaseCommand* msg);
  static void set_has_authchallenge(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::pulsar::proto::CommandAuthResponse& authresponse(const BaseCommand* msg);
  static void set_has_authresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static const ::pulsar::proto::CommandAckResponse& ackresponse(const BaseCommand* msg);
  static void set_has_ackresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static const ::pulsar::proto::CommandGetOrCreateSchema& getorcreateschema(const BaseCommand* msg);
  static void set_has_getorcreateschema(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static const ::pulsar::proto::CommandGetOrCreateSchemaResponse& getorcreateschemaresponse(const BaseCommand* msg);
  static void set_has_getorcreateschemaresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static const ::pulsar::proto::CommandNewTxn& newtxn(const BaseCommand* msg);
  static void set_has_newtxn(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static const ::pulsar::proto::CommandNewTxnResponse& newtxnresponse(const BaseCommand* msg);
  static void set_has_newtxnresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static const ::pulsar::proto::CommandAddPartitionToTxn& addpartitiontotxn(const BaseCommand* msg);
  static void set_has_addpartitiontotxn(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static const ::pulsar::proto::CommandAddPartitionToTxnResponse& addpartitiontotxnresponse(const BaseCommand* msg);
  static void set_has_addpartitiontotxnresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static const ::pulsar::proto::CommandAddSubscriptionToTxn& addsubscriptiontotxn(const BaseCommand* msg);
  static void set_has_addsubscriptiontotxn(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& addsubscriptiontotxnresponse(const BaseCommand* msg);
  static void set_has_addsubscriptiontotxnresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static const ::pulsar::proto::CommandEndTxn& endtxn(const BaseCommand* msg);
  static void set_has_endtxn(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static const ::pulsar::proto::CommandEndTxnResponse& endtxnresponse(const BaseCommand* msg);
  static void set_has_endtxnresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static const ::pulsar::proto::CommandEndTxnOnPartition& endtxnonpartition(const BaseCommand* msg);
  static void set_has_endtxnonpartition(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static const ::pulsar::proto::CommandEndTxnOnPartitionResponse& endtxnonpartitionresponse(const BaseCommand* msg);
  static void set_has_endtxnonpartitionresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static const ::pulsar::proto::CommandEndTxnOnSubscription& endtxnonsubscription(const BaseCommand* msg);
  static void set_has_endtxnonsubscription(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& endtxnonsubscriptionresponse(const BaseCommand* msg);
  static void set_has_endtxnonsubscriptionresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static const ::pulsar::proto::CommandTcClientConnectRequest& tcclientconnectrequest(const BaseCommand* msg);
  static void set_has_tcclientconnectrequest(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static const ::pulsar::proto::CommandTcClientConnectResponse& tcclientconnectresponse(const BaseCommand* msg);
  static void set_has_tcclientconnectresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static const ::pulsar::proto::CommandWatchTopicList& watchtopiclist(const BaseCommand* msg);
  static void set_has_watchtopiclist(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static const ::pulsar::proto::CommandWatchTopicListSuccess& watchtopiclistsuccess(const BaseCommand* msg);
  static void set_has_watchtopiclistsuccess(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static const ::pulsar::proto::CommandWatchTopicUpdate& watchtopicupdate(const BaseCommand* msg);
  static void set_has_watchtopicupdate(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static const ::pulsar::proto::CommandWatchTopicListClose& watchtopiclistclose(const BaseCommand* msg);
  static void set_has_watchtopiclistclose(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static const ::pulsar::proto::CommandTopicMigrated& topicmigrated(const BaseCommand* msg);
  static void set_has_topicmigrated(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[1] & 0x04000000) ^ 0x04000000) != 0;
  }
};

const ::pulsar::proto::CommandConnect&
BaseCommand::_Internal::connect(const BaseCommand* msg) {
  return *msg->connect_;
}
const ::pulsar::proto::CommandConnected&
BaseCommand::_Internal::connected(const BaseCommand* msg) {
  return *msg->connected_;
}
const ::pulsar::proto::CommandSubscribe&
BaseCommand::_Internal::subscribe(const BaseCommand* msg) {
  return *msg->subscribe_;
}
const ::pulsar::proto::CommandProducer&
BaseCommand::_Internal::producer(const BaseCommand* msg) {
  return *msg->producer_;
}
const ::pulsar::proto::CommandSend&
BaseCommand::_Internal::send(const BaseCommand* msg) {
  return *msg->send_;
}
const ::pulsar::proto::CommandSendReceipt&
BaseCommand::_Internal::send_receipt(const BaseCommand* msg) {
  return *msg->send_receipt_;
}
const ::pulsar::proto::CommandSendError&
BaseCommand::_Internal::send_error(const BaseCommand* msg) {
  return *msg->send_error_;
}
const ::pulsar::proto::CommandMessage&
BaseCommand::_Internal::message(const BaseCommand* msg) {
  return *msg->message_;
}
const ::pulsar::proto::CommandAck&
BaseCommand::_Internal::ack(const BaseCommand* msg) {
  return *msg->ack_;
}
const ::pulsar::proto::CommandFlow&
BaseCommand::_Internal::flow(const BaseCommand* msg) {
  return *msg->flow_;
}
const ::pulsar::proto::CommandUnsubscribe&
BaseCommand::_Internal::unsubscribe(const BaseCommand* msg) {
  return *msg->unsubscribe_;
}
const ::pulsar::proto::CommandSuccess&
BaseCommand::_Internal::success(const BaseCommand* msg) {
  return *msg->success_;
}
const ::pulsar::proto::CommandError&
BaseCommand::_Internal::error(const BaseCommand* msg) {
  return *msg->error_;
}
const ::pulsar::proto::CommandCloseProducer&
BaseCommand::_Internal::close_producer(const BaseCommand* msg) {
  return *msg->close_producer_;
}
const ::pulsar::proto::CommandCloseConsumer&
BaseCommand::_Internal::close_consumer(const BaseCommand* msg) {
  return *msg->close_consumer_;
}
const ::pulsar::proto::CommandProducerSuccess&
BaseCommand::_Internal::producer_success(const BaseCommand* msg) {
  return *msg->producer_success_;
}
const ::pulsar::proto::CommandPing&
BaseCommand::_Internal::ping(const BaseCommand* msg) {
  return *msg->ping_;
}
const ::pulsar::proto::CommandPong&
BaseCommand::_Internal::pong(const BaseCommand* msg) {
  return *msg->pong_;
}
const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages&
BaseCommand::_Internal::redeliverunacknowledgedmessages(const BaseCommand* msg) {
  return *msg->redeliverunacknowledgedmessages_;
}
const ::pulsar::proto::CommandPartitionedTopicMetadata&
BaseCommand::_Internal::partitionmetadata(const BaseCommand* msg) {
  return *msg->partitionmetadata_;
}
const ::pulsar::proto::CommandPartitionedTopicMetadataResponse&
BaseCommand::_Internal::partitionmetadataresponse(const BaseCommand* msg) {
  return *msg->partitionmetadataresponse_;
}
const ::pulsar::proto::CommandLookupTopic&
BaseCommand::_Internal::lookuptopic(const BaseCommand* msg) {
  return *msg->lookuptopic_;
}
const ::pulsar::proto::CommandLookupTopicResponse&
BaseCommand::_Internal::lookuptopicresponse(const BaseCommand* msg) {
  return *msg->lookuptopicresponse_;
}
const ::pulsar::proto::CommandConsumerStats&
BaseCommand::_Internal::consumerstats(const BaseCommand* msg) {
  return *msg->consumerstats_;
}
const ::pulsar::proto::CommandConsumerStatsResponse&
BaseCommand::_Internal::consumerstatsresponse(const BaseCommand* msg) {
  return *msg->consumerstatsresponse_;
}
const ::pulsar::proto::CommandReachedEndOfTopic&
BaseCommand::_Internal::reachedendoftopic(const BaseCommand* msg) {
  return *msg->reachedendoftopic_;
}
const ::pulsar::proto::CommandSeek&
BaseCommand::_Internal::seek(const BaseCommand* msg) {
  return *msg->seek_;
}
const ::pulsar::proto::CommandGetLastMessageId&
BaseCommand::_Internal::getlastmessageid(const BaseCommand* msg) {
  return *msg->getlastmessageid_;
}
const ::pulsar::proto::CommandGetLastMessageIdResponse&
BaseCommand::_Internal::getlastmessageidresponse(const BaseCommand* msg) {
  return *msg->getlastmessageidresponse_;
}
const ::pulsar::proto::CommandActiveConsumerChange&
BaseCommand::_Internal::active_consumer_change(const BaseCommand* msg) {
  return *msg->active_consumer_change_;
}
const ::pulsar::proto::CommandGetTopicsOfNamespace&
BaseCommand::_Internal::gettopicsofnamespace(const BaseCommand* msg) {
  return *msg->gettopicsofnamespace_;
}
const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse&
BaseCommand::_Internal::gettopicsofnamespaceresponse(const BaseCommand* msg) {
  return *msg->gettopicsofnamespaceresponse_;
}
const ::pulsar::proto::CommandGetSchema&
BaseCommand::_Internal::getschema(const BaseCommand* msg) {
  return *msg->getschema_;
}
const ::pulsar::proto::CommandGetSchemaResponse&
BaseCommand::_Internal::getschemaresponse(const BaseCommand* msg) {
  return *msg->getschemaresponse_;
}
const ::pulsar::proto::CommandAuthChallenge&
BaseCommand::_Internal::authchallenge(const BaseCommand* msg) {
  return *msg->authchallenge_;
}
const ::pulsar::proto::CommandAuthResponse&
BaseCommand::_Internal::authresponse(const BaseCommand* msg) {
  return *msg->authresponse_;
}
const ::pulsar::proto::CommandAckResponse&
BaseCommand::_Internal::ackresponse(const BaseCommand* msg) {
  return *msg->ackresponse_;
}
const ::pulsar::proto::CommandGetOrCreateSchema&
BaseCommand::_Internal::getorcreateschema(const BaseCommand* msg) {
  return *msg->getorcreateschema_;
}
const ::pulsar::proto::CommandGetOrCreateSchemaResponse&
BaseCommand::_Internal::getorcreateschemaresponse(const BaseCommand* msg) {
  return *msg->getorcreateschemaresponse_;
}
const ::pulsar::proto::CommandNewTxn&
BaseCommand::_Internal::newtxn(const BaseCommand* msg) {
  return *msg->newtxn_;
}
const ::pulsar::proto::CommandNewTxnResponse&
BaseCommand::_Internal::newtxnresponse(const BaseCommand* msg) {
  return *msg->newtxnresponse_;
}
const ::pulsar::proto::CommandAddPartitionToTxn&
BaseCommand::_Internal::addpartitiontotxn(const BaseCommand* msg) {
  return *msg->addpartitiontotxn_;
}
const ::pulsar::proto::CommandAddPartitionToTxnResponse&
BaseCommand::_Internal::addpartitiontotxnresponse(const BaseCommand* msg) {
  return *msg->addpartitiontotxnresponse_;
}
const ::pulsar::proto::CommandAddSubscriptionToTxn&
BaseCommand::_Internal::addsubscriptiontotxn(const BaseCommand* msg) {
  return *msg->addsubscriptiontotxn_;
}
const ::pulsar::proto::CommandAddSubscriptionToTxnResponse&
BaseCommand::_Internal::addsubscriptiontotxnresponse(const BaseCommand* msg) {
  return *msg->addsubscriptiontotxnresponse_;
}
const ::pulsar::proto::CommandEndTxn&
BaseCommand::_Internal::endtxn(const BaseCommand* msg) {
  return *msg->endtxn_;
}
const ::pulsar::proto::CommandEndTxnResponse&
BaseCommand::_Internal::endtxnresponse(const BaseCommand* msg) {
  return *msg->endtxnresponse_;
}
const ::pulsar::proto::CommandEndTxnOnPartition&
BaseCommand::_Internal::endtxnonpartition(const BaseCommand* msg) {
  return *msg->endtxnonpartition_;
}
const ::pulsar::proto::CommandEndTxnOnPartitionResponse&
BaseCommand::_Internal::endtxnonpartitionresponse(const BaseCommand* msg) {
  return *msg->endtxnonpartitionresponse_;
}
const ::pulsar::proto::CommandEndTxnOnSubscription&
BaseCommand::_Internal::endtxnonsubscription(const BaseCommand* msg) {
  return *msg->endtxnonsubscription_;
}
const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse&
BaseCommand::_Internal::endtxnonsubscriptionresponse(const BaseCommand* msg) {
  return *msg->endtxnonsubscriptionresponse_;
}
const ::pulsar::proto::CommandTcClientConnectRequest&
BaseCommand::_Internal::tcclientconnectrequest(const BaseCommand* msg) {
  return *msg->tcclientconnectrequest_;
}
const ::pulsar::proto::CommandTcClientConnectResponse&
BaseCommand::_Internal::tcclientconnectresponse(const BaseCommand* msg) {
  return *msg->tcclientconnectresponse_;
}
const ::pulsar::proto::CommandWatchTopicList&
BaseCommand::_Internal::watchtopiclist(const BaseCommand* msg) {
  return *msg->watchtopiclist_;
}
const ::pulsar::proto::CommandWatchTopicListSuccess&
BaseCommand::_Internal::watchtopiclistsuccess(const BaseCommand* msg) {
  return *msg->watchtopiclistsuccess_;
}
const ::pulsar::proto::CommandWatchTopicUpdate&
BaseCommand::_Internal::watchtopicupdate(const BaseCommand* msg) {
  return *msg->watchtopicupdate_;
}
const ::pulsar::proto::CommandWatchTopicListClose&
BaseCommand::_Internal::watchtopiclistclose(const BaseCommand* msg) {
  return *msg->watchtopiclistclose_;
}
const ::pulsar::proto::CommandTopicMigrated&
BaseCommand::_Internal::topicmigrated(const BaseCommand* msg) {
  return *msg->topicmigrated_;
}
BaseCommand::BaseCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.BaseCommand)
}
BaseCommand::BaseCommand(const BaseCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_connect()) {
    connect_ = new ::pulsar::proto::CommandConnect(*from.connect_);
  } else {
    connect_ = nullptr;
  }
  if (from._internal_has_connected()) {
    connected_ = new ::pulsar::proto::CommandConnected(*from.connected_);
  } else {
    connected_ = nullptr;
  }
  if (from._internal_has_subscribe()) {
    subscribe_ = new ::pulsar::proto::CommandSubscribe(*from.subscribe_);
  } else {
    subscribe_ = nullptr;
  }
  if (from._internal_has_producer()) {
    producer_ = new ::pulsar::proto::CommandProducer(*from.producer_);
  } else {
    producer_ = nullptr;
  }
  if (from._internal_has_send()) {
    send_ = new ::pulsar::proto::CommandSend(*from.send_);
  } else {
    send_ = nullptr;
  }
  if (from._internal_has_send_receipt()) {
    send_receipt_ = new ::pulsar::proto::CommandSendReceipt(*from.send_receipt_);
  } else {
    send_receipt_ = nullptr;
  }
  if (from._internal_has_send_error()) {
    send_error_ = new ::pulsar::proto::CommandSendError(*from.send_error_);
  } else {
    send_error_ = nullptr;
  }
  if (from._internal_has_message()) {
    message_ = new ::pulsar::proto::CommandMessage(*from.message_);
  } else {
    message_ = nullptr;
  }
  if (from._internal_has_ack()) {
    ack_ = new ::pulsar::proto::CommandAck(*from.ack_);
  } else {
    ack_ = nullptr;
  }
  if (from._internal_has_flow()) {
    flow_ = new ::pulsar::proto::CommandFlow(*from.flow_);
  } else {
    flow_ = nullptr;
  }
  if (from._internal_has_unsubscribe()) {
    unsubscribe_ = new ::pulsar::proto::CommandUnsubscribe(*from.unsubscribe_);
  } else {
    unsubscribe_ = nullptr;
  }
  if (from._internal_has_success()) {
    success_ = new ::pulsar::proto::CommandSuccess(*from.success_);
  } else {
    success_ = nullptr;
  }
  if (from._internal_has_error()) {
    error_ = new ::pulsar::proto::CommandError(*from.error_);
  } else {
    error_ = nullptr;
  }
  if (from._internal_has_close_producer()) {
    close_producer_ = new ::pulsar::proto::CommandCloseProducer(*from.close_producer_);
  } else {
    close_producer_ = nullptr;
  }
  if (from._internal_has_close_consumer()) {
    close_consumer_ = new ::pulsar::proto::CommandCloseConsumer(*from.close_consumer_);
  } else {
    close_consumer_ = nullptr;
  }
  if (from._internal_has_producer_success()) {
    producer_success_ = new ::pulsar::proto::CommandProducerSuccess(*from.producer_success_);
  } else {
    producer_success_ = nullptr;
  }
  if (from._internal_has_ping()) {
    ping_ = new ::pulsar::proto::CommandPing(*from.ping_);
  } else {
    ping_ = nullptr;
  }
  if (from._internal_has_pong()) {
    pong_ = new ::pulsar::proto::CommandPong(*from.pong_);
  } else {
    pong_ = nullptr;
  }
  if (from._internal_has_redeliverunacknowledgedmessages()) {
    redeliverunacknowledgedmessages_ = new ::pulsar::proto::CommandRedeliverUnacknowledgedMessages(*from.redeliverunacknowledgedmessages_);
  } else {
    redeliverunacknowledgedmessages_ = nullptr;
  }
  if (from._internal_has_partitionmetadata()) {
    partitionmetadata_ = new ::pulsar::proto::CommandPartitionedTopicMetadata(*from.partitionmetadata_);
  } else {
    partitionmetadata_ = nullptr;
  }
  if (from._internal_has_partitionmetadataresponse()) {
    partitionmetadataresponse_ = new ::pulsar::proto::CommandPartitionedTopicMetadataResponse(*from.partitionmetadataresponse_);
  } else {
    partitionmetadataresponse_ = nullptr;
  }
  if (from._internal_has_lookuptopic()) {
    lookuptopic_ = new ::pulsar::proto::CommandLookupTopic(*from.lookuptopic_);
  } else {
    lookuptopic_ = nullptr;
  }
  if (from._internal_has_lookuptopicresponse()) {
    lookuptopicresponse_ = new ::pulsar::proto::CommandLookupTopicResponse(*from.lookuptopicresponse_);
  } else {
    lookuptopicresponse_ = nullptr;
  }
  if (from._internal_has_consumerstats()) {
    consumerstats_ = new ::pulsar::proto::CommandConsumerStats(*from.consumerstats_);
  } else {
    consumerstats_ = nullptr;
  }
  if (from._internal_has_consumerstatsresponse()) {
    consumerstatsresponse_ = new ::pulsar::proto::CommandConsumerStatsResponse(*from.consumerstatsresponse_);
  } else {
    consumerstatsresponse_ = nullptr;
  }
  if (from._internal_has_reachedendoftopic()) {
    reachedendoftopic_ = new ::pulsar::proto::CommandReachedEndOfTopic(*from.reachedendoftopic_);
  } else {
    reachedendoftopic_ = nullptr;
  }
  if (from._internal_has_seek()) {
    seek_ = new ::pulsar::proto::CommandSeek(*from.seek_);
  } else {
    seek_ = nullptr;
  }
  if (from._internal_has_getlastmessageid()) {
    getlastmessageid_ = new ::pulsar::proto::CommandGetLastMessageId(*from.getlastmessageid_);
  } else {
    getlastmessageid_ = nullptr;
  }
  if (from._internal_has_getlastmessageidresponse()) {
    getlastmessageidresponse_ = new ::pulsar::proto::CommandGetLastMessageIdResponse(*from.getlastmessageidresponse_);
  } else {
    getlastmessageidresponse_ = nullptr;
  }
  if (from._internal_has_active_consumer_change()) {
    active_consumer_change_ = new ::pulsar::proto::CommandActiveConsumerChange(*from.active_consumer_change_);
  } else {
    active_consumer_change_ = nullptr;
  }
  if (from._internal_has_gettopicsofnamespace()) {
    gettopicsofnamespace_ = new ::pulsar::proto::CommandGetTopicsOfNamespace(*from.gettopicsofnamespace_);
  } else {
    gettopicsofnamespace_ = nullptr;
  }
  if (from._internal_has_gettopicsofnamespaceresponse()) {
    gettopicsofnamespaceresponse_ = new ::pulsar::proto::CommandGetTopicsOfNamespaceResponse(*from.gettopicsofnamespaceresponse_);
  } else {
    gettopicsofnamespaceresponse_ = nullptr;
  }
  if (from._internal_has_getschema()) {
    getschema_ = new ::pulsar::proto::CommandGetSchema(*from.getschema_);
  } else {
    getschema_ = nullptr;
  }
  if (from._internal_has_getschemaresponse()) {
    getschemaresponse_ = new ::pulsar::proto::CommandGetSchemaResponse(*from.getschemaresponse_);
  } else {
    getschemaresponse_ = nullptr;
  }
  if (from._internal_has_authchallenge()) {
    authchallenge_ = new ::pulsar::proto::CommandAuthChallenge(*from.authchallenge_);
  } else {
    authchallenge_ = nullptr;
  }
  if (from._internal_has_authresponse()) {
    authresponse_ = new ::pulsar::proto::CommandAuthResponse(*from.authresponse_);
  } else {
    authresponse_ = nullptr;
  }
  if (from._internal_has_ackresponse()) {
    ackresponse_ = new ::pulsar::proto::CommandAckResponse(*from.ackresponse_);
  } else {
    ackresponse_ = nullptr;
  }
  if (from._internal_has_getorcreateschema()) {
    getorcreateschema_ = new ::pulsar::proto::CommandGetOrCreateSchema(*from.getorcreateschema_);
  } else {
    getorcreateschema_ = nullptr;
  }
  if (from._internal_has_getorcreateschemaresponse()) {
    getorcreateschemaresponse_ = new ::pulsar::proto::CommandGetOrCreateSchemaResponse(*from.getorcreateschemaresponse_);
  } else {
    getorcreateschemaresponse_ = nullptr;
  }
  if (from._internal_has_newtxn()) {
    newtxn_ = new ::pulsar::proto::CommandNewTxn(*from.newtxn_);
  } else {
    newtxn_ = nullptr;
  }
  if (from._internal_has_newtxnresponse()) {
    newtxnresponse_ = new ::pulsar::proto::CommandNewTxnResponse(*from.newtxnresponse_);
  } else {
    newtxnresponse_ = nullptr;
  }
  if (from._internal_has_addpartitiontotxn()) {
    addpartitiontotxn_ = new ::pulsar::proto::CommandAddPartitionToTxn(*from.addpartitiontotxn_);
  } else {
    addpartitiontotxn_ = nullptr;
  }
  if (from._internal_has_addpartitiontotxnresponse()) {
    addpartitiontotxnresponse_ = new ::pulsar::proto::CommandAddPartitionToTxnResponse(*from.addpartitiontotxnresponse_);
  } else {
    addpartitiontotxnresponse_ = nullptr;
  }
  if (from._internal_has_addsubscriptiontotxn()) {
    addsubscriptiontotxn_ = new ::pulsar::proto::CommandAddSubscriptionToTxn(*from.addsubscriptiontotxn_);
  } else {
    addsubscriptiontotxn_ = nullptr;
  }
  if (from._internal_has_addsubscriptiontotxnresponse()) {
    addsubscriptiontotxnresponse_ = new ::pulsar::proto::CommandAddSubscriptionToTxnResponse(*from.addsubscriptiontotxnresponse_);
  } else {
    addsubscriptiontotxnresponse_ = nullptr;
  }
  if (from._internal_has_endtxn()) {
    endtxn_ = new ::pulsar::proto::CommandEndTxn(*from.endtxn_);
  } else {
    endtxn_ = nullptr;
  }
  if (from._internal_has_endtxnresponse()) {
    endtxnresponse_ = new ::pulsar::proto::CommandEndTxnResponse(*from.endtxnresponse_);
  } else {
    endtxnresponse_ = nullptr;
  }
  if (from._internal_has_endtxnonpartition()) {
    endtxnonpartition_ = new ::pulsar::proto::CommandEndTxnOnPartition(*from.endtxnonpartition_);
  } else {
    endtxnonpartition_ = nullptr;
  }
  if (from._internal_has_endtxnonpartitionresponse()) {
    endtxnonpartitionresponse_ = new ::pulsar::proto::CommandEndTxnOnPartitionResponse(*from.endtxnonpartitionresponse_);
  } else {
    endtxnonpartitionresponse_ = nullptr;
  }
  if (from._internal_has_endtxnonsubscription()) {
    endtxnonsubscription_ = new ::pulsar::proto::CommandEndTxnOnSubscription(*from.endtxnonsubscription_);
  } else {
    endtxnonsubscription_ = nullptr;
  }
  if (from._internal_has_endtxnonsubscriptionresponse()) {
    endtxnonsubscriptionresponse_ = new ::pulsar::proto::CommandEndTxnOnSubscriptionResponse(*from.endtxnonsubscriptionresponse_);
  } else {
    endtxnonsubscriptionresponse_ = nullptr;
  }
  if (from._internal_has_tcclientconnectrequest()) {
    tcclientconnectrequest_ = new ::pulsar::proto::CommandTcClientConnectRequest(*from.tcclientconnectrequest_);
  } else {
    tcclientconnectrequest_ = nullptr;
  }
  if (from._internal_has_tcclientconnectresponse()) {
    tcclientconnectresponse_ = new ::pulsar::proto::CommandTcClientConnectResponse(*from.tcclientconnectresponse_);
  } else {
    tcclientconnectresponse_ = nullptr;
  }
  if (from._internal_has_watchtopiclist()) {
    watchtopiclist_ = new ::pulsar::proto::CommandWatchTopicList(*from.watchtopiclist_);
  } else {
    watchtopiclist_ = nullptr;
  }
  if (from._internal_has_watchtopiclistsuccess()) {
    watchtopiclistsuccess_ = new ::pulsar::proto::CommandWatchTopicListSuccess(*from.watchtopiclistsuccess_);
  } else {
    watchtopiclistsuccess_ = nullptr;
  }
  if (from._internal_has_watchtopicupdate()) {
    watchtopicupdate_ = new ::pulsar::proto::CommandWatchTopicUpdate(*from.watchtopicupdate_);
  } else {
    watchtopicupdate_ = nullptr;
  }
  if (from._internal_has_watchtopiclistclose()) {
    watchtopiclistclose_ = new ::pulsar::proto::CommandWatchTopicListClose(*from.watchtopiclistclose_);
  } else {
    watchtopiclistclose_ = nullptr;
  }
  if (from._internal_has_topicmigrated()) {
    topicmigrated_ = new ::pulsar::proto::CommandTopicMigrated(*from.topicmigrated_);
  } else {
    topicmigrated_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:pulsar.proto.BaseCommand)
}

inline void BaseCommand::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&connect_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&topicmigrated_) -
    reinterpret_cast<char*>(&connect_)) + sizeof(topicmigrated_));
type_ = 2;
}

BaseCommand::~BaseCommand() {
  // @@protoc_insertion_point(destructor:pulsar.proto.BaseCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void BaseCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete connect_;
  if (this != internal_default_instance()) delete connected_;
  if (this != internal_default_instance()) delete subscribe_;
  if (this != internal_default_instance()) delete producer_;
  if (this != internal_default_instance()) delete send_;
  if (this != internal_default_instance()) delete send_receipt_;
  if (this != internal_default_instance()) delete send_error_;
  if (this != internal_default_instance()) delete message_;
  if (this != internal_default_instance()) delete ack_;
  if (this != internal_default_instance()) delete flow_;
  if (this != internal_default_instance()) delete unsubscribe_;
  if (this != internal_default_instance()) delete success_;
  if (this != internal_default_instance()) delete error_;
  if (this != internal_default_instance()) delete close_producer_;
  if (this != internal_default_instance()) delete close_consumer_;
  if (this != internal_default_instance()) delete producer_success_;
  if (this != internal_default_instance()) delete ping_;
  if (this != internal_default_instance()) delete pong_;
  if (this != internal_default_instance()) delete redeliverunacknowledgedmessages_;
  if (this != internal_default_instance()) delete partitionmetadata_;
  if (this != internal_default_instance()) delete partitionmetadataresponse_;
  if (this != internal_default_instance()) delete lookuptopic_;
  if (this != internal_default_instance()) delete lookuptopicresponse_;
  if (this != internal_default_instance()) delete consumerstats_;
  if (this != internal_default_instance()) delete consumerstatsresponse_;
  if (this != internal_default_instance()) delete reachedendoftopic_;
  if (this != internal_default_instance()) delete seek_;
  if (this != internal_default_instance()) delete getlastmessageid_;
  if (this != internal_default_instance()) delete getlastmessageidresponse_;
  if (this != internal_default_instance()) delete active_consumer_change_;
  if (this != internal_default_instance()) delete gettopicsofnamespace_;
  if (this != internal_default_instance()) delete gettopicsofnamespaceresponse_;
  if (this != internal_default_instance()) delete getschema_;
  if (this != internal_default_instance()) delete getschemaresponse_;
  if (this != internal_default_instance()) delete authchallenge_;
  if (this != internal_default_instance()) delete authresponse_;
  if (this != internal_default_instance()) delete ackresponse_;
  if (this != internal_default_instance()) delete getorcreateschema_;
  if (this != internal_default_instance()) delete getorcreateschemaresponse_;
  if (this != internal_default_instance()) delete newtxn_;
  if (this != internal_default_instance()) delete newtxnresponse_;
  if (this != internal_default_instance()) delete addpartitiontotxn_;
  if (this != internal_default_instance()) delete addpartitiontotxnresponse_;
  if (this != internal_default_instance()) delete addsubscriptiontotxn_;
  if (this != internal_default_instance()) delete addsubscriptiontotxnresponse_;
  if (this != internal_default_instance()) delete endtxn_;
  if (this != internal_default_instance()) delete endtxnresponse_;
  if (this != internal_default_instance()) delete endtxnonpartition_;
  if (this != internal_default_instance()) delete endtxnonpartitionresponse_;
  if (this != internal_default_instance()) delete endtxnonsubscription_;
  if (this != internal_default_instance()) delete endtxnonsubscriptionresponse_;
  if (this != internal_default_instance()) delete tcclientconnectrequest_;
  if (this != internal_default_instance()) delete tcclientconnectresponse_;
  if (this != internal_default_instance()) delete watchtopiclist_;
  if (this != internal_default_instance()) delete watchtopiclistsuccess_;
  if (this != internal_default_instance()) delete watchtopicupdate_;
  if (this != internal_default_instance()) delete watchtopiclistclose_;
  if (this != internal_default_instance()) delete topicmigrated_;
}

void BaseCommand::ArenaDtor(void* object) {
  BaseCommand* _this = reinterpret_cast< BaseCommand* >(object);
  (void)_this;
}
void BaseCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BaseCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BaseCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.BaseCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(connect_ != nullptr);
      connect_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(connected_ != nullptr);
      connected_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(subscribe_ != nullptr);
      subscribe_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(producer_ != nullptr);
      producer_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(send_ != nullptr);
      send_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(send_receipt_ != nullptr);
      send_receipt_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(send_error_ != nullptr);
      send_error_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(message_ != nullptr);
      message_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(ack_ != nullptr);
      ack_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(flow_ != nullptr);
      flow_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(unsubscribe_ != nullptr);
      unsubscribe_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(success_ != nullptr);
      success_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(error_ != nullptr);
      error_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(close_producer_ != nullptr);
      close_producer_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(close_consumer_ != nullptr);
      close_consumer_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(producer_success_ != nullptr);
      producer_success_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(ping_ != nullptr);
      ping_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(pong_ != nullptr);
      pong_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(redeliverunacknowledgedmessages_ != nullptr);
      redeliverunacknowledgedmessages_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(partitionmetadata_ != nullptr);
      partitionmetadata_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(partitionmetadataresponse_ != nullptr);
      partitionmetadataresponse_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(lookuptopic_ != nullptr);
      lookuptopic_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(lookuptopicresponse_ != nullptr);
      lookuptopicresponse_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(consumerstats_ != nullptr);
      consumerstats_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(consumerstatsresponse_ != nullptr);
      consumerstatsresponse_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(reachedendoftopic_ != nullptr);
      reachedendoftopic_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(seek_ != nullptr);
      seek_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(getlastmessageid_ != nullptr);
      getlastmessageid_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(getlastmessageidresponse_ != nullptr);
      getlastmessageidresponse_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(active_consumer_change_ != nullptr);
      active_consumer_change_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(gettopicsofnamespace_ != nullptr);
      gettopicsofnamespace_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(gettopicsofnamespaceresponse_ != nullptr);
      gettopicsofnamespaceresponse_->Clear();
    }
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(getschema_ != nullptr);
      getschema_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(getschemaresponse_ != nullptr);
      getschemaresponse_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(authchallenge_ != nullptr);
      authchallenge_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(authresponse_ != nullptr);
      authresponse_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(ackresponse_ != nullptr);
      ackresponse_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(getorcreateschema_ != nullptr);
      getorcreateschema_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(getorcreateschemaresponse_ != nullptr);
      getorcreateschemaresponse_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(newtxn_ != nullptr);
      newtxn_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(newtxnresponse_ != nullptr);
      newtxnresponse_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(addpartitiontotxn_ != nullptr);
      addpartitiontotxn_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(addpartitiontotxnresponse_ != nullptr);
      addpartitiontotxnresponse_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(addsubscriptiontotxn_ != nullptr);
      addsubscriptiontotxn_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(addsubscriptiontotxnresponse_ != nullptr);
      addsubscriptiontotxnresponse_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(endtxn_ != nullptr);
      endtxn_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(endtxnresponse_ != nullptr);
      endtxnresponse_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(endtxnonpartition_ != nullptr);
      endtxnonpartition_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(endtxnonpartitionresponse_ != nullptr);
      endtxnonpartitionresponse_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(endtxnonsubscription_ != nullptr);
      endtxnonsubscription_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(endtxnonsubscriptionresponse_ != nullptr);
      endtxnonsubscriptionresponse_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(tcclientconnectrequest_ != nullptr);
      tcclientconnectrequest_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(tcclientconnectresponse_ != nullptr);
      tcclientconnectresponse_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(watchtopiclist_ != nullptr);
      watchtopiclist_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(watchtopiclistsuccess_ != nullptr);
      watchtopiclistsuccess_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(watchtopicupdate_ != nullptr);
      watchtopicupdate_->Clear();
    }
  }
  if (cached_has_bits & 0x07000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(watchtopiclistclose_ != nullptr);
      watchtopiclistclose_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(topicmigrated_ != nullptr);
      topicmigrated_->Clear();
    }
    type_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BaseCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .pulsar.proto.BaseCommand.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pulsar::proto::BaseCommand_Type_IsValid(val))) {
            _internal_set_type(static_cast<::pulsar::proto::BaseCommand_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandConnect connect = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connect(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandConnected connected = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_connected(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandSubscribe subscribe = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscribe(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandProducer producer = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_producer(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandSend send = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_send(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_send_receipt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandSendError send_error = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_send_error(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandMessage message = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_message(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandAck ack = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_ack(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandFlow flow = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_unsubscribe(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandSuccess success = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_success(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandError error = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_close_producer(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_close_consumer(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_producer_success(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandPing ping = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_ping(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandPong pong = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_pong(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_redeliverunacknowledgedmessages(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_partitionmetadata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_partitionmetadataresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_lookuptopic(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_lookuptopicresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_consumerstats(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_consumerstatsresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_reachedendoftopic(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandSeek seek = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_seek(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_getlastmessageid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_getlastmessageidresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_active_consumer_change(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_gettopicsofnamespace(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_gettopicsofnamespaceresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandGetSchema getSchema = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_getschema(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_getschemaresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_authchallenge(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandAuthResponse authResponse = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_authresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandAckResponse ackResponse = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_ackresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_getorcreateschema(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_getorcreateschemaresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandNewTxn newTxn = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_newtxn(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_newtxnresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_addpartitiontotxn(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_addpartitiontotxnresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_addsubscriptiontotxn(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_addsubscriptiontotxnresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandEndTxn endTxn = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_endtxn(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_endtxnresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_endtxnonpartition(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_endtxnonpartitionresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_endtxnonsubscription(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_endtxnonsubscriptionresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_tcclientconnectrequest(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_tcclientconnectresponse(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_watchtopiclist(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_watchtopiclistsuccess(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_watchtopicupdate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_watchtopiclistclose(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_topicmigrated(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BaseCommand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.BaseCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[1];
  // required .pulsar.proto.BaseCommand.Type type = 1;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .pulsar.proto.CommandConnect connect = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::connect(this), target, stream);
  }

  // optional .pulsar.proto.CommandConnected connected = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::connected(this), target, stream);
  }

  // optional .pulsar.proto.CommandSubscribe subscribe = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::subscribe(this), target, stream);
  }

  // optional .pulsar.proto.CommandProducer producer = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::producer(this), target, stream);
  }

  // optional .pulsar.proto.CommandSend send = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::send(this), target, stream);
  }

  // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::send_receipt(this), target, stream);
  }

  // optional .pulsar.proto.CommandSendError send_error = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::send_error(this), target, stream);
  }

  // optional .pulsar.proto.CommandMessage message = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::message(this), target, stream);
  }

  // optional .pulsar.proto.CommandAck ack = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::ack(this), target, stream);
  }

  // optional .pulsar.proto.CommandFlow flow = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::flow(this), target, stream);
  }

  // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::unsubscribe(this), target, stream);
  }

  // optional .pulsar.proto.CommandSuccess success = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::success(this), target, stream);
  }

  // optional .pulsar.proto.CommandError error = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::error(this), target, stream);
  }

  // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::close_producer(this), target, stream);
  }

  // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        16, _Internal::close_consumer(this), target, stream);
  }

  // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::producer_success(this), target, stream);
  }

  // optional .pulsar.proto.CommandPing ping = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::ping(this), target, stream);
  }

  // optional .pulsar.proto.CommandPong pong = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::pong(this), target, stream);
  }

  // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::redeliverunacknowledgedmessages(this), target, stream);
  }

  // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::partitionmetadata(this), target, stream);
  }

  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        22, _Internal::partitionmetadataresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::lookuptopic(this), target, stream);
  }

  // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        24, _Internal::lookuptopicresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::consumerstats(this), target, stream);
  }

  // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        26, _Internal::consumerstatsresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        27, _Internal::reachedendoftopic(this), target, stream);
  }

  // optional .pulsar.proto.CommandSeek seek = 28;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        28, _Internal::seek(this), target, stream);
  }

  // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        29, _Internal::getlastmessageid(this), target, stream);
  }

  // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::getlastmessageidresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        31, _Internal::active_consumer_change(this), target, stream);
  }

  // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        32, _Internal::gettopicsofnamespace(this), target, stream);
  }

  // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        33, _Internal::gettopicsofnamespaceresponse(this), target, stream);
  }

  cached_has_bits = _has_bits_[1];
  // optional .pulsar.proto.CommandGetSchema getSchema = 34;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        34, _Internal::getschema(this), target, stream);
  }

  // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        35, _Internal::getschemaresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        36, _Internal::authchallenge(this), target, stream);
  }

  // optional .pulsar.proto.CommandAuthResponse authResponse = 37;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        37, _Internal::authresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandAckResponse ackResponse = 38;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        38, _Internal::ackresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        39, _Internal::getorcreateschema(this), target, stream);
  }

  // optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        40, _Internal::getorcreateschemaresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandNewTxn newTxn = 50;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        50, _Internal::newtxn(this), target, stream);
  }

  // optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        51, _Internal::newtxnresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        52, _Internal::addpartitiontotxn(this), target, stream);
  }

  // optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        53, _Internal::addpartitiontotxnresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        54, _Internal::addsubscriptiontotxn(this), target, stream);
  }

  // optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        55, _Internal::addsubscriptiontotxnresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxn endTxn = 56;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        56, _Internal::endtxn(this), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        57, _Internal::endtxnresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        58, _Internal::endtxnonpartition(this), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        59, _Internal::endtxnonpartitionresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        60, _Internal::endtxnonsubscription(this), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        61, _Internal::endtxnonsubscriptionresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        62, _Internal::tcclientconnectrequest(this), target, stream);
  }

  // optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        63, _Internal::tcclientconnectresponse(this), target, stream);
  }

  // optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        64, _Internal::watchtopiclist(this), target, stream);
  }

  // optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        65, _Internal::watchtopiclistsuccess(this), target, stream);
  }

  // optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        66, _Internal::watchtopicupdate(this), target, stream);
  }

  // optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        67, _Internal::watchtopiclistclose(this), target, stream);
  }

  // optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        68, _Internal::topicmigrated(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.BaseCommand)
  return target;
}

size_t BaseCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.BaseCommand)
  size_t total_size = 0;

  // required .pulsar.proto.BaseCommand.Type type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .pulsar.proto.CommandConnect connect = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *connect_);
    }

    // optional .pulsar.proto.CommandConnected connected = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *connected_);
    }

    // optional .pulsar.proto.CommandSubscribe subscribe = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *subscribe_);
    }

    // optional .pulsar.proto.CommandProducer producer = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *producer_);
    }

    // optional .pulsar.proto.CommandSend send = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *send_);
    }

    // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *send_receipt_);
    }

    // optional .pulsar.proto.CommandSendError send_error = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *send_error_);
    }

    // optional .pulsar.proto.CommandMessage message = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *message_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .pulsar.proto.CommandAck ack = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ack_);
    }

    // optional .pulsar.proto.CommandFlow flow = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *flow_);
    }

    // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *unsubscribe_);
    }

    // optional .pulsar.proto.CommandSuccess success = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *success_);
    }

    // optional .pulsar.proto.CommandError error = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *error_);
    }

    // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *close_producer_);
    }

    // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *close_consumer_);
    }

    // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *producer_success_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .pulsar.proto.CommandPing ping = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ping_);
    }

    // optional .pulsar.proto.CommandPong pong = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pong_);
    }

    // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *redeliverunacknowledgedmessages_);
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *partitionmetadata_);
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *partitionmetadataresponse_);
    }

    // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lookuptopic_);
    }

    // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lookuptopicresponse_);
    }

    // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *consumerstats_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *consumerstatsresponse_);
    }

    // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *reachedendoftopic_);
    }

    // optional .pulsar.proto.CommandSeek seek = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *seek_);
    }

    // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *getlastmessageid_);
    }

    // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *getlastmessageidresponse_);
    }

    // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *active_consumer_change_);
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gettopicsofnamespace_);
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gettopicsofnamespaceresponse_);
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional .pulsar.proto.CommandGetSchema getSchema = 34;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *getschema_);
    }

    // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *getschemaresponse_);
    }

    // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *authchallenge_);
    }

    // optional .pulsar.proto.CommandAuthResponse authResponse = 37;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *authresponse_);
    }

    // optional .pulsar.proto.CommandAckResponse ackResponse = 38;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ackresponse_);
    }

    // optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *getorcreateschema_);
    }

    // optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *getorcreateschemaresponse_);
    }

    // optional .pulsar.proto.CommandNewTxn newTxn = 50;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *newtxn_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *newtxnresponse_);
    }

    // optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *addpartitiontotxn_);
    }

    // optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *addpartitiontotxnresponse_);
    }

    // optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *addsubscriptiontotxn_);
    }

    // optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *addsubscriptiontotxnresponse_);
    }

    // optional .pulsar.proto.CommandEndTxn endTxn = 56;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endtxn_);
    }

    // optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endtxnresponse_);
    }

    // optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endtxnonpartition_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endtxnonpartitionresponse_);
    }

    // optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endtxnonsubscription_);
    }

    // optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endtxnonsubscriptionresponse_);
    }

    // optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tcclientconnectrequest_);
    }

    // optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tcclientconnectresponse_);
    }

    // optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *watchtopiclist_);
    }

    // optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *watchtopiclistsuccess_);
    }

    // optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *watchtopicupdate_);
    }

  }
  if (cached_has_bits & 0x03000000u) {
    // optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *watchtopiclistclose_);
    }

    // optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *topicmigrated_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BaseCommand::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const BaseCommand*>(
      &from));
}

void BaseCommand::MergeFrom(const BaseCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.BaseCommand)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_connect()->::pulsar::proto::CommandConnect::MergeFrom(from._internal_connect());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_connected()->::pulsar::proto::CommandConnected::MergeFrom(from._internal_connected());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_subscribe()->::pulsar::proto::CommandSubscribe::MergeFrom(from._internal_subscribe());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_producer()->::pulsar::proto::CommandProducer::MergeFrom(from._internal_producer());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_send()->::pulsar::proto::CommandSend::MergeFrom(from._internal_send());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_send_receipt()->::pulsar::proto::CommandSendReceipt::MergeFrom(from._internal_send_receipt());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_send_error()->::pulsar::proto::CommandSendError::MergeFrom(from._internal_send_error());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_message()->::pulsar::proto::CommandMessage::MergeFrom(from._internal_message());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_ack()->::pulsar::proto::CommandAck::MergeFrom(from._internal_ack());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_flow()->::pulsar::proto::CommandFlow::MergeFrom(from._internal_flow());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_unsubscribe()->::pulsar::proto::CommandUnsubscribe::MergeFrom(from._internal_unsubscribe());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_success()->::pulsar::proto::CommandSuccess::MergeFrom(from._internal_success());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_error()->::pulsar::proto::CommandError::MergeFrom(from._internal_error());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_close_producer()->::pulsar::proto::CommandCloseProducer::MergeFrom(from._internal_close_producer());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_close_consumer()->::pulsar::proto::CommandCloseConsumer::MergeFrom(from._internal_close_consumer());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_producer_success()->::pulsar::proto::CommandProducerSuccess::MergeFrom(from._internal_producer_success());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_ping()->::pulsar::proto::CommandPing::MergeFrom(from._internal_ping());
    }
    if (cached_has_bits & 0x00020000u) {
      _internal_mutable_pong()->::pulsar::proto::CommandPong::MergeFrom(from._internal_pong());
    }
    if (cached_has_bits & 0x00040000u) {
      _internal_mutable_redeliverunacknowledgedmessages()->::pulsar::proto::CommandRedeliverUnacknowledgedMessages::MergeFrom(from._internal_redeliverunacknowledgedmessages());
    }
    if (cached_has_bits & 0x00080000u) {
      _internal_mutable_partitionmetadata()->::pulsar::proto::CommandPartitionedTopicMetadata::MergeFrom(from._internal_partitionmetadata());
    }
    if (cached_has_bits & 0x00100000u) {
      _internal_mutable_partitionmetadataresponse()->::pulsar::proto::CommandPartitionedTopicMetadataResponse::MergeFrom(from._internal_partitionmetadataresponse());
    }
    if (cached_has_bits & 0x00200000u) {
      _internal_mutable_lookuptopic()->::pulsar::proto::CommandLookupTopic::MergeFrom(from._internal_lookuptopic());
    }
    if (cached_has_bits & 0x00400000u) {
      _internal_mutable_lookuptopicresponse()->::pulsar::proto::CommandLookupTopicResponse::MergeFrom(from._internal_lookuptopicresponse());
    }
    if (cached_has_bits & 0x00800000u) {
      _internal_mutable_consumerstats()->::pulsar::proto::CommandConsumerStats::MergeFrom(from._internal_consumerstats());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _internal_mutable_consumerstatsresponse()->::pulsar::proto::CommandConsumerStatsResponse::MergeFrom(from._internal_consumerstatsresponse());
    }
    if (cached_has_bits & 0x02000000u) {
      _internal_mutable_reachedendoftopic()->::pulsar::proto::CommandReachedEndOfTopic::MergeFrom(from._internal_reachedendoftopic());
    }
    if (cached_has_bits & 0x04000000u) {
      _internal_mutable_seek()->::pulsar::proto::CommandSeek::MergeFrom(from._internal_seek());
    }
    if (cached_has_bits & 0x08000000u) {
      _internal_mutable_getlastmessageid()->::pulsar::proto::CommandGetLastMessageId::MergeFrom(from._internal_getlastmessageid());
    }
    if (cached_has_bits & 0x10000000u) {
      _internal_mutable_getlastmessageidresponse()->::pulsar::proto::CommandGetLastMessageIdResponse::MergeFrom(from._internal_getlastmessageidresponse());
    }
    if (cached_has_bits & 0x20000000u) {
      _internal_mutable_active_consumer_change()->::pulsar::proto::CommandActiveConsumerChange::MergeFrom(from._internal_active_consumer_change());
    }
    if (cached_has_bits & 0x40000000u) {
      _internal_mutable_gettopicsofnamespace()->::pulsar::proto::CommandGetTopicsOfNamespace::MergeFrom(from._internal_gettopicsofnamespace());
    }
    if (cached_has_bits & 0x80000000u) {
      _internal_mutable_gettopicsofnamespaceresponse()->::pulsar::proto::CommandGetTopicsOfNamespaceResponse::MergeFrom(from._internal_gettopicsofnamespaceresponse());
    }
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_getschema()->::pulsar::proto::CommandGetSchema::MergeFrom(from._internal_getschema());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_getschemaresponse()->::pulsar::proto::CommandGetSchemaResponse::MergeFrom(from._internal_getschemaresponse());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_authchallenge()->::pulsar::proto::CommandAuthChallenge::MergeFrom(from._internal_authchallenge());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_authresponse()->::pulsar::proto::CommandAuthResponse::MergeFrom(from._internal_authresponse());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_ackresponse()->::pulsar::proto::CommandAckResponse::MergeFrom(from._internal_ackresponse());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_getorcreateschema()->::pulsar::proto::CommandGetOrCreateSchema::MergeFrom(from._internal_getorcreateschema());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_getorcreateschemaresponse()->::pulsar::proto::CommandGetOrCreateSchemaResponse::MergeFrom(from._internal_getorcreateschemaresponse());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_newtxn()->::pulsar::proto::CommandNewTxn::MergeFrom(from._internal_newtxn());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_newtxnresponse()->::pulsar::proto::CommandNewTxnResponse::MergeFrom(from._internal_newtxnresponse());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_addpartitiontotxn()->::pulsar::proto::CommandAddPartitionToTxn::MergeFrom(from._internal_addpartitiontotxn());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_addpartitiontotxnresponse()->::pulsar::proto::CommandAddPartitionToTxnResponse::MergeFrom(from._internal_addpartitiontotxnresponse());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_addsubscriptiontotxn()->::pulsar::proto::CommandAddSubscriptionToTxn::MergeFrom(from._internal_addsubscriptiontotxn());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_addsubscriptiontotxnresponse()->::pulsar::proto::CommandAddSubscriptionToTxnResponse::MergeFrom(from._internal_addsubscriptiontotxnresponse());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_endtxn()->::pulsar::proto::CommandEndTxn::MergeFrom(from._internal_endtxn());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_endtxnresponse()->::pulsar::proto::CommandEndTxnResponse::MergeFrom(from._internal_endtxnresponse());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_endtxnonpartition()->::pulsar::proto::CommandEndTxnOnPartition::MergeFrom(from._internal_endtxnonpartition());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_endtxnonpartitionresponse()->::pulsar::proto::CommandEndTxnOnPartitionResponse::MergeFrom(from._internal_endtxnonpartitionresponse());
    }
    if (cached_has_bits & 0x00020000u) {
      _internal_mutable_endtxnonsubscription()->::pulsar::proto::CommandEndTxnOnSubscription::MergeFrom(from._internal_endtxnonsubscription());
    }
    if (cached_has_bits & 0x00040000u) {
      _internal_mutable_endtxnonsubscriptionresponse()->::pulsar::proto::CommandEndTxnOnSubscriptionResponse::MergeFrom(from._internal_endtxnonsubscriptionresponse());
    }
    if (cached_has_bits & 0x00080000u) {
      _internal_mutable_tcclientconnectrequest()->::pulsar::proto::CommandTcClientConnectRequest::MergeFrom(from._internal_tcclientconnectrequest());
    }
    if (cached_has_bits & 0x00100000u) {
      _internal_mutable_tcclientconnectresponse()->::pulsar::proto::CommandTcClientConnectResponse::MergeFrom(from._internal_tcclientconnectresponse());
    }
    if (cached_has_bits & 0x00200000u) {
      _internal_mutable_watchtopiclist()->::pulsar::proto::CommandWatchTopicList::MergeFrom(from._internal_watchtopiclist());
    }
    if (cached_has_bits & 0x00400000u) {
      _internal_mutable_watchtopiclistsuccess()->::pulsar::proto::CommandWatchTopicListSuccess::MergeFrom(from._internal_watchtopiclistsuccess());
    }
    if (cached_has_bits & 0x00800000u) {
      _internal_mutable_watchtopicupdate()->::pulsar::proto::CommandWatchTopicUpdate::MergeFrom(from._internal_watchtopicupdate());
    }
  }
  if (cached_has_bits & 0x07000000u) {
    if (cached_has_bits & 0x01000000u) {
      _internal_mutable_watchtopiclistclose()->::pulsar::proto::CommandWatchTopicListClose::MergeFrom(from._internal_watchtopiclistclose());
    }
    if (cached_has_bits & 0x02000000u) {
      _internal_mutable_topicmigrated()->::pulsar::proto::CommandTopicMigrated::MergeFrom(from._internal_topicmigrated());
    }
    if (cached_has_bits & 0x04000000u) {
      type_ = from.type_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BaseCommand::CopyFrom(const BaseCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.BaseCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseCommand::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_connect()) {
    if (!connect_->IsInitialized()) return false;
  }
  if (_internal_has_connected()) {
    if (!connected_->IsInitialized()) return false;
  }
  if (_internal_has_subscribe()) {
    if (!subscribe_->IsInitialized()) return false;
  }
  if (_internal_has_producer()) {
    if (!producer_->IsInitialized()) return false;
  }
  if (_internal_has_send()) {
    if (!send_->IsInitialized()) return false;
  }
  if (_internal_has_send_receipt()) {
    if (!send_receipt_->IsInitialized()) return false;
  }
  if (_internal_has_send_error()) {
    if (!send_error_->IsInitialized()) return false;
  }
  if (_internal_has_message()) {
    if (!message_->IsInitialized()) return false;
  }
  if (_internal_has_ack()) {
    if (!ack_->IsInitialized()) return false;
  }
  if (_internal_has_flow()) {
    if (!flow_->IsInitialized()) return false;
  }
  if (_internal_has_unsubscribe()) {
    if (!unsubscribe_->IsInitialized()) return false;
  }
  if (_internal_has_success()) {
    if (!success_->IsInitialized()) return false;
  }
  if (_internal_has_error()) {
    if (!error_->IsInitialized()) return false;
  }
  if (_internal_has_close_producer()) {
    if (!close_producer_->IsInitialized()) return false;
  }
  if (_internal_has_close_consumer()) {
    if (!close_consumer_->IsInitialized()) return false;
  }
  if (_internal_has_producer_success()) {
    if (!producer_success_->IsInitialized()) return false;
  }
  if (_internal_has_redeliverunacknowledgedmessages()) {
    if (!redeliverunacknowledgedmessages_->IsInitialized()) return false;
  }
  if (_internal_has_partitionmetadata()) {
    if (!partitionmetadata_->IsInitialized()) return false;
  }
  if (_internal_has_partitionmetadataresponse()) {
    if (!partitionmetadataresponse_->IsInitialized()) return false;
  }
  if (_internal_has_lookuptopic()) {
    if (!lookuptopic_->IsInitialized()) return false;
  }
  if (_internal_has_lookuptopicresponse()) {
    if (!lookuptopicresponse_->IsInitialized()) return false;
  }
  if (_internal_has_consumerstats()) {
    if (!consumerstats_->IsInitialized()) return false;
  }
  if (_internal_has_consumerstatsresponse()) {
    if (!consumerstatsresponse_->IsInitialized()) return false;
  }
  if (_internal_has_reachedendoftopic()) {
    if (!reachedendoftopic_->IsInitialized()) return false;
  }
  if (_internal_has_seek()) {
    if (!seek_->IsInitialized()) return false;
  }
  if (_internal_has_getlastmessageid()) {
    if (!getlastmessageid_->IsInitialized()) return false;
  }
  if (_internal_has_getlastmessageidresponse()) {
    if (!getlastmessageidresponse_->IsInitialized()) return false;
  }
  if (_internal_has_active_consumer_change()) {
    if (!active_consumer_change_->IsInitialized()) return false;
  }
  if (_internal_has_gettopicsofnamespace()) {
    if (!gettopicsofnamespace_->IsInitialized()) return false;
  }
  if (_internal_has_gettopicsofnamespaceresponse()) {
    if (!gettopicsofnamespaceresponse_->IsInitialized()) return false;
  }
  if (_internal_has_getschema()) {
    if (!getschema_->IsInitialized()) return false;
  }
  if (_internal_has_getschemaresponse()) {
    if (!getschemaresponse_->IsInitialized()) return false;
  }
  if (_internal_has_ackresponse()) {
    if (!ackresponse_->IsInitialized()) return false;
  }
  if (_internal_has_getorcreateschema()) {
    if (!getorcreateschema_->IsInitialized()) return false;
  }
  if (_internal_has_getorcreateschemaresponse()) {
    if (!getorcreateschemaresponse_->IsInitialized()) return false;
  }
  if (_internal_has_newtxn()) {
    if (!newtxn_->IsInitialized()) return false;
  }
  if (_internal_has_newtxnresponse()) {
    if (!newtxnresponse_->IsInitialized()) return false;
  }
  if (_internal_has_addpartitiontotxn()) {
    if (!addpartitiontotxn_->IsInitialized()) return false;
  }
  if (_internal_has_addpartitiontotxnresponse()) {
    if (!addpartitiontotxnresponse_->IsInitialized()) return false;
  }
  if (_internal_has_addsubscriptiontotxn()) {
    if (!addsubscriptiontotxn_->IsInitialized()) return false;
  }
  if (_internal_has_addsubscriptiontotxnresponse()) {
    if (!addsubscriptiontotxnresponse_->IsInitialized()) return false;
  }
  if (_internal_has_endtxn()) {
    if (!endtxn_->IsInitialized()) return false;
  }
  if (_internal_has_endtxnresponse()) {
    if (!endtxnresponse_->IsInitialized()) return false;
  }
  if (_internal_has_endtxnonpartition()) {
    if (!endtxnonpartition_->IsInitialized()) return false;
  }
  if (_internal_has_endtxnonpartitionresponse()) {
    if (!endtxnonpartitionresponse_->IsInitialized()) return false;
  }
  if (_internal_has_endtxnonsubscription()) {
    if (!endtxnonsubscription_->IsInitialized()) return false;
  }
  if (_internal_has_endtxnonsubscriptionresponse()) {
    if (!endtxnonsubscriptionresponse_->IsInitialized()) return false;
  }
  if (_internal_has_tcclientconnectrequest()) {
    if (!tcclientconnectrequest_->IsInitialized()) return false;
  }
  if (_internal_has_tcclientconnectresponse()) {
    if (!tcclientconnectresponse_->IsInitialized()) return false;
  }
  if (_internal_has_watchtopiclist()) {
    if (!watchtopiclist_->IsInitialized()) return false;
  }
  if (_internal_has_watchtopiclistsuccess()) {
    if (!watchtopiclistsuccess_->IsInitialized()) return false;
  }
  if (_internal_has_watchtopicupdate()) {
    if (!watchtopicupdate_->IsInitialized()) return false;
  }
  if (_internal_has_watchtopiclistclose()) {
    if (!watchtopiclistclose_->IsInitialized()) return false;
  }
  if (_internal_has_topicmigrated()) {
    if (!topicmigrated_->IsInitialized()) return false;
  }
  return true;
}

void BaseCommand::InternalSwap(BaseCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BaseCommand, topicmigrated_)
      + sizeof(BaseCommand::topicmigrated_)
      - PROTOBUF_FIELD_OFFSET(BaseCommand, connect_)>(
          reinterpret_cast<char*>(&connect_),
          reinterpret_cast<char*>(&other->connect_));
  swap(type_, other->type_);
}

std::string BaseCommand::GetTypeName() const {
  return "pulsar.proto.BaseCommand";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace pulsar
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pulsar::proto::Schema* Arena::CreateMaybeMessage< ::pulsar::proto::Schema >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::Schema >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::MessageIdData* Arena::CreateMaybeMessage< ::pulsar::proto::MessageIdData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::MessageIdData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::KeyValue* Arena::CreateMaybeMessage< ::pulsar::proto::KeyValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::KeyValue >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::KeyLongValue* Arena::CreateMaybeMessage< ::pulsar::proto::KeyLongValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::KeyLongValue >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::IntRange* Arena::CreateMaybeMessage< ::pulsar::proto::IntRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::IntRange >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::EncryptionKeys* Arena::CreateMaybeMessage< ::pulsar::proto::EncryptionKeys >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::EncryptionKeys >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::MessageMetadata* Arena::CreateMaybeMessage< ::pulsar::proto::MessageMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::MessageMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::SingleMessageMetadata* Arena::CreateMaybeMessage< ::pulsar::proto::SingleMessageMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::SingleMessageMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::BrokerEntryMetadata* Arena::CreateMaybeMessage< ::pulsar::proto::BrokerEntryMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::BrokerEntryMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandConnect* Arena::CreateMaybeMessage< ::pulsar::proto::CommandConnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandConnect >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::FeatureFlags* Arena::CreateMaybeMessage< ::pulsar::proto::FeatureFlags >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::FeatureFlags >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandConnected* Arena::CreateMaybeMessage< ::pulsar::proto::CommandConnected >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandConnected >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandAuthResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandAuthResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandAuthResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandAuthChallenge* Arena::CreateMaybeMessage< ::pulsar::proto::CommandAuthChallenge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandAuthChallenge >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::AuthData* Arena::CreateMaybeMessage< ::pulsar::proto::AuthData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::AuthData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::KeySharedMeta* Arena::CreateMaybeMessage< ::pulsar::proto::KeySharedMeta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::KeySharedMeta >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandSubscribe* Arena::CreateMaybeMessage< ::pulsar::proto::CommandSubscribe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandSubscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandPartitionedTopicMetadata* Arena::CreateMaybeMessage< ::pulsar::proto::CommandPartitionedTopicMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandPartitionedTopicMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandPartitionedTopicMetadataResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandPartitionedTopicMetadataResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandPartitionedTopicMetadataResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandLookupTopic* Arena::CreateMaybeMessage< ::pulsar::proto::CommandLookupTopic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandLookupTopic >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandLookupTopicResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandLookupTopicResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandLookupTopicResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandProducer* Arena::CreateMaybeMessage< ::pulsar::proto::CommandProducer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandProducer >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandSend* Arena::CreateMaybeMessage< ::pulsar::proto::CommandSend >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandSend >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandSendReceipt* Arena::CreateMaybeMessage< ::pulsar::proto::CommandSendReceipt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandSendReceipt >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandSendError* Arena::CreateMaybeMessage< ::pulsar::proto::CommandSendError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandSendError >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandMessage* Arena::CreateMaybeMessage< ::pulsar::proto::CommandMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandAck* Arena::CreateMaybeMessage< ::pulsar::proto::CommandAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandAck >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandAckResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandAckResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandAckResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandActiveConsumerChange* Arena::CreateMaybeMessage< ::pulsar::proto::CommandActiveConsumerChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandActiveConsumerChange >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandFlow* Arena::CreateMaybeMessage< ::pulsar::proto::CommandFlow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandFlow >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandUnsubscribe* Arena::CreateMaybeMessage< ::pulsar::proto::CommandUnsubscribe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandUnsubscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandSeek* Arena::CreateMaybeMessage< ::pulsar::proto::CommandSeek >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandSeek >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandReachedEndOfTopic* Arena::CreateMaybeMessage< ::pulsar::proto::CommandReachedEndOfTopic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandReachedEndOfTopic >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandTopicMigrated* Arena::CreateMaybeMessage< ::pulsar::proto::CommandTopicMigrated >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandTopicMigrated >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandCloseProducer* Arena::CreateMaybeMessage< ::pulsar::proto::CommandCloseProducer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandCloseProducer >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandCloseConsumer* Arena::CreateMaybeMessage< ::pulsar::proto::CommandCloseConsumer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandCloseConsumer >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* Arena::CreateMaybeMessage< ::pulsar::proto::CommandRedeliverUnacknowledgedMessages >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandRedeliverUnacknowledgedMessages >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandSuccess* Arena::CreateMaybeMessage< ::pulsar::proto::CommandSuccess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandSuccess >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandProducerSuccess* Arena::CreateMaybeMessage< ::pulsar::proto::CommandProducerSuccess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandProducerSuccess >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandError* Arena::CreateMaybeMessage< ::pulsar::proto::CommandError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandError >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandPing* Arena::CreateMaybeMessage< ::pulsar::proto::CommandPing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandPing >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandPong* Arena::CreateMaybeMessage< ::pulsar::proto::CommandPong >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandPong >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandConsumerStats* Arena::CreateMaybeMessage< ::pulsar::proto::CommandConsumerStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandConsumerStats >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandConsumerStatsResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandConsumerStatsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandConsumerStatsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandGetLastMessageId* Arena::CreateMaybeMessage< ::pulsar::proto::CommandGetLastMessageId >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandGetLastMessageId >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandGetLastMessageIdResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandGetLastMessageIdResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandGetLastMessageIdResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandGetTopicsOfNamespace* Arena::CreateMaybeMessage< ::pulsar::proto::CommandGetTopicsOfNamespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandGetTopicsOfNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandGetTopicsOfNamespaceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandGetTopicsOfNamespaceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandWatchTopicList* Arena::CreateMaybeMessage< ::pulsar::proto::CommandWatchTopicList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandWatchTopicList >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandWatchTopicListSuccess* Arena::CreateMaybeMessage< ::pulsar::proto::CommandWatchTopicListSuccess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandWatchTopicListSuccess >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandWatchTopicUpdate* Arena::CreateMaybeMessage< ::pulsar::proto::CommandWatchTopicUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandWatchTopicUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandWatchTopicListClose* Arena::CreateMaybeMessage< ::pulsar::proto::CommandWatchTopicListClose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandWatchTopicListClose >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandGetSchema* Arena::CreateMaybeMessage< ::pulsar::proto::CommandGetSchema >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandGetSchema >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandGetSchemaResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandGetSchemaResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandGetSchemaResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandGetOrCreateSchema* Arena::CreateMaybeMessage< ::pulsar::proto::CommandGetOrCreateSchema >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandGetOrCreateSchema >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandGetOrCreateSchemaResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandGetOrCreateSchemaResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandGetOrCreateSchemaResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandTcClientConnectRequest* Arena::CreateMaybeMessage< ::pulsar::proto::CommandTcClientConnectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandTcClientConnectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandTcClientConnectResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandTcClientConnectResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandTcClientConnectResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandNewTxn* Arena::CreateMaybeMessage< ::pulsar::proto::CommandNewTxn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandNewTxn >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandNewTxnResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandNewTxnResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandNewTxnResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandAddPartitionToTxn* Arena::CreateMaybeMessage< ::pulsar::proto::CommandAddPartitionToTxn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandAddPartitionToTxn >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandAddPartitionToTxnResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandAddPartitionToTxnResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandAddPartitionToTxnResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::Subscription* Arena::CreateMaybeMessage< ::pulsar::proto::Subscription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::Subscription >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandAddSubscriptionToTxn* Arena::CreateMaybeMessage< ::pulsar::proto::CommandAddSubscriptionToTxn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandAddSubscriptionToTxn >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandAddSubscriptionToTxnResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandAddSubscriptionToTxnResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandAddSubscriptionToTxnResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandEndTxn* Arena::CreateMaybeMessage< ::pulsar::proto::CommandEndTxn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandEndTxn >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandEndTxnResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandEndTxnResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandEndTxnResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandEndTxnOnPartition* Arena::CreateMaybeMessage< ::pulsar::proto::CommandEndTxnOnPartition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandEndTxnOnPartition >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandEndTxnOnPartitionResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandEndTxnOnPartitionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandEndTxnOnPartitionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandEndTxnOnSubscription* Arena::CreateMaybeMessage< ::pulsar::proto::CommandEndTxnOnSubscription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandEndTxnOnSubscription >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* Arena::CreateMaybeMessage< ::pulsar::proto::CommandEndTxnOnSubscriptionResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::CommandEndTxnOnSubscriptionResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::pulsar::proto::BaseCommand* Arena::CreateMaybeMessage< ::pulsar::proto::BaseCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pulsar::proto::BaseCommand >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
